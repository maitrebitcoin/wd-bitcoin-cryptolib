#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : compilateurDeFormule
 major_version : 25
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x1e42616f00e6a6ee
 internal_properties : BQAAAAUAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  type_code : 10
  p_codes :
   -
     code : |1-
      // compile des formules simple vers un code ASM x86 qui exécute le calcul
      //=>pour calcul rapide K*P sur courbe elliptique.
      // Ex:
      // A = B*B
      // C = A+B
      // D = A+C+B
      compilateurDeFormule est une Classe
      	// proto tel que déclaré dans le code. ex  "PointDouble(X, Y, Z)"
      	sPrototypeSource		est chaine 
      	// variable de la formule
      	tabVariables			est un tableau associatif de STVariable
      	// fonctions utilisables dans la formule
      	tabFunction				est un tableau associatif de STFonction
      	// Nb de paramètre et var locale
      	nbParametre				est entier
      	nbVarLocale				est entier
      	// options
      	bAvecCommentaire		est un booléen	// mets des commentaire dans l'ASM généré
      	
      	// indique que certaines var doivent être mise en registre pour optim
      	tabOptimVarVersReg 	est un tableau associatif de chaine
      	
      	// indique sur quelle adresse les registres pointent apres chaque ligne de code générée
      	tabRegVersVar	est un tableau associatif de chaine
      	tabVarVersReg	est un tableau associatif de chaine
      FIN
      // types de variables gérées
      ETypeVar est une énumération
      	PUI256      // pointeur sur un entier 256 bits (paramètres uniquement)
      	PST256_XYZ  // pointeur sur une structure de 3 entier 256 bits X,Y,Z (paramètres uniquement)
      	UI256  		// entier 256 bits (var locale uniquement )
      	UI8    	    // entier sur 8
      fin
      EPortée est une énumération
      	paramètre
      	variableLocale
      FIN
      // 1 variables
      STVariable est une structure
      	nom		     est chaine		// nom de la variable
      	type	     est ETypeVar	// type de la variable
      	portée	     est EPortée	// porte de la variable
      	indice	     est entier		// n° de la variable dans sa portée, commence a 0
      	offsetStruct est entier    // si la variable est dans une structure (ex: P.Z), offset par rapport au début (32 ou 64)
      fin 
      // 1 fonction
      STFonction est un structure
      	nom					est chaine					//  ex "*" ou "+"
      	addresse			est entier système			// adresse a appelle par "call"
      	tabTypeParamètre	est un tableau de ETypeVar	// ex : [PUI256,PUI256,PUI256]
      fin
      
      // 1 formule parsée
      STFormuleParsee est une structure
      	// source
      	numLigne		est entier
      	ligneSource		est chaine
      	// résultat du parsing
      	nomVarDest		est chaîne 
      	operateur		est chaîne	// ex : "*" ou "-"
      	var1			est chaine  // ex "X" ou "3"
      	var2			est chaine
      	bvar1EstLiteral est booléen // vrai si var1 représente un litéral
      fin
      
      
      // taille en octet des type gérés
      constant nTaille_INT256 = 32 
      // nom de type gérés
      constant sNomType_POINT32 = "Point3D"
      
      // taille prise pas un registre
      CONSTANT nTaille_REG = 8
      
      // Erreur levée si pb
      constant ERR_COMPILATION_FORMULE = 55
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 2180412298985187054
     type_code : 27
     code : |1+
      PROCEDURE Constructeur()
      
      :bAvecCommentaire = EnModeTest()
     type : 589824
   -
     name : Destructeur
     procedure_id : 2180412298985252590
     type_code : 28
     code : |1+
      PROCEDURE Destructeur()
     type : 655360
   -
     name : _declarePrototype
     procedure_id : 2181992559179551443
     type_code : 12
     code : |1+
      // déclare le prototype (ie les paramètres de la fonction a générér)
      // ex: PointDouble(X,Y,Z)
      procédure privée _declarePrototype( sProto est chaine )
      
      
      //
      nPosDebut est entier = position(sProto,"(")
      si nPosDebut<=0 ALORS
      	ErreurDéclenche(ERR_COMPILATION_FORMULE,"Erreur de syntaxe dans le proto : " + sProto)
      	retour
      FIN
      nPosFin est entier = position(sProto,")", nPosDebut+1)
      SI nPosDebut<=0 ALORS
      	ErreurDéclenche(ERR_COMPILATION_FORMULE,"Erreur de syntaxe dans le proto : " + sProto)
      	RETOUR
      FIN
      // garder le proto
      :sPrototypeSource = sProto
      
      // extraire les paramètres
      sListeParam est chaine = milieu(sProto, nPosDebut+1, nPosFin-nPosDebut-1 )
      sListeParam = SansEspace(sListeParam)
      sExprParametreI est chaine
      pour TOUTE CHAÎNE sExprParametreI DE sListeParam SÉPARÉE PAR ","
      	sExprParametreI  = SansEspace(sExprParametreI)
      	typeParamètre est ETypeVar = PUI256 
      	// si le type est défini.
      	// ex :"P Point3D"
      	sNomParametre est chaine = sExprParametreI
      	sNomType      est chaine = ExtraitChaîne(sExprParametreI,2," ")
      	si sNomType<>EOT ALORS
      		// seul type supporté
      		si sNomType=sNomType_POINT32 ALORS
      			sNomParametre = ExtraitChaîne(sExprParametreI,1," ")
      			typeParamètre = PST256_XYZ
      		sinon
      			ErreurDéclenche(ERR_COMPILATION_FORMULE,"type non géré : " + sNomType )
      			RETOUR
      		FIN
      	FIN
      	
      	// on déclare le paramètre 
      	_déclareParamètre(sNomParametre, typeParamètre)
      FIN
      	
      
      
     type : 458752
   -
     name : _déclareParamètre
     procedure_id : 2180413497281210159
     type_code : 12
     code : |1+
      procédure privée _déclareParamètre( nom chaine, type ETypeVar )
      dbgAssertion(nom<>"")
      dbgAssertion(pas tabVariables[nom]..existe)
      
      // déclare un paramètre
      newVar est un STVariable
      newVar.nom  = nom
      newVar.type = type
      newVar.portée = paramètre
      newVar.indice = :nbParametre 
      nbParametre++;
      // ajoute la variable
      tabVariables[nom] = newVar
     type : 458752
   -
     name : déclareOpérateurBinaire
     procedure_id : 2180631273598065125
     type_code : 12
     code : |1+
      // déclare un opérateur comme "*" ou "+"
      procédure déclareOpérateurBinaire( nom chaine, adresseProcédure entier système, typeParam2 ETypeVar = PUI256 )
      dbgActiveAssertion(nom<>"")
      dbgActiveAssertion(adresseProcédure<>0)
      
      newFonc est STFonction
      newFonc.nom = nom
      newFonc.addresse = adresseProcédure
      pour i = 1 a 3
      	// P0 et P1 : IN
      	// P2       : OUT
      	eTypeParam_I est ETypeVar = PUI256
      	si i=2 ALORS
      		eTypeParam_I = typeParam2
      	FIN
      	newFonc.tabTypeParamètre.Ajoute( eTypeParam_I )
      FIN
      // ajoute la fonction qui gère l'opérateur
      tabFunction[nom] = newFonc
      
     type : 458752
   -
     name : declareOptimRegistre
     procedure_id : 2182446623217186059
     type_code : 12
     code : |1-
      // <nomRegistre> doit être R12, R13, R14, R15
      procédure declareOptimRegistre( nomVar chaine, nomRegistre chaine )
      // The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15 are considered nonvolatile (callee-saved).[20]
      
      tabOptimVarVersReg[nomVar] = nomRegistre
      
      // ajout comme registre utilisable
      :_VarUtiliseRegistre(nomVar,nomRegistre)
     type : 458752
   -
     name : _bTok_EstNombre
     procedure_id : 2181867043071814814
     type_code : 12
     code : |1+
      // indique si <sToken> est un nombre. ex "4"
      procédure _bTok_EstNombre( sToken chaine) 
      
      renvoyer VérifieExpressionRégulière(sToken,"[0-9]*")
     type : 458752
   -
     name : _bParse
     procedure_id : 2181489094526545596
     type_code : 12
     code : |1+
      // analyse syntaxique de <sCode>
      procédure privee _bParse( sCode chaine, resultat tableau de STFormuleParsee, sProto_OUT chaine ) : booléen
      
      // parsing ligne a ligne
      // Ex de code attendu :
      // A = B*B
      // C = A+B
      // D = A-C
      nLigne			est un entier	= 1
      POUR TOUTE CHAÎNE sCodeLigneI DE sCode séparée par RC
      	// la 1er ligne est le prototype
      	si nLigne=1 ALORS
      		sProto_OUT = sCodeLigneI
      		nLigne++
      		continuer
      	FIN
      	// la suite est le code
      	stLigneI est STFormuleParsee
      	stLigneI.numLigne		= nLigne
      	stLigneI.ligneSource	= sCodeLigneI
      	// découpe "A=B+C" en ses parties
      	ligneSansEspace	est chaine	= SansEspace( sCodeLigneI,sscTout )
      	ligneSansEspace = Remplace(ligneSansEspace, TAB,"") 
      	// enlever les commentaires à droite de //
      	si position( ligneSansEspace , "//") >0 ALORS
      		ligneSansEspace = ExtraitChaîne(ligneSansEspace,1,"//")
      	FIN
      	// ignorer les lignes vides
      	si ligneSansEspace="" ALORS
      		nLigne++;
      		continuer;
      	FIN
      	
      	nomVarDest		est chaine	= ExtraitChaîne( ligneSansEspace, 1, "=" )
      	codeOpération	est chaîne	= ExtraitChaîne( ligneSansEspace, 2, "=" )
      	SI nomVarDest="" _OU_ codeOpération="" ALORS
      		ErreurDéclenche(ERR_COMPILATION_FORMULE,"erreur de syntaxe : "  +  sCodeLigneI )
      		RENVOYER 0 // Erreur
      	FIN	
      	// extrait opérateur et opérande
      	var1		est chaine
      	var2		est chaine
      	operateur	est chaine	// ex : "*"
      	SI PAS _bParseOpération( codeOpération,var1,var2, operateur ) ALORS
      		ErreurDéclenche(ERR_COMPILATION_FORMULE,"erreur de syntaxe : "  +  sCodeLigneI  )
      		RENVOYER faux // erreur
      	FIN
      	// récup fonction 
      	SI PAS :tabFunction[operateur]..Existe ALORS
      		ErreurDéclenche(ERR_COMPILATION_FORMULE,"opérateur inconnu : "  +  operateur )
      		RENVOYER faux
      	FIN	
      	// OK affectation
      	stLigneI.operateur		= operateur
      	stLigneI.nomVarDest		= nomVarDest
      	stLigneI.var1			= var1
      	stLigneI.var2			= var2
      	// gestion des littéraux (ex "4")
      	si _bTok_EstNombre(var1) ALORS
      		stLigneI.bvar1EstLiteral = vrai
      	FIN
      	resultat.Ajoute(stLigneI)
      	
      	// ligne suivante
      	nLigne++
      FIN
      // OK
      renvoyer vrai
     type : 458752
   -
     name : _bChercheVariableParNom
     procedure_id : 2182270289013573270
     type_code : 12
     code : |1-
      // recheche une variable a partir de son nom
      procédure _bChercheVariableParNom( sNomVar est chaine ) : (booléen, STVariable )
      
      // cas de P.X, P.Y, ....
      si position(sNomVar,".")>0 ALORS
      	sNomStruct est chaine = ExtraitChaîne(sNomVar,1,".")
      	sNomMembre est chaine = ExtraitChaîne(sNomVar,2,".")
      	SI PAS :tabVariables[sNomStruct]..Existe ALORS
      		stVarVide est STVariable
      		RENVOYER (Faux, stVarVide)
      	FIN
      	stVarResultat est STVariable = tabVariables[sNomStruct]
      	// offset selon le membre
      	selon sNomMembre
      		cas "X" : stVarResultat.offsetStruct = 0
      		cas "Y" : stVarResultat.offsetStruct = 32
      		cas "Z" : stVarResultat.offsetStruct = 64
      		AUTRE CAS
      			// non géré
      			dbgAssertion(Faux, sNomMembre) 
      	FIN
      	// var trouvée et initialisée
      	renvoyer (vrai, stVarResultat)
      FIN
      
      
      si pas :tabVariables[sNomVar]..Existe ALORS
      	stVarVide est STVariable
      	renvoyer (faux, stVarVide)
      FIN
      // OK variable trouvée
      renvoyer (vrai, :tabVariables[sNomVar] )
     type : 458752
   -
     name : compileFormule
     procedure_id : 2180632166951339637
     type_code : 12
     code : |1+
      // compile une formule.
      // renvoie l'adresse pour l'exécuter par API ou 0 (erreur)
      procédure compileFormule( sCode est chaine ) : entier système
      
      
      // parsing
      sProto est chaine
      résultatParsing est un tableau de STFormuleParsee
      si pas _bParse( sCode, résultatParsing, sProto) ALORS
      	renvoyer  0 // erreur
      FIN
      // Init proto
      _declarePrototype(sProto)
      si ErreurDétectée ALORS
      	RENVOYER  0 // erreur
      FIN
      
      
      
      // 1er passe pour déclarer les variable et vérifier qu'elle ne sont pas utilisée avant l'affectation
      // parcourt des lignes a compiler 
      stLigneI est STFormuleParsee
      POUR TOUT stLigneI de résultatParsing
      	bVarExiste est un booléen
      	// si un var source est utilisé non déclarée
      	si pas stLigneI.bvar1EstLiteral alors // ignorer les littéraux
      		bVarExiste = _bChercheVariableParNom( stLigneI.var1 ) 
      		SI PAS bVarExiste  ALORS
      			ErreurDéclenche(ERR_COMPILATION_FORMULE,"variable inconnue : "  + stLigneI.var1  )
      			RENVOYER  0 // erreur
      		FIN
      	fin
      	bVarExiste = _bChercheVariableParNom( stLigneI.var2 ) 
      	SI PAS bVarExiste ALORS
      		ErreurDéclenche(ERR_COMPILATION_FORMULE,"variable inconnue : "  + stLigneI.var2  )
      		RENVOYER  0 // erreur
      	FIN	
      	// si une var est inconnue on la déclare
      	SI PAS :tabVariables[stLigneI.nomVarDest]..Existe ALORS
      		_déclareVariableLocale( stLigneI.nomVarDest )
      	FIN
      fin
      
      // Affection initiale des registre  (pour OPTIM)
      // en entrée les 4 paramètres d'entrés au max sont dans des registres
      pour tout stVar de :tabVariables
      	si stVar.portée = paramètre _et_ stVar.indice<=3 ALORS
      		// ex: T["param2"] = "rdx"
      		sReg est chaine =  _sGetNomRegPourParamNum64(stVar.indice+1)
      		_VarUtiliseRegistre( stVar.nom, sReg )
      	FIN
      FIN
      
      
      // 2eme passe : génération du code
      sCodeAsm est chaine
      POUR TOUT stLigneI DE résultatParsing
      	// génération du code ASM pour la ligne
      	SI :bAvecCommentaire alors 
      		sCodeAsm += [RC] + "; ("  + Complète( stLigneI.numLigne, 4 ) + ")    " +  stLigneI.ligneSource
      	FIN
      	// récup fonction qui effectue le calcul
      	soit func <-	:tabFunction[stLigneI.operateur]
      	
      	// génération du code pour l'opération
      	// ex : 
      	//	; X=B*B
      	//	mov rcx,[rsp-8]
      	//	mov rdx,rcx
      	//	lea r8,[rbp]
      	//	call 0x000178EE780198	
      	
      	//@Cas particulier "3.X"
      	si stLigneI.bvar1EstLiteral ALORS
      		dbgAssertion(func.nom=".")
      		//@@On inverse P1/P2
      		sCodeAsm += [RC] + "mov " + _sGetNomRegPourParamNum64(2) + "," +  stLigneI.var1
      		_VarDissocieRegiste(_sGetNomRegPourParamNum64(2))
      		sCodeAsm += [RC] + _genCodeAsmInitParam( 0, stLigneI.var2 )
      		sCodeAsm += [RC] + _genCodeAsmInitParam( 2, stLigneI.nomVarDest ) // OUT
      	sinon
      		sCodeAsm += [RC] + _genCodeAsmInitParam( 0, stLigneI.var1 )
      		sCodeAsm += [RC] + _genCodeAsmInitParam( 1, stLigneI.var2 )
      		sCodeAsm += [RC] + _genCodeAsmInitParam( 2, stLigneI.nomVarDest ) // OUT
      	fin
      	sCodeAsm += [RC] + "call 0x" + EntierVersHexa(  func.addresse )
      	// apres un call certains registre peuvent être modifié:
      	_VarDissocieApresCall()
      FIN
      
      // on génère le prologue et l'épilogue
      sCodeFinal est chaine
      SI :bAvecCommentaire sCodeFinal += [RC] + "; " + :sPrototypeSource
      sCodeFinal += [RC] + _genCodeAsm_Prologue()
      SI :bAvecCommentaire sCodeFinal += [RC] + "; Code principal" + rc
      sCodeFinal += [RC] + sCodeAsm
      sCodeFinal += [RC] + _genCodeAsm_Epilogue()
      
      // on compile le code ASM => code machine
      pResultat est un entier système
      sErr est chaine
      (pResultat,sErr) = compileAsmX86_API(sCodeFinal)
      dbgAssertion(pResultat<>0,sErr)
      
      renvoyer pResultat
     type : 458752
   -
     name : _déclareVariableLocale
     procedure_id : 2180636491983431122
     type_code : 12
     code : |1+
      // déclare une variable locale de nom <nom>
      procédure privée _déclareVariableLocale( nom chaine )
      dbgAssertion(pas :tabVariables[nom]..Existe)
      
      newVar est un STVariable
      newVar.nom		= nom
      newVar.type		= UI256
      newVar.portée	= variableLocale
      newVar.indice	= :nbVarLocale
      nbVarLocale++;
      // ajoute la variable
      tabVariables[nom] = newVar
      
     type : 458752
   -
     name : _bParseOpération
     procedure_id : 2180637033149370367
     type_code : 12
     code : |1+
      	// extrait opérateur et opérande
      procédure PRIVÉE  _bParseOpération( expression chaine, var1_out chaine, var2_out chaine, operation_out chaine ): booléen
      
      // vérification pour 1 opérateur
      procédure interne _bParseUnOpérateur( _expression est chaine,  _opérateurATester chaine, _var1_out chaine, _var2_out chaine, _operation_out chaine )
      	SI Position(_expression, _opérateurATester)>0 ALORS
      		_var1_out		= ExtraitChaîne(_expression,1, _opérateurATester)
      		_var2_out		= ExtraitChaîne(_expression,2, _opérateurATester)
      		_operation_out  = _opérateurATester 
      		RENVOYER Vrai
      	FIN
      	// pas OK 
      	renvoyer faux
      fin
      
      // A*B
      si _bParseUnOpérateur(expression,"*", var1_out,var2_out,operation_out ) ALORS
      	renvoyer Vrai	
      FIN
      // A+B
      SI _bParseUnOpérateur(expression,"+", var1_out,var2_out,operation_out ) ALORS
      	RENVOYER Vrai	
      FIN
      // A-B
      SI _bParseUnOpérateur(expression,"-", var1_out,var2_out,operation_out ) ALORS
      	RENVOYER Vrai	
      FIN
      // 3.B => a la fin pour que "P.X" soit prioritaire
      SI _bParseUnOpérateur(expression,".", var1_out,var2_out,operation_out ) ALORS
      	RENVOYER Vrai	
      FIN
      
      // erreur de syntaxe
      renvoyer faux
     type : 458752
   -
     name : _GetLocalisationVariable
     procedure_id : 2182448865190178038
     type_code : 12
     code : |1+
      // renvoie l'adresse d'une variable + si elle est dans un registre
      // ex: ([esp+40], faux) ou (rax, vrai)
      procédure _GetLocalisationVariable( varI est STVariable, bPourPrologue = faux ) : (chaine, booléen)
      
      
      
      // SOURCE : ou récupérer la valeur de varI
      varI_location	est chaine	// morceau de code pour la source. ex [rsp+8]
      bScrRegistre	est un booléen	= faux
      
      
      // OPTIM : si on a sa valeur dans un registre
      SI :tabVarVersReg[varI.nom]..Existe ALORS
      	// on renvoie le rgistre a utiliser
      	renvoyer (tabVarVersReg[varI.nom], Vrai )
      FIN
      SI pas bPourPrologue _et_ :tabOptimVarVersReg[varI.nom]..Existe ALORS
      	// on renvoie le registre a utiliser
      	RENVOYER (tabOptimVarVersReg[varI.nom], Vrai )
      FIN
      
      
      bScrParamètre	est un booléen	= varI.portée = paramètre
      SI bScrParamètre ALORS
      	// les paramètre d'entrée sont mis dans [rsp+08h] dans le prologue
      	// ensuite RSP est décalé (en négatif) de  (_nGetTailleAllocaVarLoc + push rbp )
      	// NB : fonctionne aussi pour les paramètres apres le 4eme, mis par l'appelant dans la pile.
      	nOffset est un entier =  8 // prologue
      	nOffset              +=  nTaille_REG + _nGetTailleAllocaVarLoc() // push rbp
      	nOffset              += (varI.indice)*nTaille_REG 
      	varI_location = "[rsp+" + nOffset + "]"
      	
      	
      SINON 
      	// variable locale : stoquée a partir de rbp
      	// ex : lea r8, [rbp+8]
      	//@TODO : additionner les offsets
      	nOffset est un entier = (varI.indice)*nTaille_INT256
      	SI nOffset= 0 ALORS
      		varI_location = "[rbp]"
      	SINON
      		varI_location = "[rbp+" + nOffset +"]"
      	FIN
      FIN
      
      
      renvoyer (varI_location, bScrRegistre )
     type : 458752
   -
     name : _genCodeAsmInitParam
     procedure_id : 2180638502028265783
     type_code : 12
     code : |1+
      // génère le code ASM pour initialisation d'un paramètre avant appel de procédure
      // ex : "mov rcx,[rsp-20]"
      // <numParam> : commence à 0
      procédure privée _genCodeAsmInitParam( numParam entier, nom chaine) : chaine
      
      // récup var
      varI est STVariable //dynamique <- :tabVariables[nom]
      bOk est un booléen
      (bOk,varI) = _bChercheVariableParNom( nom )
      dbgAssertion(bOk, nom )
      // SOURCE : ou récupérer la valeur de varI
      varI_location est chaine  // morceau de code pour la source. ex [rsp+8]
      bScrRegistre  est un booléen = faux
      bScrParamètre est un booléen = varI.portée = paramètre
      (varI_location, bScrRegistre ) =  _GetLocalisationVariable(varI)
      //
      //si bScrParamètre ALORS
      //	// les paramètre d'entrée sont mis dans [rsp+08h] dans le prologue
      //	// ensuite RSP est décalé (en négatif) de  (_nGetTailleAllocaVarLoc + push rbp )
      //	// NB : fonctionne aussi pour les paramètres apres le 4eme, mis par l'appelant dans la pile.
      //	nOffset est un entier =  8 // prologue
      //	nOffset              +=  nTaille_REG + _nGetTailleAllocaVarLoc() // push rbp
      //	nOffset              += (varI.indice)*nTaille_REG 
      //	varI_location = "[rsp+" + nOffset + "]"
      //
      //
      //sinon 
      //	// variable locale : stoquée a partir de rbp
      //	// ex : lea r8, [rbp+8]
      //	//@TODO : additionner les offsets
      //	nOffset est un entier = (varI.indice)*nTaille_INT256
      //	si nOffset= 0 alors
      //		varI_location = "[rbp]"
      //	sinon
      //		varI_location = "[rbp+" + nOffset +"]"
      //	fin
      //FIN
      //// OPTIM : si on a sa valeur dans un registre
      //SI :tabVarVersReg[nom]..Existe ALORS
      //	varI_location	= tabVarVersReg[nom]
      //	bScrRegistre	= Vrai
      //FIN
      
      
      sCodeASM est chaine
      
      // DEST.
      // ex: "lea rcx," 
      // recup du nom du registre a effecter
      sNomRegDest est chaine = _sGetNomRegPourParamNum64(numParam + 1)
      // si la source est un registre
      si bScrRegistre ALORS
      	// OPTIM si c'est un registre déjà initialisé
      	// pour ne pas générer "mox rcx,rcx"
      	si sNomRegDest = varI_location ALORS
      		renvoyer ""
      	fin
      	
      	// ex : "mov rcx, r9"
      	sCodeASM ="mov " + sNomRegDest +"," + varI_location  
      // si la source est une indirection	
      sinon
      	si bScrParamètre ALORS
      		// ex : mov r8,[rsp+88] ; R
      		sCodeASM ="mov " + sNomRegDest +"," + varI_location  
      	sinon
      		// ex : "lea rcx, [rbp+8]"
      		sCodeASM ="lea " + sNomRegDest +"," + varI_location  
      	fin
      FIN
      SI :bAvecCommentaire
      	sCodeASM += " ; " + nom
      FIN
      // si la source est dans un structure, on rajoute le décalage
      si varI.offsetStruct ALORS
      	// ex: "add rcx,32"
      	sCodeASM += RC 
      	sCodeASM += "add " + sNomRegDest + "," + varI.offsetStruct
      
      FIN
      
      
      // MAJ utilisation des registres
      _VarUtiliseRegistre( varI.nom , sNomRegDest)
      
      
      
      renvoyer sCodeASM
     type : 458752
   -
     name : _sGetNomRegPourParamNum64
     procedure_id : 2181478614805738911
     type_code : 12
     code : |1+
      // renvoie le nom du registre utilisé pour mettre un paramètre 
      // convention d'appel des procédure 64 bits  Microsoft : RCX, RDX, R8, R9 
      // <nNumParam>: de 1 a 5
      procédure privée _sGetNomRegPourParamNum64( nNumParam )
      
      selon nNumParam
      	cas 0: dbgAssertion(faux)
      	cas 1: renvoyer "rcx"
      	cas 2: renvoyer "rdx"
      	cas 3: renvoyer "r8"
      	cas 4: renvoyer "r9"
      	AUTRE CAS
      		dbgAssertion(Faux)
      FIN
      renvoyer "***ERR***" // ne compilera pas.
      
     type : 458752
   -
     name : _genCodeAsm_Prologue
     procedure_id : 2180642874305073169
     type_code : 12
     code : |1+
      procédure privée _genCodeAsm_Prologue() : chaine
      
      sCodeASM_Prologue est chaine = [
      ; Prologue
      	mov    [rsp+08h],rcx  ; P1 mis dans l'emplacement réservé par l'appelant
      	mov    [rsp+10h],rdx  ; idem P2 
      	mov    [rsp+18h],r8   ; idem P3 
      	mov    [rsp+20h],r9   ; idem P4 
      	push   rbp
      	sub    rsp, TAILLE_VAR_LOC  ; réserve pour les variables locale + appel des procédures
      	lea    rbp,[rsp+20h]        ; rbp pointe sur le debut des variables locales
      ]
      // calcul taille pile
      nTailleVarLoc est un entier = _nGetTailleAllocaVarLoc()
      sCodeASM est chaine = remplace(sCodeASM_Prologue,"TAILLE_VAR_LOC", ""+nTailleVarLoc )
      
      // Optim des variables a conserver en registre
      pour TOUT sRegOptim,sNomVar DE :tabOptimVarVersReg
      	soit(b, stVar) = _bChercheVariableParNom(sNomVar)
      	si b alors
      		soit (sLocalisation,bSourceVariable) = _GetLocalisationVariable(stVar, vrai )
      		si  stVar.portée = paramètre
      			sCodeASM += RC + "mov " + sRegOptim + "," + sLocalisation 
      		else
      			sCodeASM += rc + "lea " + sRegOptim + "," + sLocalisation 
      		fin
      	fin
      FIN
      	
      
      
      
      RENVOYER sCodeASM 
     type : 458752
   -
     name : _genCodeAsm_Epilogue
     procedure_id : 2180643608744586234
     type_code : 12
     code : |1+
      procédure privée _genCodeAsm_Epilogue() : chaine
      
      sCodeASM_Epilogue est chaine = [
      ; Epilogue
      	add    rsp, TAILLE_VAR_LOC
      	pop    rbp
      	ret  
      ]
      // calcul taille pile
      nTailleVarLoc	est un entier	= _nGetTailleAllocaVarLoc()
      sCodeASM		est chaine		= remplace(sCodeASM_Epilogue,"TAILLE_VAR_LOC", ""+nTailleVarLoc )
      
      RENVOYER sCodeASM 
     type : 458752
   -
     name : _nGetTailleAllocaVarLoc
     procedure_id : 2181471802987135410
     type_code : 12
     code : |1+
      // renvoie la taille a allouer pour les variable locale dans la pile
      procédure _nGetTailleAllocaVarLoc()
      
      si EnMode64bits() ALORS
      	// +32 : convention d'appel de procédure, on doit leur laisse 4 emplacement de 64 bits (toujours).
      	nTaille est un entier  = 32
      	// ajout de la taille de variables locales
      	POUR TOUT var DE :tabVariables
      		si var.portée = variableLocale ALORS
      			selon var.type
      				CAS UI256
      					nTaille +=nTaille_INT256
      				autre cas
      					dbgAssertion(faux)
      			FIN
      		FIN
      	FIN
      	renvoyer nTaille
      fin
      dbgAssertion(faux,"TODO")
      renvoyer 0
     type : 458752
   -
     name : _VarUtiliseRegistre
     procedure_id : 2181503035991799654
     type_code : 12
     code : |1+
      // indique sur quelle adresse les registres pointent apres chaque ligne de code générée
      procédure privée _VarUtiliseRegistre( sVariable chaine, sRegistre chaine )
      
      // si le registre était utilisé
      _VarDissocieRegiste( sRegistre )
      
      // note l'utilisation 
      :tabRegVersVar[	sRegistre ] = sVariable
      :tabVarVersReg[ sVariable ] = sRegistre
     type : 458752
   -
     name : _VarDissocieRegiste
     procedure_id : 2181515822110581931
     type_code : 12
     code : |1+
      // indique qu'un registe a été changé et ne contient plus de variable 
      // supprime l'association si il y en avait une
      procédure privée _VarDissocieRegiste( sRegistre )
      
      // si le registre était utilisé
      SI :tabRegVersVar[ sRegistre ]..Existe ALORS
      	// on supprime l'ancienne entrée
      	sAncienneVariable est chaine = tabRegVersVar[sRegistre]
      	dbgAssertion(sAncienneVariable<>"")
      	TableauSupprime( :tabRegVersVar,	sRegistre	      )   
      	TableauSupprime( :tabVarVersReg,	sAncienneVariable )   
      FIN
     type : 458752
   -
     name : _VarDissocieApresCall
     procedure_id : 2181516346096648367
     type_code : 12
     code : |1-
      // apres un CALL certains registre peuvent être modifié.
      // => on les note comme ne pointant plus sur une var connue
      procédure privée _VarDissocieApresCall()
      
      // https://en.wikipedia.org/wiki/X86_calling_conventions#Register_preservation: 
      // The registers RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile (caller-saved).[20]
      _VarDissocieRegiste("rax")
      _VarDissocieRegiste("rcx")
      _VarDissocieRegiste("rdx")
      _VarDissocieRegiste("r8")
      _VarDissocieRegiste("r9")
      _VarDissocieRegiste("r10")
      _VarDissocieRegiste("r11")
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BQAAAAUAAAA6ih3UbgNXHwTtiPSFUEj+2fi/m7v4QV2rqidAupM=
  original_name : Classe1
resources :
 string_res :
  identifier : 0x1e42616000e36e0b
  internal_properties : BQAAAAUAAAAnMYFQ1bL/vz9ehh7L22SNNSlIzGTOI8h5F/WtgDNP
custom_note :
 internal_properties : BQAAAAUAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
