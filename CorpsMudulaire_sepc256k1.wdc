#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : CorpsMudulaire_sepc256k1
 major_version : 25
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x1bba2a9f05bd54c0
 internal_properties : BQAAAAUAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  type_code : 10
  p_codes :
   -
     code : |1+
      // coprs avec comme modulo le nombre de mersenne utilisé la courbre elliptique sepc256k1 
      CorpsMudulaire_sepc256k1 est une Classe
      	hérite de CorpsModulaire
      	
      	// constante pour accélére les calcul
      	//  2^256 mod P  = 2^256-P
      	_2P256_MoinsP est Entier256
      
      	pAddrMultModulo est un entier système 
      FIN
      
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 1997956247176762560
     type_code : 27
     code : |1+
      PROCEDURE Constructeur()
      	Constructeur CorpsModulaire("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")
      	
      _2P256_MoinsP.val0 = 0x1000003d1
      
      //@TEMP : DLL pour tester de la multiplication modulaire
      si EnModeTest() _et_ EnMode64bits() alors
      	sDLL est chaine = "C:\Users\Paul Albert\Source\myRepo\LibInt256\x64\ReleaseDLL\LibInt256.dll"
      	dbgAssertion(fFichierExiste(sDLL))
      	ChargeDLL(sDLL)
      	SI ErreurDétectée ALORS
      		Erreur()
      	FIN
      	hModule est un entier système = API("kernel32","GetModuleHandleA","LibInt256.dll")
      	pAddrMultModulo = API("kernel32","GetProcAddress",hModule,"multiplicationMudulo_sepc256k1")
      fin
     type : 589824
   -
     name : Destructeur
     procedure_id : 1997956247176828096
     type_code : 28
     code : |1+
      PROCEDURE Destructeur()
      
     type : 655360
   -
     name : multiplicationModulo
     procedure_id : 2146026305968039239
     type_code : 12
     code : |1-
      // version plus rapide de ma multiplication modulaire si le modulo est 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
      PROCÉDURE virtuelle multiplicationModulo(  nombreA Entier256, nombreB Entier256) : Entier256 
      
      // algo :
      // on découpe en 4 multiplication 256*64 bits, puis on additionne chaque sous partie
      // + les débordement (=partie du résultat au delà de 256 bits sont est remis sous 256 bits par modulo P et soustrait
      ///
      //  AB =  A * B[0]  + A*2^64*B[1] + A*2^128*B[2] + A*2^196*B[3]
      //=>
      //  R0 = A*B[3]
      //  R1 = A*B[2] + R0*2^64
      //  R2 = A*B[1] + R1*2^64
      //  R  = A*B[0] + R2*2^64
      
      //renvoyer multiplicationModulo_OLD( nombreA,nombreB)
      
      // résultat R
      resultat est Entier256
      // var de travail temp
      retenue  est un entier sur 8 sans signe
      depasseModP  est un Entier256
      partieDeB_64 est entier sans signe sur 8 octets
      
      //-- Etape 1
      // R0 = A*B[3]
      retenue  =	API(arithmetique.addrprocMult256x64_256_ASM, &nombreA, &nombreB.val3, &resultat )
      // R = R mop P
      // application du modulo en soustrayant le nombre de fois ou l'on a dépassé
      //depasseModP = multiplication64x64_128( retenue, _2P256_MoinsP.val0 ) // retenue * _2P256_MoinsP.val0 
      API(arithmetique.addrprocMult64x64_128_ASM, &retenue, &_2P256_MoinsP.val0, &depasseModP)
      retenue = API(arithmetique.addrprocAddition256p256_256c, &resultat, &depasseModP )
      SI retenue ALORS
      	API(arithmetique.addrprocAddition256p256_256c, &resultat, &_2P256_MoinsP )
      FIN
      
      _AB_I est Entier256
      
      pour i = 1 a 3
      //	 partieDeB_64 = nombreB._64Bits(3-i)
      	selon i
      //		cas 0 : partieDeB_64 = nombreB.val3
      		cas 1 :	 partieDeB_64 = nombreB.val2
      		cas 2 :	 partieDeB_64 = nombreB.val1
      		cas 3 :  partieDeB_64 = nombreB.val0
      	FIN
      
      	//-1- calcul de : R*2^64 mod P
      
      	// on garde ce qui va dépasser apres la multiplication par 2^64
      	//depasseModP = multiplication64x64_128( resultat.val3, _2P256_MoinsP.val0 ) 
      	API(arithmetique.addrprocMult64x64_128_ASM, &resultat.val3, &_2P256_MoinsP.val0, &depasseModP)
      	// R*2^64 
      	resultat.val3 = resultat.val2
      	resultat.val2 = resultat.val1
      	resultat.val1 = resultat.val0
      	resultat.val0 = 0
      	//resultat.mulitplieParUnePuissanceDe2(64)
      	
      	// mod P : ajoute ce qui dépasse modulo P
      	retenue = API(arithmetique.addrprocAddition256p256_256c, &resultat, &depasseModP )
      	si retenue ALORS
      		API(arithmetique.addrprocAddition256p256_256c, &resultat, &_2P256_MoinsP )
      	FIN
      	
       	//-2- calcul de A*B[I]
      	// (retenue, _AB) = nombreA * partieDeB_64 
      	_AB_I.affecteAvecEntierPositif(0)
      	retenue  =	API(arithmetique.addrprocMult256x64_256_ASM, &nombreA, &partieDeB_64, &_AB_I )
      	// R += A*B[I]
      	retenue += API(arithmetique.addrprocAddition256p256_256c, &resultat, &_AB_I ) 
      	// R = R mop P
      	// application du modulo en soustrayant le nombre de fois ou l'on a dépassé
      	//depasseModP = multiplication64x64_128( retenue, _2P256_MoinsP.val0 ) // retenue * _2P256_MoinsP.val0 
      	API(arithmetique.addrprocMult64x64_128_ASM, &retenue, &_2P256_MoinsP.val0, &depasseModP)
      	retenue = API(arithmetique.addrprocAddition256p256_256c, &resultat, &depasseModP )
      	SI retenue ALORS
      		API(arithmetique.addrprocAddition256p256_256c, &resultat, &_2P256_MoinsP )
      	FIN
      
      FIN
      
      
      SI resultat.estSupérieurOuEgalA( :P ) ALORS
      	// OPTIM de : resultat256 = soustraction( resultat256, :P )
      	resultat = addition( resultat, _2P256_MoinsP )
      FIN
      
      // en debug on vérifie qu'on obtient le meme résultat avec un autre algo
      si EnModeTest() _et_ pAddrMultModulo<>0 ALORS
      	// soit valDbg = multiplicationModulo_OLD(nombreA,nombreB)
      	valDbg est Entier256
      	API(pAddrMultModulo,&nombreA,&nombreB,&valDbg)
      	si pas valDbg.estEgalA(resultat) alors
      		dbgAssertion(faux, nombreA.VersChaineHexa() + Rc + nombreB.VersChaineHexa()+rc+"---"+rc+valDbg.VersChaineHexa()+rc+resultat.VersChaineHexa() )
      	fin
      	
      FIN
      
      renvoyer resultat
     type : 458752
   -
     name : multiplicationModulo_OLD
     procedure_id : 1997957801955089261
     type_code : 12
     group : 1
     code : |1+
      // renvoie A * B ( mod P )
      //@Version optimisée pour P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
      procédure multiplicationModulo_OLD(  nombreA entier256, nombreB entier256) : Entier256
      
      // cas particulier de la multiplication par 1 (fractions)
      si nombreA.EstEgalA1() ALORS
      	renvoyer nombreB
      FIN 
      SI nombreB.estEgalA1() ALORS
      	RENVOYER nombreA
      FIN 
      
      //si P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
       // OPTIM  avec = 0x1000003d1 
       
      // calcul de A*B sur 512
      AB512 est Entier512 = multiplication256x256_512( nombreA, nombreB)
      
      // calcul de reste modulaire poids fort de AB
      AB512_PFort est Entier512 = multiplication256x256_512(AB512.valPoidsFort, _2P256_MoinsP)
      
      restePF est un entier256 =  multiplication256x64_256(AB512_PFort.valPoidsFort, _2P256_MoinsP.val0  )
      bretenue est un booléen
      restePF = addition( restePF,AB512_PFort.valPoidsFaible,bretenue)
      si bretenue ALORS
      	restePF = addition( restePF, _2P256_MoinsP )
      FIN
      	
      resultat256 est un entier256 = addition(AB512.valPoidsFaible, restePF,bretenue)
      SI bretenue ALORS
      	resultat256 = addition( resultat256, _2P256_MoinsP )
      FIN	
      
      si resultat256.estSupérieurouEgalA( :p ) ALORS
      	// OPTIM de : resultat256 = soustraction( resultat256, :P )
      	resultat256 = addition( resultat256, _2P256_MoinsP )
      FIN
      
      	
      renvoyer resultat256
      
     type : 458752
   -
     name : multiplicationParUI32Modulo
     procedure_id : 2166339207307541054
     type_code : 12
     code : |1+
      procédure multiplicationParUI32Modulo( nombre Entier256, UI32 est entier sans signe ) : Entier256
      
      // var de travail temp
      retenue  est un entier sur 8 sans signe
      depasseModP  est un Entier256
      
      resultat est entier256
      retenue  =	API(arithmetique.addrprocMult256x64_256_ASM, &nombre, &UI32, &resultat )
      
      // R = R mop P
      // application du modulo en soustrayant le nombre de fois ou l'on a dépassé
      API(arithmetique.addrprocMult64x64_128_ASM, &retenue, &_2P256_MoinsP.val0, &depasseModP)
      retenue = API(arithmetique.addrprocAddition256p256_256c, &resultat, &depasseModP )
      SI retenue ALORS
      	API(arithmetique.addrprocAddition256p256_256c, &resultat, &_2P256_MoinsP )
      FIN
      // si on dépasse le modulo :
      SI resultat.estSupérieurOuEgalA( :P ) ALORS
      	// OPTIM de : resultat256 = soustraction( resultat256, :P )
      	resultat = addition( resultat, _2P256_MoinsP )
      FIN
      
      renvoyer resultat
     type : 458752
   -
     name : multiplicationPar4Modulo
     procedure_id : 2166340259575690984
     type_code : 12
     code : |1-
      PROCÉDURE multiplicationPar4Modulo( nombre Entier256 ) : entier256  
      //@A optimiser
      RENVOYER multiplicationParUI32Modulo( nombre, 4 )
     type : 458752
   -
     name : multiplicationPar8Modulo
     procedure_id : 2166339383401437923
     type_code : 12
     code : |1-
      PROCÉDURE multiplicationPar8Modulo( nombre Entier256 ) : Entier256  
      
      //@A optimiser
      RENVOYER multiplicationParUI32Modulo( nombre, 8 )
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BQAAAAUAAAA6ih3UbgNXHwTtiPSFUEj+2fi/m7v4QV2rqidAupM=
  original_name : Classe1
resources :
 string_res :
  identifier : 0x1bba2a8405baebf4
  internal_properties : BQAAAAUAAAAnMYFQ1bL/vz9ehh7L22SNNSlIzGTOI8h5F/WtgDNP
custom_note :
 internal_properties : BQAAAAUAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
