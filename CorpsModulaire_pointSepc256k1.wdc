#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : CorpsModulaire_pointSepc256k1
 major_version : 25
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x1e37073f0090859a
 internal_properties : BQAAAAUAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  type_code : 10
  p_codes :
   -
     code : |1+
      // coprs avec comme modulo le nombre de mersenne utilisé la courbre elliptique sepc256k1 
      CorpsModulaire_pointSepc256k1 est une Classe
      	hérite de CorpsModulaire
      	
      	// constante pour accélére les calcul
      	//  2^256 mod P  = 2^256-P
      	_2P256_MoinsP est Entier256
      	// (P+1)/4 : pour racine carrée
      	_Pplus1Sur4 est Entier256 // ="0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c"
      
      	pAddrMultModulo est un entier système 
      FIN
      
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 2177216912030795162
     type_code : 27
     code : |1+
      PROCEDURE Constructeur()
      	Constructeur CorpsModulaire("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")
      	Constructeur _Pplus1Sur4("0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c")
      	
      _2P256_MoinsP.val0 = 0x1000003d1
      
      //@TEMP : DLL pour tester de la multiplication modulaire
      si EnModeTest() _et_ EnMode64bits() alors
      	sDLL est chaine = "C:\Users\Paul Albert\Source\myRepo\LibInt256\x64\ReleaseDLL\LibInt256.dll"
      	dbgAssertion(fFichierExiste(sDLL))
      	ChargeDLL(sDLL)
      	SI ErreurDétectée ALORS
      		Erreur()
      	FIN
      	hModule est un entier système = API("kernel32","GetModuleHandleA","LibInt256.dll")
      	pAddrMultModulo = API("kernel32","GetProcAddress",hModule,"multiplicationMudulo_sepc256k1")
      fin
     type : 589824
   -
     name : Destructeur
     procedure_id : 2177216912030860698
     type_code : 28
     code : |1+
      PROCEDURE Destructeur()
     type : 655360
   -
     name : multiplication_255x255x8_Modulo
     procedure_id : 2177216912030926234
     type_code : 12
     code : |1+
      // renvoie A*B*C modulo P
      // <c> doit être entre 1 et 8
      procédure multiplication_255x255x8_Modulo( nombreA Entier256, nombreB Entier256, nombreC entier sur 8)  : Entier256 
      
      // résultat R
      resultat est Entier256
      //NB on doit avoir un routine asm dispo (64 bits)
      //arithmetique.addrprocMult256x256Modulo<>0 ALORS
      API(arithmetique.addrprocMult256x256Modulo, &nombreA, &nombreB, &resultat )
      API(arithmetique.addrprocMult256x64Modulo, &resultat,  nombreC, &resultat )
      RENVOYER resultat
     type : 458752
   -
     name : carré_255x255x8_Modulo
     procedure_id : 2177216912030991770
     type_code : 12
     code : |1-
      // renvoie A*A*C modulo P
      // <c> doit être entre 1 et 8
      procédure carré_255x255x8_Modulo( nombreA Entier256, nombreC entier sur 8)  : Entier256 
      
      resultat est Entier256
      API(arithmetique.addrprocMult256x256Modulo, &nombreA, &nombreA, &resultat )
      API(arithmetique.addrprocMult256x64Modulo, &resultat,  nombreC, &resultat )
      RENVOYER resultat
     type : 458752
   -
     name : multiplicationModulo
     procedure_id : 2177216912031057306
     type_code : 12
     code : |1-
      // version plus rapide de ma multiplication modulaire si le modulo est 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
      PROCÉDURE virtuelle multiplicationModulo(  nombreA Entier256, nombreB Entier256) : Entier256 
      
      // résultat R
      resultat est Entier256
      //si on un routine asm dispo (64 bits)
      si arithmetique.addrprocMult256x256Modulo<>0 ALORS
      	API(arithmetique.addrprocMult256x256Modulo, &nombreA, &nombreB, &resultat )
      	renvoyer resultat
      FIN
      
      // algo :
      // on découpe en 4 multiplication 256*64 bits, puis on additionne chaque sous partie
      // + les débordement (=partie du résultat au delà de 256 bits sont est remis sous 256 bits par modulo P et soustrait
      ///
      //  AB =  A * B[0]  + A*2^64*B[1] + A*2^128*B[2] + A*2^196*B[3]
      //=>
      //  R0 = A*B[3]
      //  R1 = A*B[2] + R0*2^64
      //  R2 = A*B[1] + R1*2^64
      //  R  = A*B[0] + R2*2^64
      
      // var de travail temp
      retenue  est un entier sur 8 sans signe
      depasseModP  est un Entier256
      partieDeB_64 est entier sans signe sur 8 octets
      
      //-- Etape 1
      // R0 = A*B[3]
      retenue  =	API(arithmetique.addrprocMult256x64_256_ASM, &nombreA, &nombreB.val3, &resultat )
      // R = R mop P
      // application du modulo en soustrayant le nombre de fois ou l'on a dépassé
      //depasseModP = multiplication64x64_128( retenue, _2P256_MoinsP.val0 ) // retenue * _2P256_MoinsP.val0 
      API(arithmetique.addrprocMult64x64_128_ASM, &retenue, &_2P256_MoinsP.val0, &depasseModP)
      retenue = API(arithmetique.addrprocAddition256p256_256c, &resultat, &depasseModP )
      SI retenue ALORS
      	API(arithmetique.addrprocAddition256p256_256c, &resultat, &_2P256_MoinsP )
      FIN
      
      _AB_I est Entier256
      
      pour i = 1 a 3
      //	 partieDeB_64 = nombreB._64Bits(3-i)
      	selon i
      //		cas 0 : partieDeB_64 = nombreB.val3
      		cas 1 :	 partieDeB_64 = nombreB.val2
      		cas 2 :	 partieDeB_64 = nombreB.val1
      		cas 3 :  partieDeB_64 = nombreB.val0
      	FIN
      
      	//-1- calcul de : R*2^64 mod P
      
      	// on garde ce qui va dépasser apres la multiplication par 2^64
      	//depasseModP = multiplication64x64_128( resultat.val3, _2P256_MoinsP.val0 ) 
      	API(arithmetique.addrprocMult64x64_128_ASM, &resultat.val3, &_2P256_MoinsP.val0, &depasseModP)
      	// R*2^64 
      	resultat.val3 = resultat.val2
      	resultat.val2 = resultat.val1
      	resultat.val1 = resultat.val0
      	resultat.val0 = 0
      	//resultat.mulitplieParUnePuissanceDe2(64)
      	
      	// mod P : ajoute ce qui dépasse modulo P
      	retenue = API(arithmetique.addrprocAddition256p256_256c, &resultat, &depasseModP )
      	si retenue ALORS
      		API(arithmetique.addrprocAddition256p256_256c, &resultat, &_2P256_MoinsP )
      	FIN
      	
       	//-2- calcul de A*B[I]
      	// (retenue, _AB) = nombreA * partieDeB_64 
      	_AB_I.affecteAvecEntierPositif(0)
      	retenue  =	API(arithmetique.addrprocMult256x64_256_ASM, &nombreA, &partieDeB_64, &_AB_I )
      	// R += A*B[I]
      	retenue += API(arithmetique.addrprocAddition256p256_256c, &resultat, &_AB_I ) 
      	// R = R mop P
      	// application du modulo en soustrayant le nombre de fois ou l'on a dépassé
      	//depasseModP = multiplication64x64_128( retenue, _2P256_MoinsP.val0 ) // retenue * _2P256_MoinsP.val0 
      	API(arithmetique.addrprocMult64x64_128_ASM, &retenue, &_2P256_MoinsP.val0, &depasseModP)
      	retenue = API(arithmetique.addrprocAddition256p256_256c, &resultat, &depasseModP )
      	SI retenue ALORS
      		API(arithmetique.addrprocAddition256p256_256c, &resultat, &_2P256_MoinsP )
      	FIN
      
      FIN
      
      
      SI resultat.estSupérieurOuEgalA( :P ) ALORS
      	// OPTIM de : resultat256 = soustraction( resultat256, :P )
      	resultat = addition( resultat, _2P256_MoinsP )
      FIN
      
      // en debug on vérifie qu'on obtient le meme résultat avec un autre algo
      si EnModeTest() _et_ pAddrMultModulo<>0 ALORS
      	// soit valDbg = multiplicationModulo_OLD(nombreA,nombreB)
      	valDbg est Entier256
      	API(pAddrMultModulo,&nombreA,&nombreB,&valDbg)
      	si pas valDbg.estEgalA(resultat) alors
      		dbgAssertion(faux, nombreA.VersChaineHexa() + Rc + nombreB.VersChaineHexa()+rc+"---"+rc+valDbg.VersChaineHexa()+rc+resultat.VersChaineHexa() )
      	fin
      	
      FIN
      
      renvoyer resultat
     type : 458752
   -
     name : multiplicationParUI32Modulo
     procedure_id : 2177216912031122842
     type_code : 12
     code : |1+
      procédure multiplicationParUI32Modulo( nombre Entier256, UI32 est entier sans signe ) : Entier256
      
      resultat est entier256
      // var de travail temp
      retenue  est un entier sur 8 sans signe
      depasseModP  est un Entier256
      
      
      retenue  =	API(arithmetique.addrprocMult256x64_256_ASM, &nombre, &UI32, &resultat )
      
      // R = R mop P
      // application du modulo en soustrayant le nombre de fois ou l'on a dépassé
      API(arithmetique.addrprocMult64x64_128_ASM, &retenue, &_2P256_MoinsP.val0, &depasseModP)
      retenue = API(arithmetique.addrprocAddition256p256_256c, &resultat, &depasseModP )
      SI retenue ALORS
      	API(arithmetique.addrprocAddition256p256_256c, &resultat, &_2P256_MoinsP )
      FIN
      // si on dépasse le modulo :
      SI resultat.estSupérieurOuEgalA( :P ) ALORS
      	// OPTIM de : resultat256 = soustraction( resultat256, :P )
      	resultat = addition( resultat, _2P256_MoinsP )
      FIN
      
      renvoyer resultat
     type : 458752
   -
     name : multiplicationPar2Modulo
     procedure_id : 2177216912031188378
     type_code : 12
     code : |1+
      PROCÉDURE multiplicationPar2Modulo(  nombre Entier256) : Entier256
      
      // si une procédure ASM existe (64 bits)
      SI arithmetique.addrprocMult256x64Modulo<> Null ALORS
      	resultat	est entier256
      	API( arithmetique.addrprocMult256x64Modulo, &nombre, 2, &resultat  )
      	RENVOYER resultat
      FIN
      
      //@A optimiser
      RENVOYER multiplicationParUI32Modulo( nombre, 3 )
     type : 458752
   -
     name : MultiplicationPar3Modulo
     procedure_id : 2177216912031253914
     type_code : 12
     code : |1-
      Procédure MultiplicationPar3Modulo( nombre Entier256 ) : entier256
      
      // si une procédure ASM existe (64 bits)
      SI arithmetique.addrprocMult256x64Modulo<> Null ALORS
      	resultat est entier256
      	API( arithmetique.addrprocMult256x64Modulo, &nombre, 3, &resultat  )
      	renvoyer resultat
      FIN
      
      //@A optimiser
      RENVOYER multiplicationParUI32Modulo( nombre, 3 )
     type : 458752
   -
     name : multiplicationPar4Modulo
     procedure_id : 2177216912031319450
     type_code : 12
     code : |1-
      PROCÉDURE multiplicationPar4Modulo( nombre Entier256 ) : entier256  
      
      // si une procédure ASM existe (64 bits)
      SI arithmetique.addrprocMult256x64Modulo<> Null ALORS
      	resultat	est entier256
      	API( arithmetique.addrprocMult256x64Modulo, &nombre, 4, &resultat  )
      	RENVOYER resultat
      FIN
      
      //@A optimiser
      RENVOYER multiplicationParUI32Modulo( nombre, 4 )
     type : 458752
   -
     name : multiplicationPar8Modulo
     procedure_id : 2177216912031384986
     type_code : 12
     code : |1+
      PROCÉDURE multiplicationPar8Modulo( nombre Entier256 ) : Entier256  
      
      // si une procédure ASM existe (64 bits)
      SI arithmetique.addrprocMult256x64Modulo<> Null ALORS
      	resultat	est entier256
      	API( arithmetique.addrprocMult256x64Modulo, &nombre, 8, &resultat  )
      	RENVOYER resultat
      FIN
      
      //@A optimiser
      RENVOYER multiplicationParUI32Modulo( nombre, 8 )
      
     type : 458752
   -
     name : soustractionModulo
     procedure_id : 2177216912031450522
     type_code : 12
     code : |1+
      // renvoie A - B ( mod P )
      PROCÉDURE soustractionModulo( nombreA Entier256, nombreB Entier256) : Entier256
      
      // si une procédure ASM existe (64 bits)
      SI arithmetique.addrprocSoustractionModulo<> Null ALORS
      	resultat	est entier256
      	API( arithmetique.addrprocSoustractionModulo, &nombreA, &nombreB, &resultat  )
      	RENVOYER resultat
      FIN
      
      
      
      SI nombreA.estSupérieurOuEgalA( nombreB ) ALORS
      	RENVOYER soustraction(nombreA,nombreB)
      SINON
      	moinsR est Entier256 = soustraction ( nombreB, nombreA  )
      	RENVOYER négationModulo( moinsR )
      FIN
      
     type : 458752
   -
     name : racineCarréeModulo
     procedure_id : 2177216912031516058
     type_code : 12
     code : |1-
      // renvoie une racine carré modulaire de <nombre>. si <nombre> est bien un carré.
      // (il en existe 2, on en renvoie une des 2)
      procédure racineCarréeModulo( nombre est Entier256 ) : Entier256
      
      // comme P = 3 (mod 4) : 
      // racine(x)  = x^((P+1)/4)
      racineCarrée est un Entier256 = puissanceModulo(nombre, :_Pplus1Sur4)
      
      renvoyer racineCarrée
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BQAAAAUAAAA6ih3UbgNXHwTtiPSFUEj+2fi/m7v4QV2rqidAupM=
  original_name : Classe1
resources :
 string_res :
  identifier : 0x1bba2a8405baebf4
  internal_properties : BQAAAAUAAAAnMYFQ1bL/vz9ehh7L22SNNSlIzGTOI8h5F/WtgDNP
custom_note :
 internal_properties : BQAAAAUAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
