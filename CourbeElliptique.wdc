#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : CourbeElliptique
 major_version : 25
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x1b42f463002eeed4
 internal_properties : BQAAAAUAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  type_code : 10
  p_codes :
   -
     code : |1+
      CourbeElliptique est une Classe
      	// coefficient de y2 = (x3 + ax + b) [mod p]
      	//coefA est Entier256 // OTIM, non géré car non nécessaire pour secp256k1
      	coefB est Entier256
      	
      	// corps des entiers modulo p, pour calculs sur les x,y des points
      	corps est CorpsModulaire dynamique
      	// ordre de la courbe : plus petit entier <n> tel que nG = 0
      	Ordre est entier256;
      	// corps des entiers modulo N, pour calculs entres les multiples de points
      	corpsOrdre est CorpsModulaire dynamique 
      FIN
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 1964401093529038548
     type_code : 27
     code : |1+
      PROCEDURE Constructeur( moduloHexa chaine, ordreHexa chaine ) 
        corps = allouer un corps( moduloHexa )
        
        Ordre.affecteAvecChaineHexa(ordreHexa)
        corpsOrdre = allouer un CorpsModulaire( ordreHexa )
     type : 589824
   -
     name : Constructeur
     procedure_id : 1964401093529038548
     type_code : 27
     code : |1-
      // constructeur avec un crops en paramètre, pour dériver...
      PROCÉDURE Constructeur( corps_, corpsOrdre_ ) 
      corps = corps_
      corpsOrdre = corpsOrdre_
      
      //Ordre.affecteAvecChaineHexa(ordreHexa)
      //corpsOrdre = allouer un CorpsModulaire( ordreHexa )
     type : 589825
   -
     name : Destructeur
     procedure_id : 1964401093529104084
     type_code : 28
     code : |1+
      PROCEDURE Destructeur()
     type : 655360
   -
     name : pointEstSurLaCourbe
     procedure_id : 1964401956817535081
     type_code : 12
     code : |1+
      // Indique si un point est sur la courbre
      // ie : y2 = (x3 + ax + b)[mod n]
      procédure pointEstSurLaCourbe( point est Point256) : booléen
      
      
      // calcul de Y^2
      Y2 est entier256 = corps.carréModulo( point.y )
      
      //	calcul de X^3 + B
      X3 est   un entier256  = corps.cubeModulo( point.x ) 
      X3plusB est entier256  = corps.additionModulo(X3, coefB)
      
      // le point si sur la courbe si égalité
      renvoyer Y2.estEgalA( X3plusB ) 
      
     type : 458752
   -
     name : pointNégation
     procedure_id : 2167743073166274897
     type_code : 12
     code : |1-
      // négation d'un point: ie renvoie -P
      PROCÉDURE pointNégation(point Point256)  : Point256
      
      PointRésultat est Point256  
      PointRésultat.x = point.x 
      PointRésultat.y = corps.négationModulo( point.y )
      renvoyer PointRésultat
     type : 458752
   -
     name : pointDouble
     procedure_id : 1964415631993640300
     type_code : 12
     code : |1+
      // Addition d'un point avec lui meme
      PROCÉDURE pointDouble(point Point256)  : Point256
      
      // formule trouvé sur le net :
      // L = (3x^2) / (2*y)-1  Modulo P
      N est entier256 = corps.multiplicationPar3Modulo( corps.carréModulo(point.x) )
      D est entier256 = corps.multiplicationPar2Modulo( point.y )
      // =>opération longue : inversion modulo ici
      L est entier256 = corps.divisionModulo( N, D )
      
      PointRésultat est Point256 ;
      //X = (L*L - 2*p.x ) 
      PointRésultat.x =  corps.soustractionModulo( corps.carréModulo(L),  corps.additionModulo( point.x, point.x ) ) 
      // Y = - (L * ( X  - p.x ) + p.y )
      RX est entier256 = PointRésultat.x
      RY est entier256 = corps.soustractionModulo( RX, point.X )
      RY  =  corps.multiplicationModulo( L, RY)
      RY =  corps.additionModulo( RY, point.y )
      
      PointRésultat.y = corps.négationModulo( RY )
      
      
      
      renvoyer PointRésultat;
     type : 458752
   -
     name : pointPlusPoint
     procedure_id : 1968097561427963392
     type_code : 12
     code : |1+
      // Addition d'un point avec une autre
      PROCÉDURE pointPlusPoint(pointA Point256, pointB Point256)  : Point256
      
      // cas du 0
      si (pointA.EstZero()) renvoyer pointB;
      SI (pointB.EstZero()) RENVOYER pointA;
      
      // cas d'addition d'un point a lui même
      si pointA.PointEstEgalA( pointB ) alors
      	renvoyer pointDouble(pointA)
      FIN
      
      // formule de calcul des coordonnées du point résultat de l'addition
      // L = (Ya - Yb) / (Xa - Xb)   Modulo P
      N est entier256 =   corps.soustractionModulo(pointA.y, pointB.y ) 
      D est entier256 =   corps.soustractionModulo(pointA.x, pointB.x ) 
      // si A et B sont inverse
      si D.estEgalAZero() ALORS
      	// le résultat est 0.
      	pt0 est Point256;
      	RENVOYER pt0;
      FIN
      // division modulaire : opération la plus lente...
      L est entier256 = corps.divisionModulo( N, D )
      LAuCarré est entier256 = corps.carréModulo( L )
      
      PointRésultat est Point256 ;
      //X = (L*L - Xa - Xb ) 
      PointRésultat.x =  corps.soustractionModulo( LAuCarré,  corps.additionModulo( pointA.x, pointB.x ) ) 
      // Y = -(YA + L * (Xr -  Xa ))
      XR est entier256 = PointRésultat.x
      RY_droite est entier256 =    corps.multiplicationModulo( L,  corps.soustractionModulo( XR, pointA.X )) 
      PointRésultat.y = corps.négationModulo( corps.additionModulo( pointA.y,  RY_droite )   )
      
      
      renvoyer PointRésultat;
      
     type : 458752
   -
     name : pointMoinsPoint
     procedure_id : 2167758444854660272
     type_code : 12
     code : |1-
      // soustraction d'un point avec une autre
      PROCÉDURE pointMoinsPoint(pointA Point256, pointB Point256)  : Point256
      
      moins_pointB est Point256 = pointNégation(pointB)
      renvoyer pointPlusPoint(pointA,moins_pointB)
     type : 458752
   -
     name : pointPlusPoint_InvModulairePrécalculé
     procedure_id : 2145519323470119807
     type_code : 12
     code : |1-
      // Addition d'un point avec une autre, version ou l'on a pré-calculé l'inverse modulaire nécessaire a l'opération
      PROCÉDURE pointPlusPoint_InvModulairePrécalculé(pointA Point256, pointB Point256, InverseDeD entier256)  : Point256
      
      // cas du 0
      SI (pointA.estZéro()) RENVOYER pointB;
      SI (pointB.estZéro()) RENVOYER pointA;
      //
      //// cas d'addition d'un point a lui même
      SI pointA.PointestEgalA( pointB ) ALORS
      	dbgAssertion(faux,"cas a voir")
      	RENVOYER pointDouble(pointA)
      FIN
      
      // formule de calcul des coordonnées du point résultat de l'addition
      // L = (Ya - Yb) / (Xa - Xb)   Modulo P
      N est Entier256 =   corps.soustractionModulo(pointA.y, pointB.y ) 
      //D est Entier256 =   corps.soustractionModulo(pointA.x, pointB.x ) 
      // si A et B sont inverse
      //SI D.estEgalAZero() ALORS
      //	// le résultat est 0.
      //	pt0 est Point256;
      //	RENVOYER pt0;
      //FIN
      // division modulaire : opération la plus lente : OPTIM, remplacée par la multiplication par l'inverse (connu)
      //L est Entier256 = corps.divisionModulo( N, D )
      L est Entier256 = corps.multiplicationModulo( N, InverseDeD )
      LAuCarré est Entier256 = corps.carréModulo( L )
      
      PointRésultat est Point256 ;
      //X = (L*L - Xa - Xb ) 
      PointRésultat.x =  corps.soustractionModulo( LAuCarré,  corps.additionModulo( pointA.x, pointB.x ) ) 
      // Y = -(YA + L * (Xr -  Xa ))
      XR est Entier256 = PointRésultat.x
      RY_droite est Entier256 =    corps.multiplicationModulo( L,  corps.soustractionModulo( XR, pointA.x )) 
      PointRésultat.y = corps.négationModulo( corps.additionModulo( pointA.y,  RY_droite )   )
      
      
      RENVOYER PointRésultat;
     type : 458752
   -
     name : MultiplicationScalaireFraction
     procedure_id : 1968103488487487938
     type_code : 12
     code : |1+
      // revoie K * point de la courbe
      PROCEDURE MultiplicationScalaireFraction( point est PointFraction256, K est Entier256 ) : PointFraction256
      
      
      résultat est PointFraction256 // 0
      point_pow2   est PointFraction256 =  point // valeurs successives de (2^I) * point
      
      POUR i = 0 a 255
      	SI K.bit(i) ALORS
      		// r = r + 2^k
      		résultat = pointPlusPointFraction( résultat, point_pow2 )
      
      	FIN
      	// calcul de K^2*P
      	point_pow2 = pointAuCarré_mon( point_pow2 )	
      FIN
      
      // le point devrait être sur la courbe, sinon erreur de calcul
      dbgAssertion( pointFractionEstSurLaCourbe( résultat ) _ou_ résultat.estZéro(), "pointEstSurLaCourbe FAILED")
      RENVOYER résultat
      
     type : 458752
   -
     name : pointAuCarré_mon
     procedure_id : 1980744096957841057
     type_code : 12
     code : |1+
      // Addition d'un point avec lui meme
      // les coord sont dans mon()
      PROCÉDURE pointAuCarré_mon(point PointFraction256)  : PointFraction256
      
      // formule trouvé sur le net :
      // L = (3x^2) / (2*y)-1  Modulo P
      X2 est Fraction256 = corps.carréFractionModulo_mon(point.x)
      N est Fraction256 = corps.additionFractionModulo_mon( corps.additionFractionModulo_mon( X2, X2 ), X2 )
      D est Fraction256 = corps.additionFractionModulo_mon( point.y, point.y )
      L est Fraction256 = corps.divisionFractionModulo_mon( N, D )
      
      PointRésultat est PointFraction256 ;
      //X = (L*L - 2*p.x ) 
      PointRésultat.x =  corps.soustractionFractionModulo_mon( corps.carréFractionModulo_mon(L),  corps.additionFractionModulo_mon( point.x, point.x ) ) 
      // Y = - (L * ( X  - p.x ) + p.y )
      RX est Fraction256 = PointRésultat.x
      RY est Fraction256 = corps.soustractionFractionModulo_mon( RX, point.X )
      RY  =  corps.multiplicationFractionModulo_mon( L, RY)
      RY =  corps.additionFractionModulo_mon( RY, point.y )
      
      PointRésultat.y = corps.négationFractionModulo_mon( RY )
      
      renvoyer PointRésultat;
     type : 458752
   -
     name : pointPlusPoint_mon
     procedure_id : 1982585959294059657
     type_code : 12
     code : |1+
      // Addition d'un point avec une autre
      // les 2 poins ont leus coordonées en transformée de montgomery
      PROCÉDURE pointPlusPoint_mon(mon_pointA PointFraction256, mon_pointB PointFraction256)  : PointFraction256
      
      // cas d'adition a 0
      si mon_pointA.EstZéro() renvoyer mon_pointB
      si mon_pointB.EstZéro() renvoyer mon_pointA
      
      // cas d'addition d'un point a lui même : Pas possible ici, car on ajoute des puissance de 2 de G.
      //si mon_pointA.PointEstEgalA(mon_pointB, :corps ) alors
      //	dbgAssertion(faux) // tous les points du tableau prédefini son différents
      //	renvoyer pointAuCarré_mon(mon_pointA)
      //FIN
      
      // formule trouvé sur le net ( https://crypto.stanford.edu/pbc/notes/elliptic/explicit.html )
      // L =  (Ya - Yb) / (Xa - Xb)  Modulo P
      mon_N est Fraction256 =   corps.soustractionFractionModulo_mon(mon_pointA.y, mon_pointB.y ) 
      mon_D est Fraction256 =   corps.soustractionFractionModulo_mon(mon_pointA.x, mon_pointB.x ) 
      // division de fractions = 2 multiplications
      mon_L est Fraction256    = corps.divisionFractionModulo_mon( mon_N, mon_D )
      // calcul L^2
      mon_LAuCarré est Fraction256 = corps.multiplicationFractionModulo_mon( mon_L, mon_L )
      
      mon_pointRésultat est PointFraction256 ;
      //X = (L*L - Xa - Xb )  = L2 - (Xb + Xa)
      mon_XAplusXB  est Fraction256 = corps.additionFractionModulo_mon( mon_pointA.x, mon_pointB.x )
      mon_pointRésultat.x =  corps.soustractionFractionModulo_mon( mon_LAuCarré, mon_XAplusXB ) 
      // Y = -(Ya + L * (Xr -  Xa )
      XR est Fraction256 = mon_pointRésultat.x
      // Xr - Xa
      mon_XRmoinsXA  est Fraction256 =corps.soustractionFractionModulo_mon( XR, mon_pointA.X )
      
      // L * (Xr - Xa )
      mon_LFois_XRmoinsXA est Fraction256 =    corps.multiplicationFractionModulo_mon( mon_L,  mon_XRmoinsXA)  
      
      mon_pointRésultat.y = corps.négationFractionModulo_mon( corps.additionFractionModulo_mon( mon_pointA.y,  mon_LFois_XRmoinsXA )   )
      
      // renvoie mon( résultat )
      renvoyer mon_pointRésultat;
     type : 458752
   -
     name : pointFractionPlusPointFraction
     procedure_id : 1991110374459798056
     type_code : 12
     code : |1+
      // Addition d'un point avec une autre
      PROCÉDURE pointFractionPlusPointFraction(pointA PointFraction256, pointB PointFraction256)  : PointFraction256
      
      // cas du 0
      si (pointA.EstZero()) renvoyer pointB;
      SI (pointB.EstZero()) RENVOYER pointA;
      
      // cas d'addition d'un point a lui même
      si pointA.PointEstEgalA( pointB, :corps ) alors
      	renvoyer pointFractionAuCarré(pointA)
      FIN
      
      // si A et B sont inverse
      si  pointA.X =  pointB.X
      	// le résultat est 0.
      	pt0 est PointFraction256;
      	RENVOYER pt0;
      fin
      
      // calcul pour OPTIM
      // pA.x = A/E   pB.x = B/F
      // pA.y = C/G   pB.y = D/H
      // 
      //  L = (Ya - Yb) / (Xa - Xb)
      //  L = (C/G - D/H ) / ( A/E - B/F )
      //  L = ((CH - GD) / HG ) / ( (AF - BE)/EF )
      //  L = ((CH - GD) / HG ) * ( EF/(AF - BE) )
      //  L = ((CH - GD) * EF ) / (HG * (AF - BE))
      
      //----
      // X = (L*L - Xa - Xb ) 
      // X = ((CH - GD) * EF ) / (HG * (AF - BE))² - A/E - B/F 
      // X = ((CH - GD) * EF ) / (HG * (AF - BE))² - (AF - BE)/EF 
      
      
      // formule trouvé sur le net :
      // L = (Ya - Yb) / (Xa - Xb)   Modulo P
      N est Fraction256 =   corps.soustractionFractionModulo(pointA.y, pointB.y ) 
      D est Fraction256 =   corps.soustractionFractionModulo(pointA.x, pointB.x ) 
      // division modulaire : opération la plus lente...
      L est Fraction256 = corps.divisionFractionModulo( N, D )
      LAuCarré est Fraction256 = corps.carréFractionModulo( L )
      
      PointRésultat est PointFraction256 ;
      //X = (L*L - Xa - Xb ) 
      PointRésultat.x =  corps.soustractionFractionModulo( LAuCarré,  corps.additionFractionModulo( pointA.x, pointB.x ) ) 
      // Y = -(AY + L * (Xr -  Xa ));
      XR est Fraction256 = PointRésultat.x
      RY_droite est Fraction256 =    corps.multiplicationFractionModulo( L,  corps.soustractionFractionModulo( XR, pointA.X )) 
      PointRésultat.y = corps.négationFractionModulo( corps.additionFractionModulo( pointA.y,  RY_droite )   )
      
      
      
      renvoyer PointRésultat;
     type : 458752
   -
     name : pointFractionAuCarré
     procedure_id : 1991110477539102071
     type_code : 12
     code : |1+
      // Addition d'un point avec lui meme
      PROCÉDURE pointFractionAuCarré(point PointFraction256)  : PointFraction256
      
      // formule trouvé sur le net :
      // L = (3x^2) / (2*y)-1  Modulo P
      N est Fraction256 = corps.multiplicationPar3FractionModulo( corps.carréFractionModulo(point.x) )
      D est Fraction256 = corps.multiplicationPar2FractionModulo( point.y )
      L est Fraction256 = corps.divisionFractionModulo( N, D )
      
      PointRésultat est PointFraction256 ;
      //X = (L*L - 2*p.x ) 
      PointRésultat.x =  corps.soustractionFractionModulo( corps.carréFractionModulo(L),  corps.additionFractionModulo( point.x, point.x ) ) 
      // Y = - (L * ( X  - p.x ) + p.y )
      RX est Fraction256 = PointRésultat.x
      RY est Fraction256 = corps.soustractionFractionModulo( RX, point.X )
      RY  =  corps.multiplicationFractionModulo( L, RY)
      RY =  corps.additionFractionModulo( RY, point.y )
      
      PointRésultat.y = corps.négationFractionModulo( RY )
      
      
      
      renvoyer PointRésultat;
     type : 458752
   -
     name : pointFractionEstSurLaCourbe
     procedure_id : 1991111864813599488
     type_code : 12
     code : |1+
      // Indique si un point est sur la courbre
      // ie : y2 = (x3 + ax + b)[mod n]
      procédure pointFractionEstSurLaCourbe( point est PointFraction256) : booléen
      
      
      // calcul de Y^2
      Y2 est Fraction256 = corps.carréFractionModulo( point.y )
      
      //	calcul de X^3 + B
      X3 est   un Fraction256  = corps.cubeFractionModulo( point.x ) 
      X3plusB est Fraction256  = corps.additionFractionModulo(X3, coefB)
      
      // le point si sur la courbe si égalité
      renvoyer Y2.estEgalAModulo( X3plusB, :corps ) 
      
      
     type : 458752
   -
     name : pointPlusPointFraction
     procedure_id : 1997963488521031516
     type_code : 12
     code : |1+
      // Addition d'un point avec une autre
      // les 2 poins ont leus coordonées en fraction (évite le calcul d'inverse modulo qui est long)
      PROCÉDURE pointPlusPointFraction(pointA PointFraction256, pointB PointFraction256)  : PointFraction256
      
      // cas d'adition a 0
      si pointA.EstZéro() renvoyer pointB
      si pointB.EstZéro() renvoyer pointA
      
      // cas d'addition d'un point a lui même : Pas possible ici, car on ajoute des puissance de 2 de G.
      //si mon_pointA.PointEstEgalA(mon_pointB, :corps ) alors
      //	dbgAssertion(faux) // tous les points du tableau prédefini son différents
      //	renvoyer pointAuCarré_mon(mon_pointA)
      //FIN
      
      // calcul pour OPTIM
      // pA.x = A/E   pB.x = B/F
      // pA.y = C/G   pB.y = D/H
      // 
      //  L = (Ya - Yb) / (Xa - Xb)
      //  L = (C/G - D/H ) / ( A/E - B/F )
      //  L = ((CH - GD) / HG ) / ( (AF - BE)/EF )
      //  L = ((CH - GD) / HG ) * ( EF/(AF - BE) )
      //  L = ((CH - GD) * EF ) / (HG * (AF - BE))
      
      //----
      // X = (L*L - Xa - Xb ) 
      // X = ((CH - GD) * EF ) / (HG * (AF - BE))² - A/E - B/F 
      // X = ((CH - GD) * EF ) / (HG * (AF - BE))² - (AF - BE)/EF 
      
      
      
      // formule trouvé sur le net ( https://crypto.stanford.edu/pbc/notes/elliptic/explicit.html )
      // L =  (Ya - Yb) / (Xa - Xb)  Modulo P
      N est Fraction256 =   corps.soustractionFractionModulo(pointA.y, pointB.y ) 
      D est Fraction256 =   corps.soustractionFractionModulo(pointA.x, pointB.x )
      //D=0 si A et B sont le meme point ou si A = -B
      si D.estEgalAZero() ALORS
      	// A= -B ?
      	// si pointA
      	si (pointA.x.estEgalAModulo(pointB.x,:corps)) ALORS
      		dbgAssertion(pointA.y.estEgalAModulo( corps.négationFractionModulo(pointB.y ),:corps)) 
      		// le résultat est 0
      		_zero est PointFraction256 
      		renvoyer _zero
      	FIN
      	
      	dbgAssertion( pointA.PointEstEgalA(pointB, :corps ) )
      	renvoyer pointAuCarréFraction(pointA)
      	
      FIN
      // division de fractions = 2 multiplications
      L est Fraction256    = corps.divisionFractionModulo( N, D )
      // calcul L^2
      LAuCarré est Fraction256 = corps.multiplicationFractionModulo( L, L )
      
      PointRésultat est PointFraction256 ;
      //X = (L*L - Xa - Xb )  = L2 - (Xb + Xa)
      XAplusXB  est Fraction256 = corps.additionFractionModulo( pointA.x, pointB.x )
      PointRésultat.x =  corps.soustractionFractionModulo( LAuCarré, XAplusXB ) 
      // Y = -(Ya + L * (Xr -  Xa )
      XR est Fraction256 = PointRésultat.x
      // Xr - Xa
      XRmoinsXA  est Fraction256 =corps.soustractionFractionModulo( XR, pointA.X )
      
      // L * (Xr - Xa )
      LFois_XRmoinsXA est Fraction256 =    corps.multiplicationFractionModulo( L,  XRmoinsXA)  
      
      PointRésultat.y = corps.négationFractionModulo( corps.additionFractionModulo( pointA.y,  LFois_XRmoinsXA )   )
      
      // renvoie  résultat
      renvoyer PointRésultat;
     type : 458752
   -
     name : pointAuCarréFraction
     procedure_id : 1998168676204217914
     type_code : 12
     code : |1+
      // Addition d'un point avec lui meme en coord fractionnaires
      PROCÉDURE pointAuCarréFraction(point PointFraction256)  : PointFraction256
      
      // formule trouvé sur le net :
      // L = (3x^2) / (2*y)-1  Modulo P
      X2 est Fraction256 = corps.carréFractionModulo(point.x)
      N est Fraction256 = corps.additionFractionModulo( corps.additionFractionModulo( X2, X2 ), X2 )
      D est Fraction256 = corps.additionFractionModulo( point.y, point.y )
      L est Fraction256 = corps.divisionFractionModulo( N, D )
      
      pointRésultat est PointFraction256 ;
      //X = (L*L - 2*p.x ) 
      pointRésultat.x =  corps.soustractionFractionModulo( corps.carréFractionModulo(L),  corps.additionFractionModulo( point.x, point.x ) ) 
      // Y = - (L * ( X  - p.x ) + p.y )
      RX est Fraction256 = pointRésultat.x
      RY est Fraction256 = corps.soustractionFractionModulo( RX, point.X )
      RY  =  corps.multiplicationFractionModulo( L, RY)
      RY =  corps.additionFractionModulo( RY, point.y )
      
      pointRésultat.y = corps.négationFractionModulo( RY )
      
      renvoyer pointRésultat;
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BQAAAAUAAAA6ih3UbgNXHwTtiPSFUEj+2fi/m7v4QV2rqidAupM=
  original_name : Classe1
resources :
 string_res :
  identifier : 0x1b42f45b002bce7b
  internal_properties : BQAAAAUAAAAnMYFQ1bL/vz9ehh7L22SNNSlIzGTOI8h5F/WtgDNP
custom_note :
 internal_properties : BQAAAAUAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
