#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : TEst_ECDA
 major_version : 25
 minor_version : 0
 type : 2
 description : ""
 subtype : 0
window :
 name : TEst_ECDA
 identifier : 0x2b7cfedd00d3a562
 internal_properties : BQAAAAUAAACxHeUIxbZNvvEi196KSYVfgKITg89gyzCvyEIeuuHEH0c1FyBDd7UCXGpUHONBGjWYzNq138gyr2XMYBQH/jCbSb8o08CtbXdmFdbYRb9d39KxuXAGlophEQPGa5Ee/xqqzY08bFXeq50NsCK4yMQMDhpoDFep2crWxtTV4d62rxxmFD3XWU+I5ksQWjS1cWtQawRqmx0aU2tlT/TdULG5ECWCIcf4v99Wcgn13Gtgw1mtluYC42LmfFSwdzud/z7zHGgfKKQbuc2dx0fMr/moPNRj1GmUXDEXaya98fq7OBdOEV9jQPcLkrCnrYmvHbMkJFod5Nh+19tMyiW5e5SYQ6M4nuYk/4cOvrduQk6gFQ97udkAWTQdc9/foDhyGa77HOiRG7QOdvmKYdVi4tIqSlFrzYBIruf0j85FzXUtQwF2RRAEPqQvd+gdoaEquvJQ+uih7XX8s1JKU0yX641bM9eZnuo8fRjoxHWoJPZnZNzNS1Xzc+4gvGEDuuli/sharV8pTQ8yRqyFaHcGJ13zoQeItBRFQ1vDT3j93/uBa7vPELknYBa6FZwt7V4dJ0De25XgVuMBGkaQ0eAiyO6IDL95BVqBaSyTfdJ0yGSDkiw5HPLBH8aosMc2PsYG+/Pz9Pje3oK+2MWAoTJ+bLkLjnMzPnBEpS02nC+pCi6cdQlxevZXx+exobtWrFyE9sohTsytDmQLSydH/jM3SnN1a/Qwg5aWgvfAZXRE3mBFDrSO+naaRlr0C677WwUZUkAGlKWYwq3MCN5UlaeYIoqgRDIBA0857UXLe9loERkGmjTGWSA8d/RSidr6D4shQKIgwfBhQ4SYsj2Qa3Q=
 controls :
  -
    name : priv_pub
    identifier : 0x2b7cfee80119d106
    internal_properties : BQAAAAUAAAAtYQkwgIZ024gJqjUYPr3qFd/+P4Vd1HAxmSu208G7W6QabfO69F//g1IszTFzQu/Kot08ZJT80YlVFSlZpjL5XEyeak1ARbeXz/K7Hck3Ope+qfLlhDrKB0L/urIYHoFHgAxPPvJWpYXlN+kZIMaHQHUAm5RXAE2Yep+wLDQY8kmLD7FLQOVvGm7pYjjdyWf0O5FNA9w2679XnpBxLpIdpKJh86d/cEVhGpbwHgqOxCWq82vp2DvhYtLbp68BNMdit4400AAxgm8ffoBKNDJknu7z/+2CK/6v3tSM7RtPEm/z9qElzSoL0+Xl/1X4V++LtxTK695E14MiNynZ3lw/GnTRlF1Uuh4Q7znKwTB2+/7paBHydd2EH8xxiIvgUxf6jd/gy9OvKEhRnVBpdPJ3F4UG6M3jByER4SQaOKV9+azvsRBaEYty2iVAskxiFmVNmym2b5mU1nvT7Z9VQ+Mf1NQgX/HIDOE9L3YlRRXlB3rP5eHXMXAW3eteI7vIjHK6Z70S1et2WqXZEOtSmiHSz/1Dd0ZKECrpBi/UIQKAIUHbPNOXqbLAu2LT5BnGW42LEGCTqcx7Df9xtPukVq148Amdkh+1ZEK29yzl3lOkTafOf42twBlSJU0ebT0bQ9nZwSHiam9hqoFQ2VQX445CRzyejTmCu85Ut3UEczE9vvOuHWVsJiEEGVWLYxdBG+yLDHpTjFUeZJa3Y4jYGb7u6sMf+flEgwlRsgSDm33cn+dpwUKO+vU/5UJf/1q6qPRFzhEkJjOpGMtikco=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         gbModeBench = vrai
         CrytoLib est ECDSA_BTC
         //ClePrivee est Entier256("75be5c76cde3bcb877a523f618c839cb6ac58269880288734acee9473a180744")
         ClePrivee est Entier256("8727b3b7be9139498f2f48f7b88f92203b1ce5ea527fd7dd754F650e2216b935")
         //CléPrivée est Entier256("2")
         
         Trace("Calcul...")
         ChronoDébut()
         ClePublique est Point256 = CrytoLib.DériveCléPubliqueDepuisCléPrivée(ClePrivee)
         Trace( "Temps (ms) : " + ChronoFin())
         Trace(ClePublique.x.VersChaineHexa())
         Trace(ClePublique.y.VersChaineHexa())
         
         // 5b0ec43c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef87b
         xOK est Entier256("0x5b0ec43c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef87b")
         //xOK est Entier256("0xFD0F6EBE95AAFBED3C431047BB3D9DEA4324B8D6CDBC16D35AE30AC22E9548")
         yOK est Entier256("0xb809f2a2d4c6423c2f946ff6499dffec78385fd75f97245910c358a4a55cfdb6")
         
         
         
         dbgAssertion(ClePublique.x.estEgalA( xOK) )
         dbgAssertion(ClePublique.y.estEgalA( yOK) )
         // b809f2a2d4c6423c2f946ff6499dffec78385fd75f97245910c358a4a55cfdb6
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : FIn1
    identifier : 0x2b8390ec00c21e47
    internal_properties : BQAAAAUAAACP97Axbk02UnDsH+R8rEUyMmQdU26ZRGS9ndVqRcZp4VWE/snY0i3pyxS00J5duC393tQw5rqZcTq37jjyfhX4jFM6vbl0hidvXPf2qJ78VCoEY/j7cl+G6EQxwfPsMAIO1ZM1cWH66hFkag08bcRcVzlVRIpyHvfpAq/y+PyVmtMiF0p8yXN4s2vRcscD+Lh1VE3Ly8p87a+fDNr+3MbpTXAH68RaCg+1E2XiSucF00C+vYQ8sWkcY+5/1/x8gEnb9mZuL+5LdJJFXraP98j1yRfsCq5gv0lUeXeQQ82b44ytKFANlfXED3XrrM21nBuoS0OXwvU1wIwXjQSqHfw9kSnSr85Zc3O9s8h3kF+2wG5u0rGFHEL0cWRxYXrFr7KFeXzi43TRKgm5GKt3w77cdhgpN+U4b1mMJaHnuFRT9DV4TJVAxlWsw2Vju8ALWFIsSvI/r85y5CQlbgIhGhVucSXVDC85TmMqC2fIF6A9mzUuVFRxAFSK9n3ldENP4K+tfmyZzU7WqoxpXb4yFzE5WCri9k4lOtQIis1A/9cm8WVzQMXOz2GRdeWvDpqQHzO1ivJzNivFy5VJkxMBmtQLTFxORh2+4ky2F5DH8rk2SE7qlJOBEHgPDdF5UM0b0aiORI8RPluJOALC4OvZmyaRK8qh/rlVaoQ5dekpwpih0KqhAIvpfj8K+Qi4HUZ9iH9R5JqSyNWLnOQ2aXadv4xEpXiE
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         ferme()
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_Mul_64
    identifier : 0x2b8e1e360145dde5
    internal_properties : BQAAAAUAAACJNYn+ASJawYWXgwiL1A0Wc0XdqSnheap7X7NtoHJwJ86tl2+noeX28kL8SLGKTc+3B2/2qQ6dMAGad1XQYAvzR6jmZe6TQUjSBOjaazJzF5njxfDBKJQEUsEvb5UI0XOZEK4YVU+1nDdzo4VYVyBatb2EmEfPwJEpbVXGV9Ieule7/fhHiHP0ZsPYXJ/QWflEQkqOk5Hd8vThmWv4QoPhWuxkF6s9MgRhr2eMvyDWW3X6TF/BCZmq5P76zyLISCKkz1wRrfPiH6UDYx0mGskmh8/hC3HGg8+AnA+FGB8lPv5Nz+8lacZFNW2mzVlQJG1RTEa3X6sKKz71b7FX9M8syU9ndN8CqxINFMb+z78DyTAmUPUICJSGqt7kFpgEW8cM4Cl7KU0dlnozvxR3xiw19Yv+jlVjW5UF/dCA5gen77L5K5TE59fuxD9eyOT6hBefMRdmn6kUtoF534nRx2OfhGAsZwH4KP2Rw2rPKz891wprAf9xX5AmrTsmTY9kWH4W3yWGxTtEuMVRjAeyiscs2f9nd1iArEZ/kHjpOoZQsJ6QaQIaLq3tbKvQuzDfRvpWT6nSZkmqlOCoPUPIgOtCmJIOzdK688M/aLFa79IZOFAjXIamx6bh+6zb6PbUGrAGlZ1EGJimRkhuBvWB/kx+Zei1HuCiOb5WMQjSHLJ+1OFIDn8CDRXaKIlmB9MaCGCQXdUKcsXifLfefJ+zEDOBOtlVlEXxaqA5iFNM
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         PROCÉDURE interne _multiplication64x64_128( nombreA entier sans signe SUR 8 octet, nombreB Entier sans signe sur 8 octet  ) : Entier256
         
         	//@TEST
         	Résultat  est Entier256 
         	nA est un numérique   (38,0) = nombreA
         	nB est un numérique   (38,0) = nombreB
         	n64 est un numérique  (38,0) = 0x100000000
         	n64 = n64 * n64
         	nAB est un numérique  (38,0)  = nA
         	nAB = nAB *  nombreB
         	sRes est chaine =  NumériqueVersChaîne(nAB,"32X")
         	nMax64 est un entier sur 8 octets sans signe  = 0xFFFFFFFFFFFFFFFF
         	nMax64_num est un numérique (38,0) = nMax64
         	//buf est un buffer sur 16
         	Transfert(&Résultat.val0,&nAB,8)
         	Transfert(&Résultat.val1,&nAB+8,8)
         	//Résultat.val0 =  ETBinaire(nMax64, nAB ) //arithmetique._2_Puissance64) //, 	arithmetique._2_Puissance64 )
         	dbgAssertion( Résultat.val0 = HexaVersEntier(droite(sRes,16)) )
         	//si taille(sRes)>16 alors
         	dbgAssertion( Résultat.val1 = HexaVersEntier(gauche(sRes,Taille(sRes)- 16) ))
         	//fin
         
         	renvoyer Résultat //(Résultat.val0, Résultat.val1)
         fin
         
         //_VerifieAMultB(  0xE6B52D16CF375361,  0xE6B52D16CF375361, "0xcfea0d3dc68974efebb6f377ccd60ac1")	
         //_VerifieAMultB(  0xFFFFFFFFFFFFFFFF,  0xFFFFFFFFFFFFFFFF, "0xfffffffffffffffe0000000000000001")	  
         V1 est un entier sur 8 octets sans signe = 1 //0xFFFFFFFFFFFFFFFF   //0xE6B52D16CF375361
         V2 est un entier sur 8 octets sans signe = 0xFFFFFFFFFFFFFFFE // 0xFFFFFFFFFFFFFFFF 
         
         ResOK est Entier256(  "0xcfea0d3dc68974efebb6f377ccd60ac1" )
         //ResOK est Entier256(  "0xfffffffffffffffe0000000000000001" )
         Res  est Entier256 = _multiplication64x64_128( V1, V2 )
         trace(Res.VersChaineHexa())
         trace(ResOK.VersChaineHexa())
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Génration_Table_Point_2_N_mon
    identifier : 0x2b8f620400c6b0a3
    internal_properties : BQAAAAUAAACSaVwupCiKbruK6TWX742W0nhd8iY+6rtvtJ+MeFHwOgXZM07BemvlbhWdTaT49H7ZCSLHNADDBUbmUPSRxlQ2VG4S3UzJ/QtBy0yAoXRQ4aKPRefkjzu2cVgw3QD/SJi0xLYYYbp4FRX3LM47H3cSdPx7cZ2tPAcPNiDt3jq0hsNGjltL+iEXHeHsKi3R3Pc9K481GjbxEHi7d3Bi3sLIiPNh9ai4psE2adindlRTcrNMdQiRklW9C6g11o1+e2EpNAL82cpxbtGD00pT9bXHFZSTd5UK/VX4v5JOL9DeE8snChCiMFR1aWURNJJIvPDwBbkwfW7nnT6vDiawHbsgLBjatcUf8Hvc/FLs9t4rp5dKZ8bZQyHPXTQW6VO3lsrog0z3q8M2G0UPgJBRvPCJL6KtilMlFkhwhUnSmBVN8W6SCoAE7xAfJ931kjrE4nH31G5cz3kz+U7lRD2RZ40VRL9Tie2c9wR+8XUBcamPxcLi7iNnoR8tvisR0WFSMNZczDZUx/nnt1zHO23Wpl0WUQzSsUaS2dfcMqkh4LPLds6BHCQo0Hyw24kn5auEEW36Gg4U5odNGRMLJ1MXZfRC/vcnYSEb6I4qn0z3uVX3GMRFJYlqqJRYTsYkZo6aO1sxEnTGDnIhtHw05oU77Nmna/UivO4911LCsHJKz0/ERhLYCu/m+tSOumxaguwsFqpPUXn5kuTsFDTdZhPDLhgRfLCsvGAnFcJC/8/hYkd9TT8iTvnbvXjMcbtBGOcszJCnYw==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         CrytoLib est ECDSA_BTC
         corps est CorpsModulaire dynamique <- CrytoLib.corpsECC
         ecc   est CourbeElliptique_secp256k1 dynamique <- CrytoLib.courbeBtc
         
         //GN est PointFraction256 //= CrytoLib.courbeBtc.pointGen
         //_1 est Entier256
         //_1.affecteAvecEntierPositif(1)
         //mon_résultat   est PointFraction256 // 0
         //mon_résultat.x.dénominateur = corps.X_to_monX( _1 )
         //mon_résultat.y.dénominateur = corps.X_to_monX( _1 )
         POUR i = 0 a 255
         	valeurKPow2I   est PointFraction256  =  ecc.TabPointPow2PreCalculé[i+1]
         	// vers mon 
         	mon_résultatvaleurKPow2I   est PointFraction256 
         	mon_résultatvaleurKPow2I.x   = corps.X_to_monX( valeurKPow2I.x )
         	mon_résultatvaleurKPow2I.y   = corps.X_to_monX( valeurKPow2I.y )
         
         	trace("  " + mon_résultatvaleurKPow2I.x.VersEntier256(corps).VersChaineHexa() + " " +	
         		  	     mon_résultatvaleurKPow2I.y.VersEntier256(corps).VersChaineHexa())		
         	Multitâche(-1)
         FIN
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : ECDSA_SigneNombre
    identifier : 0x2b9198d600a6d698
    internal_properties : BQAAAAUAAADlHuYMKnJN70U8igl7mQeTp8PkBEjT+SZjMxc1HG/+w/QLxitPMbbvWGQZlda7KZJ2o3TOCI98MtrOVXjZT6AetoGwnOstQMMtUsBEd19SAUNVzNhVAmEZs5Scy4Oq9VfRpZgnwKrzvlWwNs11lC4u6f43f9iNYug5P5A5C2Meu9yiXa+Gukg8w0wKnYD+iG0v5LO9UDcpGedfhYW4Xwt3Cmib8S3qO8LmkZRAjC5KElcTNbo2nZFoWVZ1rIk6m1dt9Td3oEDrVldbt86uOTtwNcXEi8OKdXH8nU4dSiniEZO06yjHYcdQIbDvw09vxclTl/cBgfCagsWlp6OSIlpeC8wc1a02Q4JXnxso2XvLugZJqpiilngkht71hSNwDh2ywXFEWOOm/LWaDlFwKi3LO4hCzzyJotv0cFc9eYNG/eCQadeNq6SsaeAvr1sCF/XdIP9dqJOZTggsRoo8X3JB5qd8ru5A40dM+mGOtuVqz2IE68SiOfcK4HKJkOiU2Rriwp91vFHvcOyEAx7NdnQEEYJBcIcm1f6craLdzVteDjy2yK5Qu7Fgeq227XQkJkvJRRgMnqRwgzYFJI0XLI5XezCDe/WeJXYbIeXNFzqjp4tSAfcIscOXF1eyiV2gWyhOFCrVH8LB+gQzNMDs5GXc1TfaPI3D7QQrepkAdmcQUYFWSY1Ljx+42YaY/ismymUaF9oWzuUie/FEiCkftytUwMhmzj8mUsl6BjtvNcDk71/KlHbC
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         CrytoLib est ECDSA_BTC
         ClePrivee est Entier256("8727b3b7be9139498f2f48f7b88f92203b1ce5ea527fd7dd754F650e2216b935")
         N est Entier256("12345678")
         
         Trace("Calcul...")
         ChronoDébut()
         signature est SignatureEcdsa
         signature= CrytoLib.SigneNombre( N, ClePrivee)
         Trace( "Temps (ms) : " + ChronoFin())
         trace("Signature : ")
         Trace(signature.R.VersChaineHexa())
         Trace(signature.S.VersChaineHexa())
         retour
         
         CléPublique est Point256 = CrytoLib.DériveCléPubliqueDepuisCléPrivée( ClePrivee )
         sERR est chaine
         bOK est un booléen =  CrytoLib.VerifieSignature( N, CléPublique, signature, sERR )
         trace("Vérif signature :" )
         Trace(bOK)
         Trace(sERR)
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_Mul_65
    identifier : 0x2b9a01bd00828070
    internal_properties : BQAAAAUAAACXY+B66KeEId/OOTaMpLoGys8sfV4qiX6v1mJVVtTUVwtHXSPn2Kd3vbt38qT4jc+37H02M6FLdMGBZyEdMsgBrHYL2cadsfijXVbIlx0ML00OF9425siC92xop24UTIIHtXLBIRy+3HEidGZO0HclLQxgR6mUGSsr3meT2XekkxatixuytM81SO1iD4FtH/NKkACGIQUsKBArxJYhMkTKCPWSpdG34rVDjeixPP+gM7b1V9Lcm7Qzbwo/Hom75kZZmWPbK/N58TixYnzJ0N3LGuAmyRE9+Cjao5ElESl5JPSMWHvbH7vTYQggEvsjjL7TDgVqcBiwD0Voppm0waaj97e7xyMKe9tWDX8mrGrzD47XUsofplIXm4RLIKhzCo6pJ3izLEgmpky6EUHKY1NeBNkSlUoGRYNZucNYB6oagsF5a+DOlbpsSlxJRkC1VEzvUFmrSWUL5S371Depbx0ogff7p6uT3wEdNnSuK4AMjHJYVH30bBYWNF7TFReMBiWhpfqeiB5SXbeaeg4rwnPp27aqWHiLxc6UCD50E7unuk4dpQ3LwINJeavMMpAgZLU98Dt/ZTuYIoi75hLyAs7Qvg1nHLLcdG3sWLPVr4OFS7MW1Ew5nRWejHT4XGEi4cG3+0/rawX9bUv1/Wwq4sIiBRYBDT1j9CntmVey7anpuRHWMNi1FoYEwoZj+4C8PmK45e9W7HYl0zZI0A5YSsS+kBqFGB4efzx846vdqCaZaOp+
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         
         //_VerifieAMultB(  0xE6B52D16CF375361,  0xE6B52D16CF375361, "0xcfea0d3dc68974efebb6f377ccd60ac1")	
         //_VerifieAMultB(  0xFFFFFFFFFFFFFFFF,  0xFFFFFFFFFFFFFFFF, "0xfffffffffffffffe0000000000000001")	  
         V1 est Entier256( "0xFFFFFFFFFFFFFFFFFFFFFFFFFF" )
         V2 est  Entier256 ( "0xFAEAAC7C6663B93D3D6A0D489E" )
         
         ResOK est Entier256(  "0xfaeaac7c6663b93d3d6a0d489d05155383999c46c2c295f2b762" )
         //ResOK est Entier256(  "0xfffffffffffffffe0000000000000001" )
         Res  est Entier256 = multiplication128x128_256( V1, V2 )
         trace(Res.VersChaineHexa())
         trace(ResOK.VersChaineHexa())
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEst_Div
    identifier : 0x2b9d499901f6ea31
    internal_properties : BQAAAAUAAADKjWlU70YBSr6Zhyo4rYnHY1fXUCmjSAFovXwfN+3R6mbmgr+wA6UPU53ODnK8WGZsw5Jr7hNGJ2i4PhJSS4+Z60qWqi/fof367RYHsqJikM8PQ9w4lpJ3gT/X+7AA+yA51zNVKM4NVRCg38WQdddz4NT2nO5bUFAJ51Jx260j1A5s3+0VM1voEFlqWl/6qOjawMMWgy0kmocYr1jr9gIif2ikaTN9DBQIMruKzqYRkqGRa/WdwQRwYCtAnYXsH2FacueHQg3nvFUjMzhXsH7bnxSdj4Ep9Uv07+ttPANXv23+e0hDiX/g07gVxCeKbQ1kepMTHhGtkr6pEWUROFYZpiAI0l2NS5UDN9UqZehAwABQS6XHIpLW8YaF4vderoEqYtIVDAB8ZzX613vD9NLMSS2KXchAfQiQO3MgnD5BYhQEynshErO4ArHU8r6vuTLdvEqeEE50WqruPLNZ64/6EKMGHPrqLGaOjJv55LI57tIF+1bgvEYHeMlPhSjBvFAl3A67s3XV2XQb/TOzA+vWFANZsw19YBG3qtrPwgB+XdSMjCSisd4rxJEVPxPRMda4i1GhV5B6/8+egDot6Vo9LgyWMqgsYegyKM128U8FywTibHI+GghOA1eFLYb8NBgJ7kmSWnobC4g5wy0JjozREGbV8WkZq1+thCEiSY9p9u6oGZPSRrnHQ43zdpYAXQJlJtqIQkCAIWR2guqwibeDzJsoKFqdKzo=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         
         	PROCÉDURE INTERNE _VerifieAdivB( AFormaHexA est chaine, BFormaHexa est une chaîne, QuotientFormaHexa est chaine, ResteFormaHexa est chaine)
         	nombreA est Entier256(AFormaHexA)
         	nombreB est Entier256(BFormaHexa)
         	Q_Etalon est Entier256(QuotientFormaHexa)
         	R_Etalon est Entier256(ResteFormaHexa)
         	Q,R sont Entier256
         	(Q,R )  = divisionEuclidienne256( nombreA, nombreB )
         	SI PAS Q.estEgalA(Q_Etalon) ALORS
         		trace(Faux, Q.VersChaineHexa() + RC + Q_Etalon.VersChaineHexa() )
         	FIN
         	SI PAS R.estEgalA(R_Etalon) ALORS
         		Trace(Faux, R.VersChaineHexa() + RC + R_Etalon.VersChaineHexa() )
         	FIN
         	FIN  
         
         
         _VerifieAdivB("0x23456788fffdcba9877", "0xFFFFFFFFFFF", "0x23456789", "0" )  
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : PGFD
    identifier : 0x2b9d55b302462d21
    internal_properties : BQAAAAUAAABz02i2EmpH8/cN0CkxKS7RLZ9y3qQZ/uz1l8K2ZqemqCTYOZtBK5e2Kn9Vi2PKNarY48PFSzdgarnCQx8zp2a1dxRZ/Buy7WLkgB4twzsxpglvB6IudVDwUxff+XQewr0qzldCrcHNZ3SufR8IeTXae13So+jSaB1NXrXmRCk5MIttiDad9ONQLJiaxn2/9nkvMnKJOdaGTwF7bpjln/TzgQd4K2Er12T57hWyLJfPa0CiVg59jCeT//J+YBE8um5XGXoSussN7l/N62zay2tMFZU32LH7nyEDAMD+gxafoWTb9y/NGkqWX47fm+uPZgscpz1mT+Q4zFrwbIpbXEvjFUSIFiJ5ax7AHDULuq+ajRM2V8UExKodrce0QkN1ul19s50Td+yelCPlMIXJM75iGry1O1Ho79/2PATeDvc9KLkjja14+OtDpA6vrvbUgaxwgbGime7OxShxv223JItC/9hhyFtADFWk7RjJyCFtzF/Enl7l4OgGelbgR94UpASw3RkptEsZvGoWgGXhovcQEYY2/TR9mjY/L7me/UoJOizK/jcSeAkX04UNqtI1sIf2DTcuUfOdv4h61j1UdyFWlGDi/dDRhgpFDhlfXiP8kliINP+m3Uvgjr87nrucuxb81qMvnDOpiHbcrC0b1wJv0RwthDfF0uxdz32Tvfs8BuhYSzyaAfyJ7N2PBC1cmwwUU22rIaigG0stVK/mQvO0eVTo
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         nombreA est Entier256("0x23456788fffdcba9877")
         nombreB est Entier256("0xFFFFFFFFFFF")
         
         // Test PGDS
         _pgdg, u, v est Entier256
         (_pgdg,u,v) = PGCD_Etendu(nombreA, nombreB)
         
         trace(_pgdg.VersChaineHexa())
         trace(u.VersChaineHexa())
         trace(v.VersChaineHexa())
        type : 18
      -
        type : 161
        enabled : false
  -
    name : inverseModulo
    identifier : 0x2ba08bf4027a10b8
    internal_properties : BQAAAAUAAACOOL8rwAth7KQn2ku7q6w9xa+bQzmTbYZX45flQfP9PGPQFDrVfxKyZlIeDBdec+mxRinQqNGqx1InQ8umv9Whuuvq0LOLUz6VqbIgLLflp3sK5/oxjQB9gSU1wCKw9TO7lGVunXcgyymh8PZtw76OW7OkybqR4QJuZAoh6sG0Lt2Jb/UyVM2Rk2iHqiNsstl7JRJ4+Bdw4Bt0pL7w0r5PQWWYC0hhYwQAeDj4r3hIZ/qdwtFp6xmeHn64FRzXyeDjYaCM/JlKYIPcMPSK8r8DTnouqxi8c2Ljuc78hpa806+h0UfVqmw5uoShTzNQB0bYoV0HuKC5Euk0up4+68+G5au3jLwS0z5jJCocTNsABu5JDs2nBUnFH7MVqknvlsMA7kWTpLyALFixwcD3Zh4jsRcwMUtHNSwbsgMtCfS2uA0S4evTeCNrAGeh4TEe3Pdf8dAwI9XUq/V+H8CuvLfswCFHNQu+0Xp7LdwSjM9Cfs3a0oxC2mOTeCUAZ41WecYmt7OhySeY/YBrssf2igB8QboG5RvnT2q3pE/ofUHhh4cU6pWV47r4efgts+gd3lau2ChzI0l+kGrqpzmCRrG8AigcN44ENbWNHsse2xZtjERjhJ2a1REQidofMPlVPHQKsDXcHJxUf6H0wSuIV4U9IhkOYR/bHLNBLHdNUX0nQ655PV43SINKKmt0S3HUwFgo/f1aapXcVkUE2mlHbOk0eQQPTLM/vmRzfVhH
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1-
         gCorps est CorpsModulaire( "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F" )
         
         //P2 est Entier256("1" + Répète("0",28+28)) 
         //P2_Mod est Entier256 = gCorps.multiplicationModulo(P2,P2)
         //trace( P2_Mod.VersChaineHexa())
         
         
         //x est Entier256("2") 
         //x est Entier256("8727b3b7be9139498f2f48f7b88f92203b1ce5ea527fd7dd754F650e2216b915") 
         //x est Entier256("497c0fb9646881ce25a2fc68e89a129135e8715423e73fce0759ecca87d30009") 
         x est Entier256("ea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         
         inverseDex est Entier256
         y_2 est Entier256
         ChronoDébut()
         inverseDex = gCorps.inverseModulo(x)
         Trace( "Temps (ms) : " + ChronoFin())
         //y_2 = gCorps.puissanceModulo( x, gCorps.PMoins2 )
         trace(inverseDex.VersChaineHexa())
         y_2 = gCorps.multiplicationModulo(x, inverseDex)
         dbgAssertion(y_2.estEgalA1(), y_2.VersChaineHexa())
         //trace(y_2.VersChaineHexa())
         
         quotient est Entier256
         reste est Entier256
         ( quotient, reste ) = divisionEuclidienne256( x, gCorps.P )
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_PGCD
    identifier : 0x2badc0020158377f
    internal_properties : BQAAAAUAAAAqbTknXjU8tDzBY5JNdE3f+Z8Vg5OzuE/2lJ8LunkO4XiY9xZOEY14qMLtTD3/vIPrAvfNUJYC1zC/r6viRjg/l6svTVI4JzUkwtlhf7MeIgOUkiHcbXoq3TBsAOPhWbUM8a1V6DxHuA7ldYvBivxh1CXjr5p4ON1q9HVELXpRwkm/EUZgAbrGUsBri0hVbU0tgfx0r+F7nkx7mYFjR2GvgNN5dfBWyg+gWD1+DPP+9neJI4fmhHxpfi8xznsOK+3OLBi/vuzC24qx++jfvFDg2V2IdSQxQSCPrHa6SoNylCdRkpmYBhKX6lp3hqw9OJl0x3788Z8U3XFAKCIpm+CWVCBQwL5IfkUeazhtxaQwqZBgTJwvc4+sx7ki0pfo1nCJqAfJLm3celf6J7paMiUwIAXOVObNDoXqIPD49VlgWjFpX+QTSxTOD8zyCKHKB8Csgb8uUs2PhqB2Y0uG8x6YPXCA/87oy20+dvJdAJv87ENvXycImRdqWIziv+JAtQVtY2Xa+t9RkrpEtEWdbH5BEgkxfdn831SWm2D/g51Km/F6fzhlsFxJm2jMKYlZc2Glh7U024Sw2TnCII7oU+GpnNdzW2+ozIPk3DPmhSxtctEs+TqvDk14nzPz1tG2TNiY7kwjAmO/sldXQF9cJMvrhmqdsvQDFXnsUUH8MB0C9HS2/HXLdUtBGm2iZw+a8RgkNrSSFGiD3szcAK+CMvgPyYZY6XtshOoyIys=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1-
         
         //PGCD_Ex(23,120)
         PGCD_ExR(40,70)
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TET
    identifier : 0x2c228a9a00fa64e4
    internal_properties : BQAAAAUAAAAXT5RS/nd2DCa0XaxejuNeSMjRs97DzGIH4QUK4KDrsYshkCC6HMKHZW7ahlDn9l877JZ+MEQHT5wxdI6M0CNK2sm8pXhHrGUR9pVwlaQBvKc3M0qmz1RCKTNRbeJ0rLnIjj+WBZ/1MVLyZyOq2XsaJUFSM+AMSKuD9j/aLqs/VLVdIPY9WlcuhhwCHjd51FmN0tYNfVDCvVeH7JDXMUqjk+Ng56E9K9aDPuumitURn3bKelL10q/Fqbo0FFv2BPpVeSKaHk1h0C2JGWTQoVWoC5XDqC1Ns5NJHJLGQWTVIfK7n6fluNIAYc7di6klrPMaB/H+N+48zlC8Ot5hysU301ykujYvc8Bu0LM33Lko3d1NaDYVmY2O/u4F1yCegx5sdir4HDXlPeQkqQJOvMdr5ZOm7DIlGrhT26Uz47jy5bzm+hKVmcpw2f2Ye/tdbpXrACpj6lvxpj3EdP5AOYxHmqteLeD5w4rppEH2PdLivXbnSysqob9vC8G1gA9BoY3DzMKS7RCccfuFaTp+AxStTAX3/jVivRtakDBBoEkYyXXj9ebRs5Yy3v6UDQVkg1K75m71FCiQIDUBV/LJEJ5Pz/PX6uX67SNqnaKUS8RN4+N/HbxrHJTbdVGFUJWAZ8BmuI91SkN5GAau8Kdd815Ja/ZZSm2dsrwVkUk1309QoCoypxJAqaTBkIk/YIEUQzIqZdkRT0g4o8un+Mn4JpfYHfAM
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         Signature est SignatureEcdsa
         Signature.R.affecteAvecChaineHexa("13cfb50edf248662ca8d64195cf48b26d90f4ebc1998966d0d9ead4275c20dad")
         Signature.S.affecteAvecChaineHexa("6c2134191f22d1f5fea6848fd23524297fc88c0fb296cd7e955f01370fcda63f")
         
         
         CléPublique est Point256 // = CrytoLib.ECDSA_DériveCléPubliqueDepuisCléPrivée( CléPrivée )
         CléPublique.x.affecteAvecChaineHexa("61b0c48518491955c022d99b0c73b43d947990ae361eced90d5e0d22ce3ab4b7")
         CléPublique.y.affecteAvecChaineHexa("8aa93591f1a2818ffc6e7d575bdc1312055e188616dca470aaefd5bba9b9625e")
         
         N est un entier256
         N.affecteAvecChaineHexa("f49c9d1c8a96157ce04d5651ce201778aba934c3ff245f9c64727ecb2f6fe0ad")
         
         sERR est chaine
         bOK est un booléen 
         (bOK, sERR ) =  ECDSA_Bitcoin.VerifieSignature( N, CléPublique, Signature )
         trace(bOK)
         trace(sERR)
        type : 18
      -
        type : 161
        enabled : false
  -
    name : priv_pub1
    identifier : 0x2dc68581035feaad
    internal_properties : BQAAAAUAAAC1GxaOg8Z93HugH3qLVQrXT8hrSv2sn//NcnbATkuYjLa5HQzLzTKSoZcXJ7bJAM7J1TvCbB67cK8zwh7QLRlL0wdeA+lQJk05MGH1nfUvwhdRBP6+Ykm5XOujCl0cVuw3MoZSze2M+FnqDMpaOIJAmTiCPJeuujK/yyHTY90CHVJMLrHz4C0U4k25jU5UjUymtBokUVTPOhyhRzytvi2QfuVgoViG3N2ImycbBpNjrIzfYPkUG7VKFimJPdVyl4/CgVl/gtlmSTX1/eXYIQ52YDfnCpjoX/nINz+HYI4mhaaY1zTtlrmAGF9Zdlf7kjB7nQxyKpUE8G8EsbggL//Tz04kprqGGOSqv5wMQW7cc1mB9LgSRvFpvDHCuxXcQZptkmmue5XxEBXU62MuzlDaddVmPfMoMkCmvaYnoGJyOkxhke6bmR3b3XKGx53cEg5E4lNT6fgprMHx8D0reiJzSU7sgpc0KWH7jaYijcGfRC1yUHU/dOev3USc2qCMMmEKPdoiJeRTxpwi1W262g0tbZPVGR5XpA19iAeRAgY4OLl+42lK/mzeNqWjBY22hPXejNHdiskzSd+7B6tVWjoMqeOdyhMGUW7ZftVQpANNzN9OaCwoC/7vGzBRVfg+zhZN9eaIVejlXhpZcDb4qnaSVxXSJo9ZWKaQC+dgfGsH5McdtYckt8lbxeCuLnw/rnVFOvCHujpPM36yPp4cBR+ZMHOftXXOLYPH6xBOWt1hTcok39bSy3HsVoIlt1lNw20PGe1h/k5pKHTHoc+cGR1c1p6QoGox
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1-
         gbModeBench = vrai
         CrytoLib est ECDSA_BTC
         ClePrivee est Entier256("0x914f06164094ab80f14de57c15a5dead827a473c005837a5c137167db965a203")
         //CléPrivée est Entier256("2")
         
         Trace("Calcul...")
         ChronoDébut()
         ClePublique est Point256 = CrytoLib.DériveCléPubliqueDepuisCléPrivée(ClePrivee)
         Trace( "Temps (ms) : " + ChronoFin())
         Trace(ClePublique.x.VersChaineHexa())
         Trace(ClePublique.y.VersChaineHexa())
         
         // TEST si OK
         xOK est Entier256("0xc51b1777e1a45b4b3cc29d32cd89153ded2c45d6cadc019207f5aec8b451e9e9")
         yOK est Entier256("0x58f798f6ec04fbcb768aae73f4f58ecd55cbf7326d79adf7cf5bf620ed9acffe")
         dbgAssertion(ClePublique.x.estEgalA( xOK) )
         dbgAssertion(ClePublique.y.estEgalA( yOK) )
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Test_mult_2
    identifier : 0x2dc8390b03833679
    internal_properties : BQAAAAUAAABe/ods33M+Ct/DhPe40arRr290Lqndkhy47OK/GxXcJkTdQ0rHFlNzCmM5wRwQd+YwBxORT5gRP+WuNQderyo/dQILuhypp4ngiOpR7qVTiS8VxN9iMNSQ9rimHcRGiRAZp8yjGW/XO+WUSMFZilJTMxU0rprh5MD2H6cFQM9rDqxCYGfOhDfM/R4mDfrsdi9xONRLRJY2WxWomIDzjAV2BaPuSWTppAU5KVlp9J5UvOkvjD0er8ky+pf8U9wmvQDeyoLeulf6eip5EnoOFrY0KKI8ReSMCcQAhAxvom44dH1NtEdK10aopAP6+YsouN7UnESo80ax2AvL7T+v/YuEuCeRisIKXGBv1BxzqRRJyXG9CRoaevQLkt3ZZBJlvwq1N5Ujc473/1xcQlCj5Vy4empCaoFGeQLzVL3cAFaReEGOEXw62mEp5nK7UmgbGNASqhcwB3xcbxXEyP+37HsaPQPGewst8hI/Yjc9NVzZinMyrw2b7HDZd0yNm8VVuk1bjnUIPRRQkyfC08/iL0kNFNhhN66xxtGHqdt5btzzfF71rQhOe03I7obpszysQiHTasfk/hyFLOCaVR5douznwFClU8rtG8i9lsoeQne8XLExT9aSq+Qr1i12SNCRn9S6FCj2/iUiF1+RkA2sWCsqNOAo/53ywwvGmjMRpK/U/oeG1Q5KlFZO6zXYnH/Y4OP0JPl3C+LgFcCc5T9FN0vi2N7sMUhXnclqjXfJPQ==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         gCorps est CorpsModulaire_pointSepc256k1 //( "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F" )
         
         
         x est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         //x est Entier256("80000000000000000A00000000000000000000000000B00000000000003") 
         //x est Entier256("483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8") 
         //y est Entier256("0x43cf5d4541155780f44aa34089024a194415bd27e39f7acf86848972528faa001") 
         //y est Entier256("0x43cf5d4541155780f44aa34089024a194415bd27e39f7acf86848972528faaae") 
         y est Entier256("0x43cf5d4541155780f44aa34089024a194415bd27e39f7acf86848972528faaae") 
         //soit y = x
         //y est Entier256("1222") 
         xy est entier256
         xy2 est entier256
         //xy_TEST est entier256
         
         // TEST
         //sDLL est chaine = "C:\Users\Paul Albert\Source\myRepo\LibInt256\x64\DebugDLL\LibInt256.dll"
         sDLL est chaine = "C:\Users\Paul Albert\Source\myRepo\LibInt256\x64\ReleaseDLL\LibInt256.dll"
         dbgAssertion(fFichierExiste(sDLL))
         ChargeDLL(sDLL)
         si ErreurDétectée ALORS
         	erreur()
         	retour
         FIN
         hModule est un entier système = API("kernel32","GetModuleHandleA","LibInt256.dll")
         pAddr est un entier système = API("kernel32","GetProcAddress",hModule,"multiplicationMudulo_sepc256k1")
         dbgAssertion(pAddr<>0)
         
         ChronoDébut()
         POUR i = 1 a 10 000
         	//API(sDLL,"multiplicationMudulo_sepc256k1", &x, &y, &xy)
         	API(pAddr, &x, &y, &xy)
         	//Trace(xy.VersChaineHexa())
         	//x = xy
         fin
         soit dureeAlgo3 = ChronoFin()
         Trace(xy.VersChaineHexa()+";"+dureeAlgo3..EnMillisecondes/10+"ms")
         //retour
         
         
         
         // nouvel algo
         ChronoDébut()
         pour i = 1 a 1000
         	 xy2 <- gCorps.multiplicationModulo(x, y)
         fin
         si pas xy2.estEgalA(xy) ALORS
         	trace("*****ERR*****")
         FIN
         soit dureeAlgo1 = ChronoFin()
         
         // ancien
         //ChronoDébut()
         //POUR i = 1 À 1000
         //	xy_TEST <- gCorps.multiplicationModulo_OLD(x, y)
         //fin
         //soit dureeAlgo2 = ChronoFin()
         
         
         //trace(x.VersChaineHexa())
         //trace(y.VersChaineHexa())
         trace(xy2.VersChaineHexa()+";"+dureeAlgo1..EnMillisecondes+"ms")
         //trace(xy_TEST.VersChaineHexa()+";"+dureeAlgo2..EnMillisecondes+"ms")
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Image1
    identifier : 0x2e10ace804c9b359
    internal_properties : BQAAAAUAAABHRyxHauuMBkJyyyr4ldl/qutBigtMbuCLWJtCIrR+97YwRwOyKk0JfNdZfVNtdpXcfLy0LuRW5tW4p0tDxUqfR3y90JgN+VBLVuwv8wYVWkiRJELZ4rOIP1V1hNRKJCGEwabVWZ8qCRcIGPis8hL/szbMRkX/Yji8Pd7NrRch0HRg3c9jQjJjxEQ3NdRNcClq3t1s5+ZmdmalWXVr0Ty6p+igiQPNjtHbhtlPerKAB0/wnwo9wk/JvggM4iYuUGh1NJjaIg7zOGDjV/u2KUhuVhGPKyxB1rzIm1fcQ3VcvQ+7QNs5oJWR5Y1CkaEl8EQZ6DFmCWzOYXq2saWTZzpuyN/XrnrUUoTs8xOIuxqAhDfjtvOXJ8qaBdz7DjLW9XT9ACFVz/C4IEE50j8O8VyqYoqiuR6zvUgv0gqxrxRnY7Pu6Ww5H8uY0GajOSWFlGa3gObfD/nwFxegYM2RIfm/P9T5lI/Ik2P8kpDNSmZhEcebngdASzO/iqaGotVnxHYnx+4Pi4/JtSmVPjNZ/19r8i79fzlatDBJm864V3KH7CJlLNM0lx7p5et95VZ+6suvNVBZ/PYwwsI6vFG++uDpagj32rHLtVYwOuoX63cIcaC+Ne28jnqwR8+R2KymdU46HCoxThwcRWkp9jMIRsGqGVBoMB/J5KJB0/3Gdfib3sx1W1uKTsxURYl4a6dp1XLFqAorqdQ9UOWKFiGGj36ZZxNVj0mRcIL/l6kpi1qbrds/GzJ6o4FBrujd2dCwsYZ9OWC9sMlbioKK5zwcjgnS6w0WM6ubd2/n4ESZs59n5+/nY8un5R3HhOE9YBOc2HBou3MM1OY7EMGy7CVRfVNZBwTMf/YWWVp0YtwxGQMbsHI8/ajbnV8F7w==
    type : 8
    code_elements :
     type_code : 8
     p_codes : []
  -
    name : ECDSA_SigneNombre_ECDSA_VérifieSignature
    identifier : 0x2c02cf800181802d
    internal_properties : BQAAAAUAAAD1EAvNkuokV2xWhLMqIpDTwY28F7AqxjqIM4ZoNrJGOUJo1SYzvosDQfiGsa1RRUGmqAE4GtAd3C/fQ56W4/HtlZUh8qCpe/V9paH2HwKPemo58NB22RqeLsL7PO7dX9piH9fbNGwlC9DKGkO7Lf1p7JluZ/R6Ys/iwJvyBepCFIRKzMHaiDmBsmvA4or/EIGfJAZertNsbov6U6L0dqzQpEv8vmOTQiCFGxCx49wJbX9MhebRZ7X7unjlilKfGmTdGcvC6pFySzKv3C9oZzLHACVb/iLYLrFPCZ07cWu5uTdhNcgwzh1PJfjAkkHGE5jLoGh4OxtT0pNPxYxcyRP09oSOKy89fGmYpZLHMf52trpxfDNXKeXtTdPSe5BcaErSaRD78CTUqtABharlCOar+b/yeDdxdfXRSBH/2IA5jXhmvvjQ+zNbsRyer2SnG2F7YFALL780e0VVisJ3Y1e17DUY+eelRL1HSTuYbOBJT7xBKSWjeWCuTwwnKo5FBEv9liok8PBR1CPmLbqhT9OFqBEz0FCyQj7bII/KUkKAsjnPJxbwO73bIpPOwRpwbmA1q/EE/56w9AScBc9Y9F+2zGbCh3ISOZGr9NFCeQhzXjalfAYkD4INYkJXZnTUJDj2ScKrD2HfrJpJghiYe4kHTAz33JXHKqdJI1scEW2vhI5aLTGsoja0W/Q1Zsr/oqYO8SE+/iZNDSU4NDP9BTJcYj8rvV8QSzAB7EppfYzIHTnPQxnrjScUtFXK2PKVd0GSz3NOHGXbjnAXyZI=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         CrytoLib est ECDSA_BTC
         ClePrivee est Entier256("8727b3b7be9139498f2f48f7b88f92203b1ce5ea527fd7dd754F650e2216b935")
         N est Entier256("12345678")
         //CléPrivée est Entier256("3")
         
         Trace("Calcul...")
         ChronoDébut()
         signature est SignatureEcdsa
         signature = CrytoLib.SigneNombre( N, ClePrivee)
         Trace( "Temps (ms) : " + ChronoFin())
         trace("Signature : ")
         Trace(signature.R.VersChaineHexa())
         Trace(signature.S.VersChaineHexa())
         
         CléPublique est Point256 = CrytoLib.DériveCléPubliqueDepuisCléPrivée( ClePrivee )
         Trace("Clé publique : ")
         Trace(CléPublique.x.VersChaineHexa())
         Trace(CléPublique.y.VersChaineHexa())
         
         sERR est chaine
         ChronoDébut()
         bOK est un booléen =  CrytoLib.VerifieSignature( N, CléPublique, signature, sERR )
         Trace( "Temps (ms) : " + ChronoFin())
         trace("Vérif signature :" )
         Trace(bOK)
         Trace(sERR)
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_SQR
    identifier : 0x2e11a4eb00e97d0e
    internal_properties : BQAAAAUAAADXKNRGeRFqjPBjXx5zfGWpldVPC4yUrRots4lsoQOU9WqMyyxAY+WiFn4bOrk18n9lPiPbJmS5PWuDeIVWKrf0DWSKvwbEcwuAps1PWVTYHOsn9vVAIb7u6aTwVKcVjZmo7elR9JgjdLqDpyFp6gCpB0Q2oYAIpCnkA77cwt8vztZJBdfhHtpO/b+VwjA4mgew8eiihR9HpJJnE1+nJX97+ucBhxYsNlVWVCdoTMF8WrXRb+WgDqSP9BP/uNM48SHAKAS9vOr+3TDN0epntjJID+VM+waDqYbpjODANo3weO052seOlA4N2KaJ7FizMmFyt/oSD1WYQ/d8Ztzxyb5i0pgcgqTmoo8gA/LPRU5WFRpUNCoFvsTdbEIJMTZTZeG0Mb7sSTTF6+Rzfgn5hUjVW5a1X+n8P7LfMU8f3HSXU+D6ho+mekWDwE2hv2gFQg1numaJNZQ4L7Gb7uaZwtEtSPF/iklnTOq7820gw9o3SWaQZgIrmOizmYG1wv1X3N6wqDCZIfJup4+dK7Qc/yUqsapYGHwT6OEjbLbH2uWAzsCOvo3aIJFdJbpHImT95lJJ6ARFnI95fg2TeihypXdd+jPf79uUgLf4sDc6wRAB1sU4jVbDIok0S3utPH8eJDBIlmx5jOXNfsrV1ILmOuHDz7dJ2N8KDu5B9vTHy3ztEUN7P1TqANDGn+IV8oIJCLFPObPXmRdEn739cz7hgWss1C+DBB6PoYmd3lY=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1-
         CrytoLib est ECDSA_BTC
         corps	est CorpsModulaire dynamique = CrytoLib.corpsOrdre	//( "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141" )
         
         
         //x		est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         // x= n-3
         x		est Entier256("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e") 
         //x		est Entier256(3)
         //x		est Entier256(3)
         
         // y   = 70ad49ae7f8574ecab641a42b3a24f22d6374023944cc665a6bcaeb0f37bbf78
         // y^4 = 1
         
         //x		est Entier256("0x04") 
         //n=				   fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         //nSur2 est Entier256("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0")  // n/2 - 1
         //nPlus1Sur2 est Entier256("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1")  // n/2 - 1
         //nSur3 est Entier256("0x55555555555555555555555555555554e8e4f44ce51835693ff0ca2ef01215c0") 
         //nSur4_Moins1 est Entier256("0x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d9050") // n/4 - 1
         //nPlus1Sur4   est Entier256("0x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d9050") // (n+1)/4 
         //nSur4_Moins1 est Entier256("0x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d904F") 
         //n_8   est Entier256("0x1fffffffffffffffffffffffffffffffd755db9cd5e9140777fa4bd19a06c828") // n/8
         //n_16  est Entier256("0x0fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036414'") // n/16
         
         // calcul racine cubique de X 
         Trace(x.VersChaineHexa())
         racineCaree_x est un Entier256 = _RacineCaree_SHANK(x)
         Trace("y = racine(x) =" )
         trace(racineCaree_x.VersChaineHexa())
         //
         Trace("y^2 =" )
         yy  est un Entier256 =  corps.multiplicationModulo(racineCaree_x,racineCaree_x )
         trace(yy.VersChaineHexa())
         ////Trace("y^3 =" )
         //yyyy est un Entier256 =  corps.multiplicationModulo(yy, racineCubique_x )
         //Trace(yyyy.VersChaineHexa())
         
         //divisionEuclidienne256()
         //inverseModulo
         
         
         
         procédure interne _RacineCaree_SHANK( nombre entier256  ) : entier256
         	
         	// p = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         	trace(corps.P.VersChaineHexa())
         	// p-1 = 2^s * t
         	// p−1 = 2^6 * x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d905
         	// s = 6
         	// t = 0x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d905
         	t			est entier256("0x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d905")		// = (p-1) / 64
         	tplus1Sur2	est entier256("0x1fffffffffffffffffffffffffffffffd755db9cd5e9140777fa4bd19a06c83")	// = (t+1)/2
         	
         	// au "hasard". ne dois pas être un résidu quadratique
         	M			est entier256("0x40bf3e95c2d24abb0dc4a579b08c0d3f52ef113a8484f33e83de2d1fef487b48")	
         	
         	
         	B  est entier256 =  corps.puissanceModulo( nombre, t)
         	_X est entier256 =  corps.puissanceModulo( nombre, tplus1Sur2)
         	Y  est entier256 =  corps.puissanceModulo( M, t)
         	R  est entier    =  5 // s-1
         	
         	//@TEst
         	_32 est Entier256(32)
         	_yy est un entier256 = corps.puissanceModulo( Y, _32)
         	trace(_yy.VersChaineHexa())
         	
         	tantque R>=1
         		
         	  // calcul de B^(2^(R-1))
         	   _2PuissanceRMoins1 est entier sans signe sur 8 octets = Puissance(2, R-1)
         	   trace(_2PuissanceRMoins1)
         	   _2PuissanceRMoins1_256 est entier256(_2PuissanceRMoins1)
         	   B2R1 est entier256 =  corps.puissanceModulo( B, _2PuissanceRMoins1_256)	
         	   
         	   //@Test
         		_2PuissanceR	est entier256( _2PuissanceRMoins1*2 )
         //		B2R				est entier256	=  corps.puissanceModulo( B, _2PuissanceR)	
         		B2R				est entier256	=  corps.carremodulo( B2R1 )	
         		trace("R="+R+":"+_2PuissanceR.val0+":"+B2R.VersChaineHexa() )
         		Multitâche(-1)
         		dbgAssertion(B2R.estEgalA1())
         		
         	   
         	   // si c'est 1 
         	   si B2R1.estEgalA1() ALORS
            	
         	   		// Y = Y^2
         	   		Y =  corps.carréModulo(Y)
         	  sinon
         	  	    // B = B*Y^2
         	   		B = corps.multiplicationModulo( B,  corps.carréModulo(Y) )
         	   		// X= XY 
         	   		_X  = corps.multiplicationModulo( _X, Y )
         	   		// Y =Y^2
         	   		Y =  corps.carréModulo(Y)
         	   		
         	   fin
         	   R--
         	FIN
         	
         	renvoyer _X
         FIN
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_MAP
    identifier : 0x2e12d85900ed5c65
    internal_properties : BQAAAAUAAAALryc4h2HrotqgMkyTLBhpmgkbwNXghxWQ4RKZxV1QWV9vQLqgw+afKa+n8IBB6Hu1qqQfRj8Mo8bsqKGdKyJfuZ3UCydvqGnUBZVlR7cD7XkSQoqot4Xe2YOE0K9vrGiFw3V+Nx0l4FD1gSIb1y6Uhab2Nvc2a/lP6zgzMXnhhK3qx7RyIwQE7jIdrIG8wfIKC1pqgUN9xi6vRYU8RqH3VO5mYxVLjqBzfatKi+ycUYOYkk9fu5kqEuA22YKQAmzalS59c3l233dR01/mwgek1Q1Tt6tMP4cKuo/72N9zTNRzQVPrC8adszfuy+206stbTnj7vTm+O/gro/ObiLFuF0UJyGFQ737b3rakQ6sRp9ZUgqnuajktj8vRd2fVDrRLV5b8lNIW4TdAXHVWd4OGBLKjb0gwLNRawhlNaQSWmI30pMELWGRtQew72Uvjk+guYGCLxgpxNRoKmNZMfCrgR6/9FECBlVgyXMsc3mx8kLVOnrCUhDlRAjjfcsrZ65OdYsYTDLTZP0bqEYgR21pBDGpQHA+JoU10N4Qf6yO3U2kKHg0j7hSLTCPLaFWpGRNGqobT0RFZO4fb+Y8yKFOtWJjiyi3LeOJ++L5JySff5P2/QAc1X+93xx3osZ8rqJjmWUUZd4EQmscwdsLjwISMwJVT/EjaL0TIg3Z91DbUDpy7v9rNsk+API2vYG1vfRCWjXVN/m89bWQiy3yo2zOeGAcBQrEN8Gbz8s3K
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib est ECDSA_BTC
         corps	est CorpsModulaire dynamique = CrytoLib.corpsOrdre	
         
         
         
         // nombre d'odre 3.
         // ie tel que  beta^3 = 1 mod 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         //beta  	est Entier256("0xac9c52b33fa3cf1f5ad9e3fd77ed9ba4a880b9fc8ec739c2e0cfc810b51283ce")
         // ie tel que  beta^3 = 1 mod 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
         beta  	est Entier256("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
         
         // Racine carrée de 3:
         //racineDe3      est Entier256("0x3538be51af024152640d9ba6e4fa9c5ce6ed7102d28e789bcc8921c18a34cf78")
         //// Racine carrée de -3:
         racineDeMoins3 est Entier256("a6c75a9980b861c14a4c38051024c8b4245c45d44102ccf1be052cf836477ae5")
         //// racine de X^2 + X + 1 = 0 :
         //// (1 - racineDeMoins3) / 2:
         //// 0xac9c52b33fa3cf1f5ad9e3fd77ed9ba4a880b9fc8ec739c2e0cfc810b51283cf
         _moins1 est Entier256("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
         _1 est Entier256(1)
         _2 est Entier256(2)
         //_1_MoinsRacineCaréeDe3 est Entier256 = corps.soustractionModulo(_moins1, racineDeMoins3)
         _moins1_PlusRacineCaréeDe3 est Entier256 = corps.additionModulo(_moins1, racineDeMoins3 )
         //_moins1_PlusRacineCaréeDe3 est Entier256 = corps.soustractionModulo(_moins1, racineDeMoins3 )
         //trace( "-1-sqrt(-3)   = " + _1_MoinsRacineCaréeDe3.VersChaineHexa())
         _L est Entier256 = corps.divisionModulo( _moins1_PlusRacineCaréeDe3 ,  _2 )
         trace( "-1-sqrt(-3)/2 = " + _L.VersChaineHexa())
         //Trace( corps.multiplicationModulo( _L, _2).VersChaineHexa() )
         
         // racine de X^2 + X + 1 = 0 ( modulo xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 )
         //_Racine est Entier256("ac9c52b33fa3cf1f5ad9e3fd77ed9ba4a880b9fc8ec739c2e0cfc810b51283ce")
         _Racine est Entier256("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72")
         //_Racine est Entier256= _L //("0xac9c52b33fa3cf1f5ad9e3fd77ed9ba4a880b9fc8ec739c2e0cfc810b51283cf")
         x est Entier256 = corps.additionModulo( corps.carréModulo(_Racine), _Racine )
         x =  corps.additionModulo(x, _1)
         dbgAssertion(x.estEgalAZero())
         //trace("X^2 + X + 1     = " + x.VersChaineHexa())
         
         
         P est Point256 = CrytoLib.courbeBtc.pointGen
         P =  CrytoLib.courbeBtc.pointDouble(P)
         
         // _Racine^2 marche ausi ?
         // _Racine = CrytoLib.corpsECC.multiplicationModulo(_Racine,_Racine)
         
         // on doit avoir _map(P) = _Racine * P
         mapP  est Point256 = _map(P)
         trace("Map(P) : " )
         trace(mapP.x.VersChaineHexa())
         trace(mapP.y.VersChaineHexa())
         //moinsX est Entier256 = CrytoLib.corpsECC.négationModulo( mapP.x )
         //Trace(moinsX.VersChaineHexa())
         KP  est Point256 =  CrytoLib.courbeBtc.MultiplicationScalairePoint( P, _Racine )
         Trace(" K*P : k = "+ _Racine.VersChaineHexa()  )
         Trace(KP.x.VersChaineHexa())
         Trace(KP.y.VersChaineHexa())
         
         
         // (x, y) => (βx, y) 
         procédure interne _map( _p est Point256 ) : Point256
         	pointRésultat est Point256 
         	pointRésultat.x =  CrytoLib.corpsECC.multiplicationModulo( beta, _p.x )
         	pointRésultat.y = _p.y
         	renvoyer pointRésultat
         FIN
         
         PROCÉDURE INTERNE _map2( _p est Point256 ) : Point256
         	RENVOYER _map(_map( _p))
         fin
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_SQR_3
    identifier : 0x2e142a0400e15cc3
    internal_properties : BQAAAAUAAAAVqT0ilX2LBh5sxscyqzDBvq7kjpt7l8RNdT/GnAFfDhkO+vCWcOq/m1tnS4wFRJZSmKJHhKme5eL/UvhjU5qSBmmxKkkuqllWj0jt8ieF60MJfk1r50SQRBvvpljQ44VPkJIEO8nC9rZsPrpaxZwPVEGlKY3co33DJ+WGm9vmbtO+22jW53hI0p7R8IVKGUo2J2Z2WZc9UgpDmZlASpF/INoGj7Untuzf8Q/uh1CUGb80iqPfJ/GuTmRyJY5sIpyOoSbhm8VmUzP1H7uCVn/USQljS2vIt7MmfkMXPHPjfCDXWW8zN74BZ6Py78mQAsv3OvAHTbVO35w3r7fXPIGm2wEp9DHErzqPmoKAbx8xh/Lo0qXuTjMXrQlTiRUHQCKJsUBOWhQ4o82GFr+cIVXU0iwdwU4q3gYAAMufx7Zg5htmHqPJ4k63n2J1ewmlRV4U+oqNpGzjh1Doikgy5kQ2XRHHxmYbxzpQKg1+pAb2zsP4EOrCTpMbUOZRBGAzFflT5NgN+sZrAQToI/qnhcx3ggxSZpU7U5+SEZo9bXHLJw1mQmmHQnAXWC8Xym1uzHgksZHUtJYWGlcgJ/BwzKq0hmJ2t6eVAedpM9dTlQnzrK5KoFtedldjz07RpErucuDOqiY4ioZermpAQLG7hMS27Sh73nKIsda8r16y8kzS6PUA1Me8i7VaKitYa11wSBi4HZ0+UiVe2N20ZuP91us5cp2vKCvLvlTt/MfQ
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib est ECDSA_BTC
         corps	est CorpsModulaire dynamique = CrytoLib.corpsECC	//( "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F" )
         
         
         x		est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         // x= n-3
         //x		est Entier256("2") 
         //x		est Entier256(2)
         //x		est Entier256(3)
         
         // y   = 70ad49ae7f8574ecab641a42b3a24f22d6374023944cc665a6bcaeb0f37bbf78
         // y^4 = 1
         
         //x		est Entier256("0x04") 
         //n=				   fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         //nSur2 est Entier256("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0")  // n/2 - 1
         //nPlus1Sur2 est Entier256("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1")  // n/2 - 1
         //nSur3 est Entier256("0x55555555555555555555555555555555555555555555555555555554fffffeba") 
         Trace(x.VersChaineHexa())
         _9 est Entier256(9)
         _1sur9 est Entier256 = corps.inverseModulo(_9)
         Trace("1/9 = " )
         Trace(_1sur9.VersChaineHexa())
         // calcul racine cubique de X 
         _3		est Entier256(9)
         _1sur3	est Entier256	= corps.inverseModulo(_3)
         
         racine6eme_x est un Entier256 = corps.puissanceModulo(x, _1sur9)
         Trace(racine6eme_x.VersChaineHexa())
         racineCubique_x2 est un Entier256 = corps.cubeModulo( racine6eme_x)
         Trace("x^(1/9) ^3 =" )
         Trace(racineCubique_x2.VersChaineHexa())
         //
         racineCubique_x est un Entier256 = corps.puissanceModulo(x, _1sur3)
         Trace("x^(1/3) =" )
         trace(racineCubique_x.VersChaineHexa())
         //
         Trace("y^3 =" )
         yy  est un Entier256 =  corps.multiplicationModulo(racineCubique_x,racineCubique_x )
         yyy  est un Entier256 =  corps.multiplicationModulo(racineCubique_x,yy )
         trace(yyy.VersChaineHexa())
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_MAP2
    identifier : 0x2e155cf800e36084
    internal_properties : BQAAAAUAAADuGNIDUlm1YJLoyAfw6fx9FpZMhGZeZo9uavGN2keb8n36cq4OiAANu0sdn/Jb/BbqCJ4xzPFUO+r32DC1he62Jsk1/BULxhcgScNfmGjGQFB+0vj4C9+olfcSaKlhuMQhkFcwBTf5yoIbgyQt2aRSR1iQQEFhC3XlTbRNSemHkl+M0ZBQ8XhAINhBJgXgeYiIuVjek8HNCnw5YcP4EkPpynRMH8Pl+vTBH0dM93gOi63qDC9BqRny/LaS1xLYSOo0t1SJxYt6D+UTg/0ekrHWT09Ry2EGQwcoRDc9CL8lVm6lp9ftAV5l1W0WXcHYTH3JHBbnz+v6Y8ZdF6lnZN90CYe/DIeqA4K9RDbOh+fLebhWsHUoqNhKlhKgMrzgB6twZI3/jdmxGnY3uxBrcoiJKU+iQtlfb7nxEdys6oMTUyYtj+jII6syAFOqpFjGoDtDRTu6Y/VYGj2t++VVQ+9jCKRwm5U07MHdd4aL78upS47/tZMVO4QKSe8CacMgNKJq4zmKmSfILPFFWEPWdtPADVMrG6xsgEpLlhd+lHzSIDR9d0LiJ0luZTToGeQqjLi9eb9gOOIVV3v/gRuaUK9JpAhyRoXZKiwsyoVY/mIYq1J4D+5WRua8EpC3PiwOX5HhZMaCJqKBoxVrv/CAT/Ghho1S9SsfSG8Huq2x9yePMw7Bf/KZrjD3DX4XmuJrRRs9lgZBcY4ZFQSrrZrqeUxYUz7KC/DOubEO3Tin
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib est ECDSA_BTC
         corps	est CorpsModulaire dynamique = CrytoLib.corpsOrdre	
         
         
         _P est Entier256("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")
         
         
         
         P est Point256 = CrytoLib.courbeBtc.pointGen
         //P =  CrytoLib.courbeBtc.pointDouble(P)
         
         // Test que 2 P = map(P) - map(map(P)) ?
         
         // on doit avoir _map(P) = _Racine * P
         mapP    est Point256 = _mapFrobenius(P)
         dbgAssertion(  CrytoLib.courbeBtc.pointEstSurLaCourbe(mapP))
         mapP_2  est Point256 = _mapFrobeniusCarré(P)
         moinsMapP_2  est Point256 =   CrytoLib.courbeBtc.pointNégation(mapP_2)
         moinsMapP    est Point256 =   CrytoLib.courbeBtc.pointNégation(mapP)
         
         _2_MoinsP est entier256("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413f")
         _T_fois_mapP  est Point256 =  CrytoLib.courbeBtc.MultiplicationScalairePoint( mapP_2 , _2_MoinsP )
         
         _P_  est Point256 =  CrytoLib.courbeBtc.pointMoinsPoint( mapP_2, _T_fois_mapP )
         
         // ---1
         trace("  Map(P) - Map(Map(P))   : " )
         trace(_P_.x.VersChaineHexa())
         trace(_P_.y.VersChaineHexa())
         ///---2
         //_2 est Entier256(2)
         _1 est Entier256(1)
         
         
         
         _1P  est Point256 =  CrytoLib.courbeBtc.MultiplicationScalairePointGenérateur( _1 )
         Trace(" P :"  )
         Trace(_1P.x.VersChaineHexa())
         Trace(_1P.y.VersChaineHexa())
         
         
         // (x, y) => (x^2, y^2) 
         procédure interne _mapFrobenius( _Pt est Point256 ) : Point256
         	pointRésultat est Point256 
         	pointRésultat.x = CrytoLib.corpsECC.puissanceModulo(  _Pt.x, _P )
         	pointRésultat.y = CrytoLib.corpsECC.puissanceModulo(  _Pt.y, _P )
         	renvoyer pointRésultat
         FIN
         
         // (x, y) => (x^4, y^4) 
         PROCÉDURE INTERNE _mapFrobeniusCarré( _Pt est Point256 ) : Point256
         	RENVOYER _mapFrobenius(_mapFrobenius(_Pt))
         fin
        type : 18
      -
        type : 161
        enabled : false
  -
    name : K1_K2
    identifier : 0x2e1826970129ec26
    internal_properties : BQAAAAUAAADmOeXS+sT7DeUOslv2hwAKomIYYlFQYhlY/rxJRwsgk8rqkQjvcieSenTnDteRDuWVILnr0mi3xV/tTBXgQj+G6VJww3NgD90XNaN7UDEYKyFn3Cn0MiIwt7/eLkYqjEYO2lj4ZjNWX9WI/ORolSA9cP+b2A7418wPTLE5F2Mab8cQS4kQ9PsxzI4CK2/+9ICRoJH+FgxJyN61h9PF3IxkVxN71L9DaZk0N2Ya7SQHO1PmoqYzps+DVxd/QgVzbzn/jfHTtnsaga3kyie6qS9K7zTFZBZa4uLCZV5VkYoK/lrEzQ29dNm46TX43aMf01z/EqU91rz30MBtZd1CnGEF7wfnudMNsbyBQME8WtGac/GtR+BTCfmWzbM6ptOGaNa7uDWlQoMmSldWgW6W6O+O4r1saBK7IBVipDKcQ87ZhYqCYLmm6XZZdItdpBh1ivViNfFZHXqhoDDybuUebX4027JEpAB4wqcUlJ4MfOv5KjrlezZnyUnC5upnDpGBrENBySJebN1r6pPSyjHxDMMt/0e0kxqlXNAMnSOc/AIhK6/9DcJvOPdqT6zVRNSuDckwSdVcPZmidwIitwghDGbeqZR04sQd0tVGtMbNKBNWnhJNq2mnqhjS3jMg7YNsNtaW26STqhPOB5siWx1pjczILjTQX16Zn3s6Vwf2umP8oso0ZqsBtouFFqWWN1N6mVAgIrz2cH+MYZvTl7ATYdMkhDGbfqgvMRZu72c=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib	est ECDSA_BTC
         corps		est CorpsModulaire dynamique	= CrytoLib.corpsOrdre
         N est Entier256 = corps.P	
         // 					0x100000000000000000000000000000000 00000000000000000000000000000000
         _Lambda est Entier256("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72")
         
         nMax128Bit  est Entier256("0x100000000000000000000000000000000")
         
         // trouve x,t,r tels que
         // s*N - t*_Racine = r et r < nMax128Bit
         soit (s,t,r,i) = PGCD_Etendu_StopMax(N, _Lambda, nMax128Bit)
         
         // vérifie que  S*A + T*B = R 
         _SA		est Entier512	= multiplication256x256_512(s,N)
         _TB		est Entier512	= multiplication256x256_512(t,_Lambda)
         _Tmp	est Entier256 
         // r = SA + TB  : 
         bSPositif est un booléen = estpair(i)
         SI bSPositif ALORS
         	//  avec T négatif  =>
         	//  R = SA - TB 
         	_Tmp = soustraction( _SA.valPoidsFaible, _TB.valPoidsFaible  ) 
         SINON
         	//  avec S négatif  =>
         	//  R = - SA + TB 		
         	_Tmp = soustraction( _TB.valPoidsFaible , _SA.valPoidsFaible ) 
         FIN
         trace(_Tmp.VersChaineHexa())
         
         
         Trace("************Trouve :")
         trace("s:"+s.VersChaineHexa())
         trace(t.VersChaineHexa())
         trace(r.VersChaineHexa())
         
         // R-1:
         _0_256 est Entier256
         soit (s0,t0,r0,i0) = PGCD_Etendu_StopMax(N, _Lambda, _0_256,i-1)
         dbgAssertion((i0=i-1))
         // R+2
         soit (s2,t2,r2,i2) = PGCD_Etendu_StopMax(N, _Lambda, _0_256,i+1)
         dbgAssertion((i2=i+1))
         
         Trace("************ -1  :")
         Trace("s0:"+s0.VersChaineHexa())
         Trace("t0:"+t0.VersChaineHexa())
         Trace("r0:"+r0.VersChaineHexa())
         
         Trace("************ +1  :")
         Trace(s2.VersChaineHexa())
         Trace(t2.VersChaineHexa())
         Trace(r2.VersChaineHexa())
         
         procédure interne _F( x Entier256, y Entier256 ) : Entier256
         	res est Entier256 = corps.additionModulo( x, corps.multiplicationModulo( y, _Lambda ) )
         	renvoyer res
         fin
         
         // vecteurs tels que  X + Y*_Lamda = 0 modulo N
         V1_X est Entier256  = r2
         V1_Y est Entier256  = t2
         V2_X est Entier256	= r
         V2_Y est Entier256	= t//corps.négationModulo(t)
         //_Tmp est entier256
         _Tmp = _F(V1_X, V1_Y )
         Trace(_Tmp.VersChaineHexa())
         _Tmp = _F(V2_X, V2_Y )
         Trace(_Tmp.VersChaineHexa())
         Trace("****** ")
         Trace("X1 (v1.x) = " +V1_X.VersChaineHexa())
         Trace("X2 (v2.x) = " +V2_X.VersChaineHexa())
         Trace("Y1 (v1.x) = " +V1_Y.VersChaineHexa())
         Trace("Y2 (v2.x) = " +V2_Y.VersChaineHexa())
         
         X1Y2 est un entier512 = multiplication256x256_512(V1_X,V2_Y)
         X2Y1 est un entier512 = multiplication256x256_512(V2_X,V1_Y)
         _Delta est Entier256 = soustraction( X2Y1.valPoidsFaible, X1Y2.valPoidsFaible )  
         Trace("_Delta = " + _Delta.VersChaineHexa())
         //trace(X1Y2.valPoidsFaible.VersChaineHexa())
         //trace(X1Y2.valPoidsFaible.VersChaineHexa())
         
         // Test de multiplication par K (nombre "au hasard")
         K est Entier256("0x071e443c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef878")
         
         //  = K * Y1 / Delta
         //   =K * Y2 / Delta
         _B1 est Entier256("0x085428ac856e542bb711d2bb9e408611")
         
         K_Y2 est Entier512 = multiplication256x256_512(K,V2_Y)
         
         
         
         _DeltaLow est entier256 = _Delta
         K_Y2.multitpliePar2puissance128()
         _DeltaLow.diviseParUnePuissanceDe2(128)
         reste est Entier256
         trace(K_Y2.valPoidsFort.VersChaineHexa())
         trace(_DeltaLow.VersChaineHexa())
         
         (_B1,reste) = divisionEuclidienne256(K_Y2.valPoidsFort, _DeltaLow  )
         trace("_B1:" + _B1.VersChaineHexa())
          
         
         _B2 est Entier256("0x2b6a121d1ef84b440996421265b4e26d")
         K_Y1 est Entier512 = multiplication256x256_512(K,V1_Y)
         K_Y1.multitpliePar2puissance128()
         (_B2,reste) = divisionEuclidienne256(K_Y1.valPoidsFort, _DeltaLow  )
         Trace("_B2:" + _B2.VersChaineHexa())
         
         
         
         // v = b1*V1 + b*V2
         VX1 est Entier512 = multiplication256x256_512( _B1, V1_X )
         VX2 est Entier512 = multiplication256x256_512( _B2, V2_X )
         
         YY1	est Entier512	= multiplication256x256_512( _B1, V1_Y )
         VY2	est Entier512	= multiplication256x256_512( _B2, V2_Y )
         
         VX est Entier256 = soustraction( VX2.valPoidsFaible, VX1.valPoidsFaible )
         trace(VX.VersChaineHexa())
         K_VX est Entier256 = soustraction( K, VX)
         
         Trace("K-VX=" + K_VX.VersChaineHexa())
         
         VY est Entier256 = soustraction( VY2.valPoidsFaible, YY1.valPoidsFaible )
         Trace("VY=  " +VY.VersChaineHexa())
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : K1_K3
    identifier : 0x2e19a33400edabb1
    internal_properties : BQAAAAUAAAAa/QNtR3Gk55i0+Qcd8DpwbFDYsUsx/hEYVelPsXLYgRXM1yUlYgEBYxX2X8OSvQVtseH6X9+XcB8NGMhoHpKrkKszXwdu29Z15Of9pvxryWBVcrWs8nRzZMn2nsyvoD60SnzcbEi0Xw0SXZtAJIzW2XCyPSdzg8i7YmL7n/1CVX/yl81ZCvsavM4QQxwlX1HERw9W1CIJXtX/OgtgsUdc9/Tnt8ozwIDV8jj7I9U3KUmsyhewLMNuFJRZlwvm8kbQKPrBNDGVqVNiEaOnGHhN5X98T65ACPRPq8t9IjgqSWG3A/Gh5i0Wzt/l81I3KOmcnJh03dzIKHPVszsmIT83pTcwqrpyCIe5SM0SqmNvwey8Xy3znkZ4itJfjOoSNA5GHaH2LFOTrsF2UNS8P48EG382IWbQ6F6lZFD7kq1RaihwxELiEQ/fKWgbE23FI4GzX++svyH99XC8Xhq4CyCnuaS6kaq6SyGhn5U7SlfokcvGDGVXaTHKn7G1fbBlmY7P1hDaAWdfNhNLq8VtvbX7QdFJ6N6iB3F7FPZ0DH6Mql3qjfWNnsvADO/8QgVJRQlyBP+z8OB5AuJ6cYhiljUEJHZYC1ZqGGPiwMvTKlhoR9D8EjwPCQZBHqKjubxEghHozsMGahJj8YJTx5kNZr6BViwPx4VN0xUROGla4UeRnlIL/qb6hg6qBmBG0/tfcj8+B7GxK2+92Atd1RflIafOedjdQzxt+wo=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib	est ECDSA_BTC
         corps		est CorpsModulaire dynamique	= CrytoLib.corpsOrdre
         N est Entier256 = corps.P	
         // 					0x100000000000000000000000000000000 00000000000000000000000000000000
         _Lambda est Entier256("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72")
         //_0_256 est Entier256
         //nMax128Bit  est Entier256("0x100000000000000000000000000000000")
         
         CalculeCoefConstantEuclide( _Lambda )
         retour
         
         // renvoie x + L*y mod N
         procédure interne _F( x Entier256, y Entier256 ) : Entier256
         	res est Entier256 = corps.additionModulo( x, corps.multiplicationModulo( y, _Lambda ) )
         	renvoyer res
         fin
         
         
         
         // Test de multiplication par K (nombre "au hasard")
         K est Entier256("0x071e443c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef878")
         // cas a pb
         //K.val0	=0x8C9709EE2C00DB85
         //K.val1	=0xED340B2E31901BFD 
         //K.val2	=0x5DCE66E6049C6A08
         //K.val3	=0x7B5AAE134D8FDABF
         // cas a pb 2
         K.val0	=0xCD20AFA495B7BF2B	
         K.val1	=0xC1605B209D915713	 
         K.val2	=0x732947073A8716AF	
         K.val3	=0xF5CDDA00DF9C6B90	
         
         
         // renvoie V1,V2,signeV1,signeV2 tels que
         // V1 + V2*R = K ( modulo N)
         // avec V1 et V2 "petits" = sur ~128 bits 
         // signeV1 et signeV2 valent +1 ou -1
         procédure interne _calcVecteurOpimise( _k est Entier256 )  : (Entier256,Entier256, entier,entier)  
         
         	// constantes calculée par utilPourOptim.CalculeCoefConstantEuclide() :
         	_moinsDelta est Entier256("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141") // X2*Y1 -X1*Y2
         	V1_X        est Entier256("0x03086d221a7d46bcde86c90e49284eb15")
         	moinsV1_Y   est Entier256("0x0e4437ed6010e88286f547fa90abfe4c3")
         	V2_X        est Entier256("0x00e5e9bd2461792dd1aca54cdd1d8b2a6")
         	moinsV2_Y   est Entier256("0x58a1bcb25ae2b9cc084678edad30447a7")
         	
         	// B2,B2 : coefficients tels que "(K,0) - (B1*V1 + B2*V2)" soit sur ~128 bits
          	_B1      est Entier256 // ex : "0x276e6bcbe7ba30a0b216a78e91107e13"
         	_moinsB2 est Entier256 // ex : "0x0658d53831aae2574117afb315cc83da"
         	
         	moinsK_Y2 est Entier512 = multiplication256x256_512( _k, moinsV2_Y)	
         	moinsK_Y1 est Entier512 = multiplication256x256_512( _k, moinsV1_Y)
         		
         	trace("K1*Y2="+moinsK_Y2.VersChaineHexa())		
         	trace(moinsK_Y2.valPoidsFort.VersChaineHexa())		
         	trace("delta="+_moinsDelta.VersChaineHexa())		
         	// calcul de B1 =  K*Y1 / _Delta
         	//	         B2 = -K*Y2 / _DeltaZ
         	/// comme delta = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 ~= 2^256, 
         	//  on approxime la division par un décalage de 256 bits vers la droite.
         	_B1 	 = moinsK_Y2.valPoidsFort
         	_moinsB2 = moinsK_Y1.valPoidsFort
         	
         	//moinsK_Y2_haut est un entier512 = moinsK_Y2
         //	_DeltaLow.multiplieParUnePuissanceDe2(128)
              //moinsK_Y2_haut.multitpliePar2puissance128()
         //     Trace("moinsK_Y2_haut=" + moinsK_Y2_haut.VersChaineHexa())	
         	//moinsK_Y1.multitpliePar2puissance128()
         	// calcul de la division entière : donne un nombre de 128 bits si K est sur 256 bits
         //	reste est Entier256
         	//soit (     b1,reste) = divisionEuclidienne256(   moinsK_Y2_haut.valPoidsFort, _moinsDelta  )
         	//_B1.multiplieParUnePuissanceDe2(128)
         	//'0x1a08ee06c6ba89c9f5498001ad0306fdd4382c84d8d3008c7fd6305c0da8a294'
         	// idem B2
         	//(     _B2,reste) = divisionEuclidienne256(moinsK_Y1.valPoidsFort, _DeltaLow  )
         	//_B2.multiplieParUnePuissanceDe2(128)
         //	trace("b1: "+ b1.VersChaineHexa())
         	trace("_B1: "+ _B1.VersChaineHexa())
         	trace("_B2:-"+ _moinsB2.VersChaineHexa())
         	
         	// v = B1*V1 + B2*V2
         	// B1*V1
         	B1V1X  	    est Entier512	= multiplication256x256_512( _B1,      V1_X      )
         	moinsB1VY1	est Entier512	= multiplication256x256_512( _B1,      moinsV1_Y )
         	// B2*V2
         	moinsB2V2X	est Entier512	= multiplication256x256_512( _moinsB2, V2_X      )
         	B2V2Y	    est Entier512	= multiplication256x256_512( _moinsB2, moinsV2_Y )
         //	dbgAssertion(B1V1X.valPoidsFort.estEgalAZero())
         //	dbgAssertion(moinsB1VY1.valPoidsFort.estEgalAZero())
         //	dbgAssertion(moinsB2V2X.valPoidsFort.estEgalAZero())
         //	dbgAssertion(B2V2Y.valPoidsFort.estEgalAZero())
         	
         	// vx     = b1*v1.x + b2*v2.x
         	VX512	est Entier512	 = soustraction512(  B1V1X,   moinsB2V2X )
         	dbgAssertion(VX512.valPoidsFort.estEgalAZero())
         //	VX	est Entier256		  = corps.soustractionModulo(  B1V1X.valPoidsFaible,   moinsB2V2X.valPoidsFaible )
         	VX	est Entier256		  = VX512.valPoidsFaible
         	Trace(" B1V1X= "  +  B1V1X   .VersChaineHexa())
         	
         	Trace(" B2V2X=-"  +  moinsB2V2X   .VersChaineHexa())
         	Trace(" VX ="  + VX	.VersChaineHexa())
         	
         	// vy     = b1*v1.y + b2*v2.y
         	//B1VY1_256 est Entier256 = corps.négationModulo(moinsB1VY1.valPoidsFaible)
         	VY est Entier256         = corps.soustractionModulo(  B2V2Y.valPoidsFaible,  moinsB1VY1.valPoidsFaible   )
         	//moinsVY est Entier256    = addition(  moinsB1VY1.valPoidsFaible,  moinsB2V2X.valPoidsFaible ) 
         	Trace(" VY ="  +VY.VersChaineHexa())
         	//moinsVX est Entier256    = corps.négationModulo(VX)
         	moinsVY est Entier256    = corps.négationModulo(VY)
         		
         	// k - vx = K - (b2*v2.x - b1*v1.x)
         	KmoinsVX est Entier256 = corps.soustractionModulo( _k, VX)
         	//Trace("K-VX ="  + KmoinsVX.VersChaineHexa())
         	//Trace(" -VY ="  + moinsVY.VersChaineHexa())
         	
         	//_0_256_ est entier256
         	signeX est entier = 1
         	signeY est entier = 1
         	VX_Resultat	est Entier256 = KmoinsVX; // corps.additionModulo(     B1V1X.valPoidsFaible , B2V2X.valPoidsFaible ) 
         	VY_Resultat	est Entier256 = moinsVY; //corps.soustractionModulo( B1V1Y.valPoidsFaible , B2V2Y.valPoidsFaible ) 
         	// si VX_Test<0
         	si VX_Resultat.bit(255)=1 ALORS
         		// x' = -x
         		VX_Resultat = corps.négationModulo( VX_Resultat ) 
         		signeX  = -1
         	FIN
         		// si VX_Test<0
         	SI VY_Resultat.bit(255)=1 ALORS
         		// y' = -y
         		VY_Resultat	= corps.négationModulo( VY_Resultat ) 
         		signeY	= -1
         	FIN	
         	
         	// renvoie le vecteur (Lamda-(b1*v1+b2*v2))
         	renvoyer ( VX_Resultat, VY_Resultat, signeX, signeY )
         fin
         
         soit (k1,k2,signek1,signek2) = _calcVecteurOpimise(K)
         
         // on vérifie que le résultat a bien les propriétés attendues
         k1AvecSigne est entier256 = (signek1 = -1) ?  corps.négationModulo(k1) sinon k1
         k2AvecSigne est entier256 = (signek2 = -1) ?  corps.négationModulo(k2) sinon k2
         _Tmp est Entier256
         _Tmp = _F(k1AvecSigne, k2AvecSigne )
         dbgAssertion( _Tmp.estEgalA(K) ,"nombre pas OK")
         // k1 et k2 doivent êtres "petits"
         dbgAssertion( k1AvecSigne.val3 = 0)
         dbgAssertion( k1AvecSigne.val2 < 0x1000)
         dbgAssertion( k2AvecSigne.val3 = 0)
         dbgAssertion( k2AvecSigne.val2 < 0x1000)
         //sinonK
         //	_Tmp =  corps.négationModulo( _FMoins(k1, k2 ) )
         //fin
         Trace("-------------------------------------------------------------")
         Trace("k1:    =" + k1.VersChaineHexa()) 
         Trace("k2:    =" + k2.VersChaineHexa()) 
         Trace("k1+k2*L=" +_Tmp.VersChaineHexa())
         Trace("K=      " + K.VersChaineHexa())
         
         
         // N = générateur du groupe des points  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
         // P = ordre de la courbe               = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         
         // un nombre d'odre 3.
         // ie tel que :  beta^3 = 1 modulo N
         // NB : tout nombre d'ordre 3 est OK.
         
         beta  	est Entier256("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
         // R tel que map(P) = R*P
         // racine du polynome : X^2 + X + 1 = 0 ( modulo P )
         _Racine est Entier256("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72")
         dbgAssertion(_Lambda.estEgalA(_Racine))
         
         	// (x, y) => (βx, y) 
         	PROCÉDURE INTERNE _map( _p est Point256 ) : Point256
         		pointRésultat est Point256 
         		pointRésultat.x	=  CrytoLib.corpsECC.multiplicationModulo( beta, _p.x )
         		pointRésultat.y	= _p.y
         		RENVOYER pointRésultat
         	FIN
         
         
         P est Point256 = CrytoLib.courbeBtc.pointGen
         P =  CrytoLib.courbeBtc.pointDouble(P)
         // on doit avoir _map(P) = _Racine * P
         mapP  est Point256 = _map(P)
         // gestion du cas ou les coefficients sont négatifs
         si signek1 = -1 ALORS
         	// P = -P
         	P = CrytoLib.courbeBtc.pointNégation(P)
         FIN
         SI signek2 = -1 ALORS
         	// P = -P
         	mapP = CrytoLib.courbeBtc.pointNégation(mapP)
         FIN
         bSigneOpose est un booléen = signek1<>signek2
         //ChronoDébut()
         // calcul optimisé
         //P1_optim		est Point256	=  CrytoLib.courbeBtc.multiplicationScalairePointJacobi( P,       k1   )
         //P2_optim		est Point256	=  CrytoLib.courbeBtc.multiplicationScalairePointJacobi( mapP,    k2  )
         
         //KfoisP_optim	est Point256	= CrytoLib.courbeBtc.pointPlusPoint(P1_optim, P2_optim )  
         //KfoisP_optim	est Point256	= CrytoLib.courbeBtc._multiplicationScalaire2PointJacobi(P, k1, k2, bSigneOpose )  
         //
         //trace(chronofin())
         //Trace("KfoisP_optim=")
         //Trace(KfoisP_optim.x.VersChaineHexa())
         //Trace(KfoisP_optim.y.VersChaineHexa())
         //
         //// calcul standard de "KP"
         //ChronoDébut()
         //KfoisP_defaut  est Point256 =  CrytoLib.courbeBtc.multiplicationScalairePointJacobi( P, K )
         //Trace(ChronoFin())
         //Trace("KfoisP_defaut=")
         //Trace(KfoisP_defaut.x.VersChaineHexa())
         //Trace(KfoisP_defaut.y.VersChaineHexa())
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : K1_K4
    identifier : 0x2e1ad517009b85a6
    internal_properties : BQAAAAUAAACcHtah8ESKRa9+ndhFls8QtcfTO478xOXy9punuA3DKs1qdlTElHjudFimOVqmpDrw3+yFXLhC/T5pi1GkpeDPtIf9i+yWXruguYkcPpjvfJtekY8vnJy67AOZa2X+6WERfgwfA3CozVNkE/3nnqWHXrjERmtPGUsl9iHOCephI+Dj1bjgL1afP8u5Mm0S7i+4Nzad3tbl6Vt42ZCPRIaooPIQHctWQGo7r4h/wKjyc6N/6fHht7pkSUFkJnzLf9QqDi8gYGRtMBoYgYvNlYAIhC+cfNXXFXYb8wv+hKHNNmETxZvcArkJK8l97AOuFcwR7mJPI+qTNb2gLqj6V4P+FfnxGCxZqb40KTIBRW2M46qK7FVO2nXZxmyUesiDxoqbJmP7wDzDm8kaogk6I8lQ7I55j1Q8PhyOPQIqTYQOVmOiWqjOndPxZxakoJypCn6H1VB3u+tILvI5v6k9uwNaURQCxZH1alBc5nFGlRZEJJgHZS165k1V/754kXOQxC8dbpsWClQb7gIAyQCLIlMp7YU1ikDLYqubPouslbeJSbkwu0hER3/T7Vx4LTfJ92rSFtX27LxcECJuDKAD9wYiX7+B9x4igZ28NqVavoJ+7BzOlD9QmEyCLwdb90c5r6tblqi3DXt1daxSar/3eNSOxQDLJloocwhiNRQkqBaS6BXgtvvu2ZNGzt/8n+ns5LRUYdcqkK84MvmwTi1hQgHT2uVIg4poVc3q4z5Z
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib	est ECDSA_BTC
         
         // Test de multiplication par K (nombre "au hasard")
         //K est Entier256("0x071e443c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef878")
         K est Entier256
         // cas a pb
         K.val0=0xCD20AFA495B7BF2B	
         K.val1=0xC1605B209D915713	 
         K.val2=0x732947073A8716AF	
         K.val3=0xF5CDDA00DF9C6B90	
         
         //Point = 2*G , pour test
         P est Point256 = CrytoLib.courbeBtc.pointGen
         P =  CrytoLib.courbeBtc.pointDouble(P)
         
         ChronoDébut()
         
         KfoisP_optimJ	est Point256_3D	= CrytoLib.courbeBtc.multiplicationScalairePoint_OptimiseJacobi(P,  K )  
         KfoisP_optim	est Point256	= CrytoLib.courbeBtc._JacobiVersPoint( KfoisP_optimJ )
         
         trace(chronofin())
         Trace("KfoisP_optim=")
         Trace(KfoisP_optim.x.VersChaineHexa())
         Trace(KfoisP_optim.y.VersChaineHexa())
         
         // calcul standard de "KP"
         ChronoDébut()
         PJ est Point256_3D
         PJ.VersJacobi(P)
         KfoisP_defaut  est Point256_3D =  CrytoLib.courbeBtc.multiplicationScalairePointJacobi( PJ, K )
         Trace(ChronoFin())
         Trace("KfoisP_defaut=")
         Trace(KfoisP_defaut.x.VersChaineHexa())
         Trace(KfoisP_defaut.y.VersChaineHexa())
         Trace(KfoisP_defaut.z.VersChaineHexa())
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : ECDSA_VérifieSignature
    identifier : 0x2e1b496d009cf43f
    internal_properties : BQAAAAUAAADBXQbOT5V+ckbrsiCOWXkbGca2NEyxrCEn7eTtJ/R53mzli6uYKdmoKRhksYJUx5scsAPAzn1tDG1dihJV0oZdQdEKDegYjL7sPBAJmtuoTgLbIhTATcQlUs+ISvMuX5cSMy67eBWuEPgXvgnh/6F84TODERj0qAs50OFaPkvWBaNugq1+/vX9IdtmUyAaDVj9kuOx6vFWulozFZdnivHI4dsYCLqRI9ll3pfuARQWhSBpkwToopziSEG9hwef2oOhSh0hW9lU/MGezapHh55BTwm4ld2K43eZRWDNQgwQXXFr4UlD+7iFhGKi2Z3dsh7iSzSSp9YowSaf4R/Xi7S0q6shdxP/XooaK+mOSzufscafUEjYalj2+Atookl+Eblektkho8OTfBSdbXBN4AhRAYueRquNjadjmz4S0qt1MdRXqcz0v60kCPuWUCyCYDM7dQtyj0FKbEMztcO140M3LJjUx6EgUpfnsVA3UemJa15/tZ0XMeKIy3mQ5022pNJKPx2sm230iJ97sknQnDWe+7EP0QTccKoT5hOIY8BeA+P6q0wMNDlpkpmKEU4hgLhEabUcHGeDidgjiDJdnbpMW1kzfbyM62fLbXvGKMiiMQhS2Z7G1lI4nEo3pgrefE50z9e4Kj5F1n2U/euuJSO5LEt3QEq5TjQG6E8i1GTKx+UTCYjkpL4QGAFRGijgYrEnQnL6Me4Qon5hwDFQQsr0mrMJsrPhbpPhXWyB9PltiA+JYf1DlWkxBNZVfg==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         
         
         // signature
         signature est SignatureEcdsa
         signature.R.affecteAvecChaineHexa("381d97bbc2cfbe448bf256bdb5ff9cd6fdbe27726ee4d603a4f92fa541fa7518")
         signature.S.affecteAvecChaineHexa("040e51ef10775569752ce8258dd5c382e1a39ae6530ba1044a58bed5f8ca9d55")
         // clé pub
         CléPublique est Point256 //= CrytoLib.DériveCléPubliqueDepuisCléPrivée( ClePrivee )
         CléPublique.x.affecteAvecChaineHexa("5b0ec43c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef87b")
         CléPublique.y.affecteAvecChaineHexa("b809f2a2d4c6423c2f946ff6499dffec78385fd75f97245910c358a4a55cfdb6")
         
         // valeur signée
         N est Entier256("12345678")
         
         sERR est chaine
         Trace("Calcul...")
         ChronoDébut()
         bOK est un booléen =  VerifieSignature( n, CléPublique, signature )
         Trace( "Temps (ms) : " + ChronoFin())
         trace("Vérif signature :" )
         si bOK ALORS
         	trace("OK")
         	retour
         FIN
         Trace("***************** FAILED ****************")
         Trace(bOK)
         Trace(sERR)
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST
    identifier : 0x2e294ec300e50462
    internal_properties : BQAAAAUAAADe0H65H9kelZv18655x8C7BAMj98enLrZ1Ld1ZvJ6/VirXOCAVzk5J/5P43IUPGORMi8OLFNiyVcesHUvs94pWoxop4A7a/IfeN0l4perw9/sxoE9lUH7PrkTM0riedzu7EUfX75yuutUUnBxLINyhA9y/KxEi3XF7ynUIF21qXCdTcLw9CuicXKZXLE8LcNrp5gOxaInM1SnSnbBli7IwCieX8Xnx/vqPqhw+SXqGrOJDcaIvne7DsSMVkS2tFM92bNYb7krYknhFR254grKqQqFpcyiEfnt1QSD8Sr7XoSf2lek6XDemePwxi9HrSF0lhEC4IrzSNIuoRqw1/0XAFtCW8KoIlmcdmRgCr+6yBalY41xlL7DuYSeUQC6yXy9hnzVdb1NJjj9ODfo9tGLTdBg4MtF7U6nq5Ba0kBHpseMUuwxwJ2VA2UriEiCiot1gBOkgNwVIZoy+kQWJi9d3++0AWUsahr+IMPQbHQmlW0sm89GvjYRuOIjSiY1CNKZT0p18k1EuRjoYKuu69g3iIHD9w2icHOrspV6bHpaUMBVxEZCI1AlNs1zoj5bVhECR1E1H8ldeCs0m5A+3GaSedSHCSVMFX4kaYq3HIfHrWH+1gh/cIuUOmpZ64+vhRfHyZzhjW0LgGrn86I8zFQ+95l3ZTixaXgrbAPiAz96e14D+bm/pkO/Ct1Xdlz1HhIHS1/SOJG8k5vMoZzqUqQ6xKsWzhA==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         //x	est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         //y	est Entier256("0x43cf5d4541155780f44aa34089024a194415bd27e39f7acf86848972528faaae") 
         
         x	est Entier256("0xc51b1777e1a45b4b3cc29d32cd89153ded2c45d6cadc019207f5aec8b451e9e9")
         y	est Entier256("0x58f798f6ec04fbcb768aae73f4f58ecd55cbf7326d79adf7cf5bf620ed9acffe")
         
         CrytoLib	est ECDSA_BTC
         //corps		est CorpsModulaire dynamique	= CrytoLib.corps
         Trace( x.VersChaineHexa( ))
         Trace( y.VersChaineHexa( ))
         
         P est Point256 = CrytoLib.xVersCléPublique( x , vrai)	
         trace("Résultat : ")
         trace( P.x.VersChaineHexa( ))
         trace( P.y.VersChaineHexa( ))
         P2 est Point256 = CrytoLib.xVersCléPublique( x , faux)	
         Trace("Résultat : ")
         Trace( P2.x.VersChaineHexa( ))
         Trace( P2.y.VersChaineHexa( ))
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_SQR_4
    identifier : 0x2e2b94a2009aeb6c
    internal_properties : BQAAAAUAAABChXkrF0jTJkrozwZSOZUTAESmp8KAOZJvtDieX8AUW4OzXVqKYAjbdRs8HGC0mF6kYJ6Vv1iN2HenAr74VnihKpPjS7yAI83FJgAEG4bz3CV6SQBzBcEO5u7KFu5RWMi/0Y4Ah6v5o2dQYP2jGNDVXGRtpsGsPXzXtTQ+pzxpSqiOSsjdLcilbU7+tdsa1H9UL5b9HhHD7zMUqTZ/BHLxlMQ6tv3u/LraZ0LCVQnH7LyKol6PuL4n/eFAqroSr5ujnCJFp/Aw7m0zU3L6c29FzbmEgIX6/5tneNNc41NRBobzTFxPjHoMxWlxFovoBO2ehVea2CuHNBJVc6dEHFIVy1QfoSoD+ZqxQrrcPv9tp0jyWC3jrpMeqLAJEZ0JRDRA0AvAA63yfdPYMSE5nogCd5soUmAyU5nkT4/MQ+SWC41gzQyuJZkQb+rX+CGYCMb/4+qT3vKMrpiVB+dIWOPN7qldTgp3wTv2tERJAL2qsbMmFL2PHfVw83T23iFYp0dAP0mQ6HDG7BtCpkLSpCyTt1aK8r6EqQM6JeOaujDUPQLz51n/TKQB7tP5U5khAHqTLccz+hB2U3GYHCR+RMfGuNcY24fIjAPV9NJQfyGXw3K4TDp/nXoTq1BybqdRsTB5viKeBCxoF9X1fWOHVCBD3KpzsxPHUfF/1vcU+z2brAhKOYPggAtLwRsDZqYISxbXWJpY+JLW+WzOWpQqYzpm2wo5d4qlM8I=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib est ECDSA_BTC
         corps	est CorpsModulaire dynamique = CrytoLib.corpsECC	//( "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F" )
         
         
         x		est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         // x= n-3
         //x		est Entier256("2") 
         //x		est Entier256(2)
         //x		est Entier256(3)
         
         // y   = 70ad49ae7f8574ecab641a42b3a24f22d6374023944cc665a6bcaeb0f37bbf78
         // y^4 = 1
         
         //x		est Entier256("0x04") 
         //n=				   fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         //nSur2 est Entier256("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0")  // n/2 - 1
         //nPlus1Sur2 est Entier256("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1")  // n/2 - 1
         nMoins1Sur6 est Entier256("0x2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa7fffff5E") // p-1/6
         //Trace(x.VersChaineHexa())
         //_9 est Entier256(9)
         //_1sur9 est Entier256 = corps.inverseModulo(_9)
         //Trace("1/9 = " )
         //Trace(_1sur9.VersChaineHexa())
         //// calcul racine cubique de X 
         //_3		est Entier256(9)
         //_1sur3	est Entier256	= corps.inverseModulo(_3)
         
         //racine6eme_x est un Entier256 = corps.puissanceModulo(x, _1sur9)
         //Trace(racine6eme_x.VersChaineHexa())
         //racineCubique_x2 est un Entier256 = corps.puissanceModulo(  x, nMoins1Sur6 )
         //Trace("x^(1/9) ^3 =" )
         //Trace(racineCubique_x2.VersChaineHexa())
         //
         Trace("x =" )
         Trace( x.VersChaineHexa() )
         racineCubique_x est un Entier256 = corps.puissanceModulo(x, nMoins1Sur6)
         Trace("y= x^(1/3) =" )
         trace(racineCubique_x.VersChaineHexa())
         //
         Trace("y^3 =" )
         //yy  est un Entier256 =  corps.multiplicationModulo(racineCubique_x,racineCubique_x )
         yyy  est un Entier256 =  corps.cubeModulo(racineCubique_x )
         trace(yyy.VersChaineHexa())
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Bench_ECDSA_VérifieSignature
    identifier : 0x2e41069e011dea6e
    internal_properties : BQAAAAUAAAAwD+KGOk0bdW6HQBbsWgPSH8dMlemr3s+Uiq4ka8TkIvF3qCIQWIX0yBFzIS5oLXCJr+5pgsiSnDRMVFlip/EW6wvtqQkiDX4tV1EPW0AwG5rAQo/TPAuTKMwgpwG8QGcXU+w2ff15viNu9xDi0UMzviXlo70/hTlVajRowr37Vif7qOWJq+rJ54zoO5jv7sch2vfDLiu1gIZh9RpIZKDyGcmt9VYAEvLwFXCn4rBvPus4rah9Jsltq9R9polC/w3BaOrs7d4FhjFPo4JvoWEDnWDr/znO0Q0IG6ImuyRqp4uDqgA+dIAFOYFJ3MaUCGR4MYkAGfKzXS5rfsZcOYcEPDQqdZGrVCPcGApkGuoHQ3/mX+69T2VXXUD2WR9r8i54uXbdpcnAiZ+tai6rQmpPKWinEM3rsJYCy8sIGrOvH2DY5LbmxRptUbvvoOQqDDcxapA64TfVH6hjLsurff9TRpVd7386aQoQZ+eXe4+Z+4zYOHkZ92n7aLlbj4NQMjwm8pCKqRc5zcaVFROw3K/M2/IMh3hYcyXuVvy0VwzGa2XRKCgYYLxEp2nBadRrBqIotHyklJxZeV6gYNHW1LnFtNFdhp+Z+5ULnjd3AV9Z6vlOXzE1Z+SQNp/RpzFH2CET7hYdaf/TD+j0wPqIzRF/WNZha+N3ZlCYMjHlVZ7/ePt44NjAx1IyVoxFJPAgOthxGf2kZ42tLzUQCL1FDcVlAh7abqc0vE855fVTT19TOxmIZU9B0xRwS7ufgl+UZi7FAQ==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         
         
         // signature
         signature est SignatureEcdsa
         signature.R.affecteAvecChaineHexa("381d97bbc2cfbe448bf256bdb5ff9cd6fdbe27726ee4d603a4f92fa541fa7518")
         signature.S.affecteAvecChaineHexa("040e51ef10775569752ce8258dd5c382e1a39ae6530ba1044a58bed5f8ca9d55")
         // clé pub
         CléPublique est Point256 //= CrytoLib.DériveCléPubliqueDepuisCléPrivée( ClePrivee )
         CléPublique.x.affecteAvecChaineHexa("5b0ec43c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef87b")
         CléPublique.y.affecteAvecChaineHexa("b809f2a2d4c6423c2f946ff6499dffec78385fd75f97245910c358a4a55cfdb6")
         
         // valeur signée
         N est Entier256("12345678")
         // 1 test a blanc
         bOK est un booléen =  VerifieSignature( N, CléPublique, signature )
         SI pas bOK ALORS
         	Trace("***************** FAILED ****************")
         	RETOUR
         FIN
         	
         //sERR est chaine
         Trace("Calcul...")
         ChronoDébut()
         pour i = 1 a 1000
         	bOK  =  VerifieSignature( N, CléPublique, signature )
         fin
         Trace( "Temps pour 1000 (ms) : " + ChronoFin()  )
         Trace( "Temps/appel     (ms) : " + ChronoFin() /1000.0 )
         
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Compile_formule
    identifier : 0x2e43345c00e29590
    internal_properties : BQAAAAUAAABeTNAFnZ5al0U45GKxBEu9WYwGoOiK0UMtJ7KsxCrisQTJUbpUQi/95FEaDJ+Usd7wO8dRYuic3zi2L9DJx4kwvjE66PNPq4NPUQQvK6tEP7gl4HwePD29VlSTCIc1N1epf1M2wg4aVKMAYYUBSqNgH+LlMJvqUgciPhIisQFL/mWY1lXgUoUPBHpq00Ek+VgFj+e77FaU85Nj5seqk2TDcYXyFAlTY8prDKRMQjTpX1PkcnLj0dD1O8CUtslTyKiP+/TNFpORcSj3lWJw3e26DahMS4/6wFdcpbOpYze2GLCNCS39JaX9rJVzth49A59kus8DHzdzPsvBwK62jDcbiR+QuS8601TCs+EqO11v6LxDDdKS1ers4jqXtB+AzUnTgXX4ZJvT0L4jwma8oMBdKNxaf7oVG+nXo10mASvN9W1GY4npcW1QaA9BxpXo8N+oTM8lsvcsQjV5bmvM229PZc/Y+qiGDo8Z5615kufdUwuO2U4IU1BCnxFRCU4UAtC5+FGPbpmMZDd/n1nPKo0iqrKFSHP+WujfEvScy3Iq6p2/9U2pLnM/MJOn2y1j8pKxkx5QDQPZs6dzXXTIB3onOlozdwbVQKLKjxnraTm0McwJNboQ1u8k3xsF+yVjupBdE2IgmGtftfwI8K85o69taoKMOpLZO7Ss23XdPRzoPffik0MhnegPT4xIOsRZjMhgLJ8KOFHg8qJjoyvcVu80piqmCG0KXZ7phYFbrco=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CPL est un compilateurDeFormule
         CE est CourbeElliptique_secp256k1
         corps est un CorpsModulaire_pointSepc256k1 dynamique <- CE.corps_point_secp256k1
         
         
         //addrB est un entier système = &_B
         
         CPL.déclareParamètre("P1" )
         CPL.déclareParamètre("Res" )
         CPL.déclareOpérateurBinaire("*", corps.addrprocMult256x256Modulo  )
         CPL.déclareOpérateurBinaire("-", corps.addrprocSoustractionModulo )
         _pf est un entier système
         _pf = CPL.compileFormule("X=P1*P1" + RC +"Res=X-P1")
         //_pf = CPL.compileFormule("X=B*B" + RC +"R=X*X")
         trace(_pf)
         _B	est Entier256(3)
         _Resultat	est Entier256
         API( _pf, &_B, &_Resultat) // (3*3)-3 => 6
         trace(_Resultat.VersChaineHexa() )
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Compile_formule_Double_Jacobi
    identifier : 0x2e464ed4009f76b4
    internal_properties : BQAAAAUAAABBiHa++FgB+ia5ihtvnpgdp5XOHgLd/20AOpfQRfH5FaUZekkJC4xi9ZFhO7zPfP5SgyqeRF/kxwEbudKFWxWONkV+AFBXDOqUGUI+VZ1dE1PPY5pjAjiW++0qPHvSZnl2BXqQlHZNO99AlQiy+9V9kWRNlN90PY+ugPsShYZOUvGIMn5M9EieMD5A59cy3RN6CTExPjQ6YYSsnbFoOrPXrQOdjuJn0QPlinmc77MYVd+zcqxUwIq+AEWUrwh0hNFPuyGhnbVGhxjyAYC+BpZ1GzuGWJZjq0FKZBluo0wI3/SKCd4mkSJvqliiVUWJk8tXfdkQDsJIbyUGxyiEeNuorobtXeUWEV5SYl9FoEOzLUhVjgXuttOI/hqt6nFNud41gprJrJGl2VasplEFruTY5u9JvlLdu9S9fOnTnKdDUgd1lqTFN3ODCEwxBcrCrG5kddyusC+Oc2WWRhyTH49wxzpvHTr+dCAdjHWgz8FRGI3lvJW0q6KjcVC13g1IPjfxCcZECk9Gz3cSbxicjumHQm9+JQsGjhMpW/K/FByqYVEUPmLhsMtkdjat5gKDChHfkxSs3Vcr4Ijgn3nnMdL1IpHk3wVU85wF0gp9MGpwTidKClbt2Lx5fJcQwfh6tuufcI5yJQIW8z3/Lu9uBLqxJJIcKM3NykI7E+DdEC6xX9d7vAQnKnMEpV+W9O8/6/fR766UcnyScem921eK3mGMbcOXxZGCcf3lm4AZV9EqWVU+CTrn247VUZXEKJpMtg==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CPL est un compilateurDeFormule
         courbe est CourbeElliptique_secp256k1
         corps est un CorpsModulaire_pointSepc256k1 dynamique <-courbe.corps_point_secp256k1
         
         
         //addrB est un entier système = &_B
         
         CPL.déclareParamètre("X" )
         CPL.déclareParamètre("Y" )
         CPL.déclareParamètre("Z" )
         CPL.déclareOpérateurBinaire("*", corps.addrprocMult256x256Modulo  )
         CPL.déclareOpérateurBinaire(".", corps.addrprocMult256x64Modulo,  compilateurDeFormule.UI8  ) // 64bits x 258 bits
         CPL.déclareOpérateurBinaire("-", corps.addrprocSoustractionModulo )
         _pf est un entier système
         //The "dbl-1998-cmo-2" doubling formulas
         sCodePoint_Doubling_Jacobi est chaine = [
         	XX	  = X*X
         	YY	  = Y*Y
         	ZZ    = Z*Z
         	XYY   = X*YY
         	S	  = 4.XYY
         	2S	  = 2.S
         	M	  = 3.XX 
         	MM    = M*M
         	X     = MM-2S
         	S_X   = S-X
         	YYYY  = YY*YY
         	8YYYY = 8.YYYY
         	MS_X  = M*S_X
         	YZ	  = Y*Z	
         	Y 	  = MS_X-8YYYY
         	Z	  = 2.YZ
         ]
         
         _pf = CPL.compileFormule(sCodePoint_Doubling_Jacobi)
         si _pf =0 ALORS
         	trace("*** ERREUR ***")
         	trace(ErreurInfo())
         	retour
         FIN
         trace(_pf)
         _X	est Entier256(311)
         _Y	est Entier256(747)
         _Z	est Entier256(1)
         P est Point256_3D
         P.x = _X
         P.Y = _Y
         P.z = _Z
         P2 est Point256_3D = courbe.pointDouble_Jacobi(P)
         Trace("X:"+P2.x.VersChaineHexa() )
         Trace("Y:"+P2.y.VersChaineHexa() )
         Trace("Z:"+P2.z.VersChaineHexa() )
         trace("GO : ---------------------------------")
         //_Resultat	est Entier256
         API( _pf, &_X, &_Y,&_Z) // (3*3)-3 => 6
         trace("X:"+_X.VersChaineHexa() )
         trace("Y:"+_Y.VersChaineHexa() )
         trace("Z:"+_Z.VersChaineHexa() )
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Compile_formule_addition_Jacobi
    identifier : 0x2e478d210126d408
    internal_properties : BQAAAAUAAACLAJD/eRDMJTcHWaFTnEezJJs2EcOJ8CDzEI6AnsSDRgQAleO9Yir0aWiPhmukDCsI9nMU3E4G4w8M9be4YmM1RnobntTWzhymDopxOUE0XXAPzGkZSctcjlpiVtvxkshM6V7O0F5fr0x9Hp32ZNgVy8KDgz/KHwuCpA+iAqxBXKsLeWYQ+MOtXnD+DbBwhvKf0S09hnKYIlYtV7XKfgkaG5NDvnCiAXAyXy5byqojjmGon/81L+s5aoxQq8PRvpFPaxrnzSey4SQbkkEnTWkswgiro9LNqahFtOhdAw+marBJVeyh9+UvKWwKp8oHx7rvOgvrbb/EbIWYrQOGaC0BrIIs2zGuRNBYN+MHqIqBamWGx2M0FfayjdwVOuAapO7mi6MzJWVlYjNmjX7lFDg1wIxoYqO5k6naGNj22udj3wka/VB80/2giVJ0jBgatOP+orMk0yFqyIKccRvVHzk1j3GcgdEchH2a4iAXa6Mn2cuOU3FPLRaIBs4OS4F+DI6jmi2ec6GCGl7gmhnEvEeY9rZrKbJKxBrcV0NSYV4C8lcpiQgMWJMXifIcXfJpiHStkPXI7umh82uM8Jj7017UDjrz/VISofmSEnecPPDEi2E1u0JgyJaokyP/vq5u2gS9aQn66mqGGiDRk258ijKa4GExsvLdyskGL7ZDok46nG14cWesiOUbOOt7ZGzIlrYYoxhbNuSv45JAn0ElEKTZXfB3UPb9HL3SBqBFjg+lkYT6mRG3uePr1XohHi6rXzU3oYZx
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CPL est un compilateurDeFormule
         courbe est CourbeElliptique_secp256k1
         corps est un CorpsModulaire_pointSepc256k1 dynamique <-courbe.corps_point_secp256k1
         
         
         //addrB est un entier système = &_B
         
         CPL.déclareParamètre("X1" )
         CPL.déclareParamètre("Y1" )
         CPL.déclareParamètre("Z1" )
         CPL.déclareParamètre("X2" )
         CPL.déclareParamètre("Y2" )
         CPL.déclareParamètre("Z2" )
         CPL.déclareOpérateurBinaire("*", corps.addrprocMult256x256Modulo  )
         CPL.déclareOpérateurBinaire(".", corps.addrprocMult256x64Modulo,  compilateurDeFormule.UI8  ) // 64bits x 258 bits
         CPL.déclareOpérateurBinaire("-", corps.addrprocSoustractionModulo )
         //CPL.déclareOpérateurBinaire("+", corps.addrprocSoustractionModulo )
         _pf est un entier système
         //The "dbl-1998-cmo-2" doubling formulas
         sCodePoint_Doubling_Jacobi est chaine = [
         	Z1Z1  = Z1*Z1<§cs:2§>
         	Z2Z2  = Z2*Z2<§cs:2§>
         	U1    = X1*Z2Z2<§cs:2§>
         	U2    = X2*Z1Z1<§cs:2§>
         //S1 = Y1*Z2*Z2Z2	<§cs:2§>
         	Y1Z2  = Y1*Z2<§cs:2§>
         	S1	  = Y1Z2*Z2Z2<§cs:2§>
         //S2 = Y2*Z1*Z1Z1	<§cs:2§>
         	Y2Z1  = Y2*Z1<§cs:2§>
         	S2	  = Y2Z1*Z1Z1<§cs:2§>
         	H	  = U2-U1<§cs:2§>
         	HH    = H*H<§cs:2§>
         	HHH   = HH*H<§cs:2§>
         	r	  = S2-S1<§cs:2§>
         	V	  = U1*HH<§cs:2§>
         // X' = r^2-HHH-2*V<§cs:2§>
         	rr    = r*r<§cs:2§>
         	2V    = 2.V<§cs:2§>
         	temp  = rr-HHH<§cs:2§>
         	X1    = temp-2V<§cs:2§>
         //	Y' = r*(V-X')-S1*HHH<§cs:2§>
         	V_X   = V-X1<§cs:2§>
         	rV_X  = r*V_X<§cs:2§>
         	S1HHH = S1*HHH<§cs:2§>
         	Y1    = rV_X-S1HHH<§cs:2§>
         //  Z' = Z1*Z2*H<§cs:2§>
         	Z1Z2  = Z1*Z2<§cs:2§>
         	Z1    = Z1Z2*H<§cs:2§>
         ]
         
         _pf = CPL.compileFormule(sCodePoint_Doubling_Jacobi)
         si _pf =0 ALORS
         	trace("*** ERREUR ***")
         	trace(ErreurInfo())
         	retour
         FIN
         trace(_pf)
         
         P1 est Point256_3D
         P2 est Point256_3D
         P3 est Point256_3D
         P1.x.affecteAvecEntierPositif(23)
         P1.y.affecteAvecEntierPositif(7)
         P1.z.affecteAvecEntierPositif(14)
         
         P2.x.affecteAvecEntierPositif(5585)
         P2.y.affecteAvecEntierPositif(222)
         P2.z.affecteAvecEntierPositif(59)
         P3 = courbe.pointPlusPoint_Jacobi(P1,P2)
         Trace("X:"+P3.x.VersChaineHexa() )
         Trace("Y:"+P3.y.VersChaineHexa() )
         Trace("Z:"+P3.z.VersChaineHexa() )
         /// TEST 
         trace("GO : ---------------------------------")
         //_Resultat	est Entier256
         API( _pf, &P1.x, &P1.y, &P1.z,  &P2.x, &P2.y, &P2.z  ) // (3*3)-3 => 6
         Trace("X:"+P1.x.VersChaineHexa() )
         Trace("Y:"+P1.y.VersChaineHexa() )
         Trace("Z:"+P1.z.VersChaineHexa() )
         
         
        type : 18
      -
        type : 161
        enabled : false
 menu :
  name : _Menu
  identifier : 0x292573e513b5f221
  internal_properties : BQAAAAUAAABd4biPtdLQOwfUFiqrit8H4xfGqKyz9t6VLxCUnNZRQiLPVs82PZNE+UVdKRzjizyeuKyRur85gNMUfqplpmtNDnQWQla9zo+GH9+1EfUJ6w17Dn/egD/gv+Hhywk8c9unIdzEp7EHgaAqD28w7Agveg4u19PBcKGZtQ==
  options : []
 languages :
  - fr-FR
 popup_menus : []
 message_bar :
  internal_properties : BQAAAAUAAABqPQh6HC8RxAVkp2SqPYLuZrfVhd+1KX4lx22hIT8uqEpE6yP7Sbc2rmVqdmL816EWzXOkEe9ijOtYwchZKAfpy3B1cNqhpJgsnbUs
 code_elements :
  internal_properties : BQAAAAUAAABWIHrh1Yb2YcVvIfiiRDSu3aXMOSCmrRDPwCP2jtbUBEGFOv+qg2ayVXoCZujUnWzZv/mop+WO+JtZ1Q==
  type_code : 1
  p_codes :
   -
     code : |1+
      PROCEDURE MaFenêtre()
   -
     code : |1+
      
      
     type : 34
   -
     code : |1+
      
      
     type : 2
   -
     code : |1+
      
      
     type : 40
   -
     code : |1+
      
      
     type : 234
   -
     code : |1+
      
      
     type : 165
   -
     code : |1+
      
      
     type : 177
   -
     code : |1+
      
      
     type : 180
   -
     type : 230
     enabled : false
  procedures :
   -
     name : PGCD_Ex
     procedure_id : 1994461367820771349
     type_code : 14
     code : |1+
      
      PROCEDURE PGCD_Ex( nA entier, nB entier)
      
      dbgAssertion(nB > nA )
      
      r, u, v   sont des entiers
      r_,u_,v_ sont des entiers
      //reste est un entier
      quotient est entier 
      
      // init
      r  = nA 
      r_ = nB
      u  = 1
      v  = 0
      u_ = 0
      v_ = 1
      
      tantque r_ <> 0
          quotient =  r / r_
          
          // sauver les valeur précédentes
          rTemp,uTemp,vTemp sont des entiers
          rTemp = r;
          uTemp = u;
          vTemp = v;
          
          r =r_
          u =u_
          v =v_ 
          
          // calcul du reste
      	r_ 	 =  rTemp- r_*quotient
      	dbgAssertion(r_>=0)
       	u_Avant est entier = u_
       	v_Avant est entier = v_
      	u_ = uTemp - quotient * u_
      	v_ = vTemp - quotient * v_
      	//trace( complete(u_+"",4," ") + " = " + Complète(uTemp+"",4," ") + "- " + quotient + " * " + u_Avant )
      	trace( complete(r_+"",4," ") + " = " + Complète(uTemp+"",4," ") + " + " + quotient + " * " + u_Avant )
      fin
      
     type : 458752
   -
     name : PGCD_ExR
     procedure_id : 1994470541871085041
     type_code : 14
     code : |1+
      // version résursive
      PROCEDURE PGCD_ExR( nA entier, nB entier, u=1, u_ =0 )
      
      //dbgAssertion(nB > nA )
      
      r   sont des entiers
      r_  sont des entiers
      //reste est un entier
      quotient est entier 
      
      // init
      r  = nA 
      r_ = nB
      
      
      si  r_ = 0 ALORS
      	renvoyer ( r, r_ ,  u, u_) 
      
      FIN
      
          quotient =  r / r_
          
          // sauver les valeur précédentes
          rTemp,uTemp sont des entiers
          rTemp = r;
          uTemp = u;
          r	  = r_
          u     = u_
          
          // calcul du reste
      	r_ 	 =  rTemp- r_*quotient
      	dbgAssertion(r_>=0)
       	uPourTrace est entier = u_
      	u_ = uTemp - quotient * u_
      	trace( complete(u_+"",4," ") + " = " + Complète(uTemp+"",4," ") + "- " + quotient + " * " +uPourTrace )
      	// récursion
      	( r, r_ ,  u, u_) = PGCD_ExR( r, r_,u,u_)
      	
      renvoyer  ( r, r_ ,  u, u_)
      
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BQAAAAUAAAAwjDLmDSZ0H1P68nJIeNfqR9EvRjU/K+sVcM1T6rhVNr+VTV1mZ/rmoweYbFDZUhBGcv8UsxlDxVCOnb2U/SQOvlGWzNby3/w/V+ppSymxv+Vh
  original_name : Modele1
resources :
 string_res :
  identifier : 0x1b7cfed701529005
  internal_properties : BQAAAAUAAAAa2Zm8J9E/zh+/WIrVvz1fER/So3PB0gjQuxc1xKQVWY4ZDm5lfg==
custom_note :
 internal_properties : BQAAAAUAAAC68/W0/adbG0nFCRhrE42B5HRnbDzVHaz86sSQyxlBk7I=
rad :
 internal_properties : BQAAAAUAAABoAN7PLpwJW3EiA7WVZdCA5EwrCA1rvutcDHooMWKe
