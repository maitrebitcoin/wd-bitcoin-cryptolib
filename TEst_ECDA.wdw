#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : TEst_ECDA
 major_version : 25
 minor_version : 0
 type : 2
 description : ""
 subtype : 0
window :
 name : TEst_ECDA
 identifier : 0x2b7cfedd00d3a562
 internal_properties : BQAAAAUAAACxHeUIxbZNvvEi196KSYVfgKITg89gyzCvyEIeuuHEH0c1FyBDd7UCXGpUHONBGjWYzNq138gyr2XMYBQH/jCbSb8o08CtbXdmFdbYRb9d39KxuXAGlophEQPGa5Ee/xqqzY08bFXeq50NsCK4yMQMDhpoDFep2crWxtTV4d62rxxmFD3XWU+I5ksQWjS1cWtQawRqmx0aU2tlT/TdULG5ECWCIcf4v99Wcgn13Gtgw1mtluYC42LmfFSwdzud/z7zHGgfKKQbuc2dx0fMr/moPNRj1GmUXDEXaya98fq7OBdOEV9jQPcLkrCnrYmvHbMkJFod5Nh+19tMyiW5e5SYQ6M4nuYk/4cOvrduQk6gFQ97udkAWTQdc9/foDhyGa77HOiRG7QOdvmKYdVi4tIqSlFrzYBIruf0j85FzXUtQwF2RRAEPqQvd+gdoaEquvJQ+uih7XX8s1JKU0yX641bM9eZnuo8fRjoxHWoJPZnZNzNS1Xzc+4gvGEDuuli/sharV8pTQ8yRqyFaHcGJ13zoQeItBRFQ1vDT3j93/uBa7vPELknYBa6FZwt7V4dJ0De25XgVuMBGkaQ0eAiyO6IDL95BVqBaSyTfdJ0yGSDkiw5HPLBH8aosMc2PsYG+/Pz9Pje3oK+2MWAoTJ+bLkLjnMzPnBEpS02nC+pCi6cdQlxevZXx+exobtWrFyE9sohTsytDmQLSydH/jM3SnN1a/Qwg5aWgvfAZXRE3mBFDrSO+naaRlr0C677WwUZUkAGlKWYwq3MCN5UlaeYIoqgRDIBA0857UXLe9loERkGmjTGWSA8d/RSidr6D4shQKIgwfBhQ4SYsj2Qa3Q=
 controls :
  -
    name : priv_pub
    identifier : 0x2b7cfee80119d106
    internal_properties : BQAAAAUAAADeD20Mji88oAvMx4zZDrf92knbeB5Sz5zei57L1PwCKtuZRLLf2BUK+8euY6nvGlDpIQQNwT4fUOyC3lv1mtHndganxbNl35OAiY2LgQefxPIj8Dqtunya/nHO0ao3sN1L7MYofQemm+Qb3jccLrG4HmxbgvwlvIZn7Ee5ZRQZ3nWrGlJMYXPkPzdhv7OOK71SmIvUnG4ST1T2IqYZxEHprvRlMwCaW7cbIfNf5okb2KGipVObLD05uBTtUySabhkajP90nXk3K9xU2OTJRSADGrmWIRhpLtuxy3mdaOXK1R+Y/tHYRBq1SrcfIBw06AVXNf+mMGeEcoaS7FCtLqkpMbIsNFLt5pyZUHY1mKPA20/+3NiI17lKShfkd91l+kFXrmCG9OZzES495vtrD45f3bpvF2HIE/57tTWxro617TZ4AmnYDsGFvi9Hk4TrZCNRpFax1STYUU/VhGp1EnmVxP134ukrCCa/z5dSPV7rnS64GPzl0EATCQF3wn2nxAYEXAhFTQhYk2OlE+DAXQcoh27w+l6HZNsRCCzLNc/iA9kisQyZVhZ580wCseH918Xp49OAA0m7Bs1BYwAaDc9qoG6UVR3ssL18K908HFLGd1/LouTJ+YN5772BCLnCQVeByGb7/tatm0m+qqF/TL72VVHHzGMjK3Oeo2BF9Uy9Uo032NgsSQ9Rc5madBmy3xzZu9eezCqsn1KZVofiLnyU1txmfk99ZxbLLrNuSxDoh5mu3ONUkeFMb86IyFZ7jqLVfp6ygYt1sCDPVw==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         gbModeBench = vrai
         CrytoLib est ECDSA_BTC
         //ClePrivee est Entier256("75be5c76cde3bcb877a523f618c839cb6ac58269880288734acee9473a180744")
         ClePrivee est Entier256("8727b3b7be9139498f2f48f7b88f92203b1ce5ea527fd7dd754F650e2216b935")
         //CléPrivée est Entier256("2")
         
         Trace("Calcul...")
         ChronoDébut()
         ClePublique est Point256 = CrytoLib.DériveCléPubliqueDepuisCléPrivée(ClePrivee)
         Trace( "Temps (ms) : " + ChronoFin())
         Trace(ClePublique.x.VersChaineHexa())
         Trace(ClePublique.y.VersChaineHexa())
         
         // 5b0ec43c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef87b
         xOK est Entier256("0x5b0ec43c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef87b")
         //xOK est Entier256("0xFD0F6EBE95AAFBED3C431047BB3D9DEA4324B8D6CDBC16D35AE30AC22E9548")
         yOK est Entier256("0xb809f2a2d4c6423c2f946ff6499dffec78385fd75f97245910c358a4a55cfdb6")
         
         
         
         dbgAssertion(ClePublique.x.estEgalA( xOK) )
         dbgAssertion(ClePublique.y.estEgalA( yOK) )
         // b809f2a2d4c6423c2f946ff6499dffec78385fd75f97245910c358a4a55cfdb6
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : FIn1
    identifier : 0x2b8390ec00c21e47
    internal_properties : BQAAAAUAAACP97Axbk02UnDsH+R8rEUyMmQdU26ZRGS9ndVqRcZp4VWE/snY0i3pyxS00J5duC393tQw5rqZcTq37jjyfhX4jFM6vbl0hidvXPf2qJ78VCoEY/j7cl+G6EQxwfPsMAIO1ZM1cWH66hFkag08bcRcVzlVRIpyHvfpAq/y+PyVmtMiF0p8yXN4s2vRcscD+Lh1VE3Ly8p87a+fDNr+3MbpTXAH68RaCg+1E2XiSucF00C+vYQ8sWkcY+5/1/x8gEnb9mZuL+5LdJJFXraP98j1yRfsCq5gv0lUeXeQQ82b44ytKFANlfXED3XrrM21nBuoS0OXwvU1wIwXjQSqHfw9kSnSr85Zc3O9s8h3kF+2wG5u0rGFHEL0cWRxYXrFr7KFeXzi43TRKgm5GKt3w77cdhgpN+U4b1mMJaHnuFRT9DV4TJVAxlWsw2Vju8ALWFIsSvI/r85y5CQlbgIhGhVucSXVDC85TmMqC2fIF6A9mzUuVFRxAFSK9n3ldENP4K+tfmyZzU7WqoxpXb4yFzE5WCri9k4lOtQIis1A/9cm8WVzQMXOz2GRdeWvDpqQHzO1ivJzNivFy5VJkxMBmtQLTFxORh2+4ky2F5DH8rk2SE7qlJOBEHgPDdF5UM0b0aiORI8RPluJOALC4OvZmyaRK8qh/rlVaoQ5dekpwpih0KqhAIvpfj8K+Qi4HUZ9iH9R5JqSyNWLnOQ2aXadv4xEpXiE
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         ferme()
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Test_P_P
    identifier : 0x2b8a9bb300c5193a
    internal_properties : BQAAAAUAAABhoF4POIXoM/XANBelwCJMKOiIeR40kTDxjjoavHgihxeKlWM7jNkSKGpfA0f79w+BWPV+eTKl+qXdNy+njloSZNM1/Jcy036QAhu/12QLD/ku+Ay+bICgFL8nBsl3QkC9W1xT4sq98UBqD9ZFMCtb2Jxg3O6VW0WtHAet8pExzH+oy33OsL/UUtgcKqCdJ5Wc93AsyU2LwnZqNQdk3TbzsJeLeXxMA0OXucmYmCjg+FsLMxzZeIbl7w5bkpnS19yTr/Q3icnTNPctZ9R+MVS1sOFUV2ADgQDRaB3nnQUN7Fi32k2b1/RuQat2IAXeHO0CtovCD0xayoiGEmbtXcZXMqy7thq5Y6uwUMylp+W8XX/s5SZ4GMAFQQmkx9yibbx29IUuFCIRTTN4YzVtDr4sY5eOiRLGs8jcSLRnpK8jkIoTw4ffpLVbrwb8i4wUokQXc4EJVmrEZ1qey7bZsTG+kvTGpnT1iIzyoJgmWQs/ZgY5DWRuEtxlWvwELkHIVM1wN4VFFhoMwY721FT84gldr39Jmp+B3IfGr6Qsb6eNnlXpvNSgYGqnZLeBoaEgu6rVpQ6s3DkligbC0KmJgZocZU3TcSqK0L0P5BRwGAdAFscMQyaseXn3akZanuZkOmlEmnOF0CRl/17PQ61pUiJhQhjRhUPnQSenjj2OLedz4nQ1oBTwgPyoAGpQ0Vkd1pWa03tXcSFfDjEzPzWztoDKtYRxz6HIUOE=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1-
         CrytoLib est ECDSA_BTC
         corps est CorpsModulaire <- CrytoLib.corpsECC
         
          _1 est un entier256(1)
          
         X   est Fraction256(3) // 0
         Y   est Fraction256(4) // 0
         X.numérateur   = corps.X_to_monX( X.numérateur  )
         Y.numérateur   = corps.X_to_monX( Y.numérateur  )
         X.dénominateur = corps.X_to_monX( _1 )
         Y.dénominateur = corps.X_to_monX( _1 )
         
         moinsX est Fraction256 = corps.négationFractionModulo_mon( X )
         Z est Fraction256 = corps.multiplicationFractionModulo_mon( X, moinsX)
         
         trace(Z.numérateur.VersChaineHexa())
         trace(Z.dénominateur.VersChaineHexa())
         Z.numérateur   = corps.monX_to_X( Z.numérateur )
         Z.dénominateur = corps.monX_to_X( Z.dénominateur )
         trace("--")
         Trace(Z.numérateur.VersChaineHexa())
         Trace(Z.dénominateur.VersChaineHexa())
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Test_mon
    identifier : 0x2b8aa07700c7b785
    internal_properties : BQAAAAUAAABKDD3ZnPIl1dplERPm4gi7bsPg34ZeG6kbYJd1aO84/UZQqUzqnINZQLuNeJfraRlphD8tLpv1cfMPxklad10vjQOoXK7+3zm6E3YQf73vbBWQcKPnek5FFckqPPPJiYPgeBq+K4YYZJPLPVkK5cUWwtYObgPcRgWTxmj/+qepXj7TjFvQsx7wLYzrWcowHT18dfCsJf2VJrvXm0uQmkMLB/TJZtefacG29r99fj1FIJr0pmtfGW10Kugwy1tbsbZ0sMwXXKsLG+aNSizKlQstmULIJMknzruBHBQx7HG0OItOINUI2DFjqFzIhDoHgto+3Ilw/OvjBbT5CRbQPrnva5yQAxW8sy4o90NP4aPsumz5t6h4dtvi9b4CFZgJRP+IoZXJ/jIYagtDGXOlK1OTF8roQsRiXAGCcTI1ZBSSQ7J++5IBLHDee4/gA9JPD9XRCKOccGJ3QJqdYRypArzZOoEaP0Y9o61KO5ga15hgyTjcb6X2lEvqZIk6/F2jRdrOTv+A0L5zwkb7dJhSdzAkzVwPgV3Fc3SqSgsxQoFziGpbyXrX2z7Vi786LE6kcyJSk5Zpno2Bbh9s574GwyTu8D9olyf3RhtSasWjyeMGXiJ+Ytxhiu/TIk32NrDVa75IS4ms1qHwoxHvYD2M9ISTZfOFigm3oahLs5xD+vWXH6oBO97TrxxPo8GUzqs6EncyLCt7Tj/Aude4waDrrEyuyg45kUQETw==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1-
         CrytoLib est ECDSA_BTC
         corps est CorpsModulaire <- CrytoLib.corpsECC
         
          //_1 est un entier256(1)
          
         X   est Fraction256(12) // 0
         Y   est Fraction256(2) // 0
         mon_X est Fraction256 = corps.X_to_monX( X  )
         mon_Y est Fraction256 = corps.X_to_monX( Y  )
         
         //Z est Fraction256 = corps.multiplicationFractionModulo_mon( X, Y)
         mon_demiX est Fraction256 = corps.divisionFractionModulo_mon( mon_X, mon_Y)
         //mon_demiX.affecteAvecChaineHexa("6")
         mon_demiX =  corps.X_to_monX( mon_demiX  )
         trace(mon_demiX.VersChaineTrace_DBG())
         demiX est Fraction256 = corps.monX_to_X( mon_demiX )
         Trace(demiX.VersChaineTrace_DBG())
         
         mon_36 est Fraction256 = corps.multiplicationFractionModulo_mon( mon_demiX, mon_demiX )
         Trace( corps.monX_to_X(mon_36). VersEntier256(corps).VersChaineHexa())
         
         mon_18 est Fraction256 = corps.additionFractionModulo_mon( mon_X, mon_demiX )
         Trace(mon_18.VersChaineTrace_DBG())
         Trace(mon_18.VersEntier256(corps).VersChaineHexa())
         
         mon_12 est Fraction256 = corps.soustractionFractionModulo_mon( mon_18, mon_demiX )
         Trace(mon_12.VersChaineTrace_DBG())
         Trace(mon_12.VersEntier256(corps).VersChaineHexa())
         mon_12 = corps.soustractionFractionModulo_mon( mon_12, mon_demiX )
         Trace(mon_12.VersChaineTrace_DBG())
         Trace(mon_12.VersEntier256(corps).VersChaineHexa())
         
         //demiX_horsmon est Fraction256 = corps.monX_to_X( demiX )
         //Trace(demiX_horsmon.VersChaineTrace_DBG())
         //trace(demiX_horsmon.VersEntier256(corps).VersChaineHexa())
         //trace(demiX.VersEntier256(corps).VersChaineHexa())
         //moinsDemiX est Fraction256 = corps.négationFractionModulo_mon( moinsDemiX )
         //Z est Fraction256 = corps.additionFractionModulo_mon( X, demiX) OK
         //monZ est Fraction256 = corps.multiplicationFractionModulo_mon( demiX, demiX)
         //Z est Fraction256 = corps.monX_to_X(monZ)
         //Trace(Z.VersChaineTrace_DBG())
         //Zi est Entier256 = Z.VersEntier256(corps)
         //Trace(Zi.VersChaineHexa())
         ////Trace(Z.VersEntier256().versChaineHexa())
         //
         ////trace(Z.numérateur.VersChaineHexa())
         ////trace(Z.dénominateur.VersChaineHexa())
         //
         //Z.numérateur   = corps.monX_to_X( Z.numérateur   )
         //Z.dénominateur = corps.monX_to_X( Z.dénominateur )
         //trace("--")
         //Trace(Z.VersChaineTrace_DBG())
         //Z2 est Entier256 = Z.VersEntier256(corps)
         //Trace(Z2.VersChaineHexa())
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_Mul_64
    identifier : 0x2b8e1e360145dde5
    internal_properties : BQAAAAUAAAATpz8gn3yU0+0eHI+xiqGC72bJuFcNFlJmq3p+PLlhBhYxt9OThIMpjg663BTOI1SUi5cuURf1QCscRl7g0nd6qLVZhyrr5WAP40OAl5aHJQ0a/5fBdDXXe5ZAm81l0OJk/4v6gyqDj+8t//HpPybJau/B4Gcx8Cbcr5UmByK+igdLXZiXmBOkBnNorP8w6VlEgpo+E/HNcqQBmUuIMiMxqpxEtzvNkjRhP3ecv+AGG3W6/G+hiWnKdP56b7L4qBJUX5wRneNiL0WTs+1mWnkGBw9ROxHG0y9QXK/FiO/lzk79r091OSZ1FX1WfXkw1C3xLNbnv2uaS641L1FHhK+c+V/nVK9Si8JtBJbOL9/zaZBG4MWIqBxecuasHoDcc9/UGDFjEaUF7oK7xzwfPkQN/ePm9t2bQ42NRVhIrt+/h9qRszwsf38GLAfGUMxyfA/niX/uZ6G87knBxzG5H5tXzBjUL2kQ0BV5q7K3sxfVb7KjSSc51/ieVeMOdZd8UHYe181u7ZMskO059A+aoh+EAbcvHwCYtF5H+OARQp5IqEZoMcpiJrXllPN4AzhX3tLepw/fUB1qCpC7Socps9CmqG7ww/VHaa8hu6PNTfGJ/lA4yImOnJsApbgAF+dBtWWV1ezyGjYc7Dx1TnSDpogwnvC/fhjqIEevit2m658h2HX+7M1t0tskds+g/fZKs0U6+A6KwHphWUlmxdT6uRpKbADVKvPDuE7r+sXS
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         PROCÉDURE interne _multiplication64x64_128( nombreA entier sans signe SUR 8 octet, nombreB Entier sans signe sur 8 octet  ) : Entier256
         
         	//@TEST
         	Résultat  est Entier256 
         	nA est un numérique   (38,0) = nombreA
         	nB est un numérique   (38,0) = nombreB
         	n64 est un numérique  (38,0) = 0x100000000
         	n64 = n64 * n64
         	nAB est un numérique  (38,0)  = nA
         	nAB = nAB *  nombreB
         	sRes est chaine =  NumériqueVersChaîne(nAB,"32X")
         	nMax64 est un entier sur 8 octets sans signe  = 0xFFFFFFFFFFFFFFFF
         	nMax64_num est un numérique (38,0) = nMax64
         	//buf est un buffer sur 16
         	Transfert(&Résultat.val0,&nAB,8)
         	Transfert(&Résultat.val1,&nAB+8,8)
         	//Résultat.val0 =  ETBinaire(nMax64, nAB ) //arithmetique._2_Puissance64) //, 	arithmetique._2_Puissance64 )
         	dbgAssertion( Résultat.val0 = HexaVersEntier(droite(sRes,16)) )
         	//si taille(sRes)>16 alors
         	dbgAssertion( Résultat.val1 = HexaVersEntier(gauche(sRes,Taille(sRes)- 16) ))
         	//fin
         
         	renvoyer Résultat //(Résultat.val0, Résultat.val1)
         fin
         
         //_VerifieAMultB(  0xE6B52D16CF375361,  0xE6B52D16CF375361, "0xcfea0d3dc68974efebb6f377ccd60ac1")	
         //_VerifieAMultB(  0xFFFFFFFFFFFFFFFF,  0xFFFFFFFFFFFFFFFF, "0xfffffffffffffffe0000000000000001")	  
         V1 est un entier sur 8 octets sans signe = 1 //0xFFFFFFFFFFFFFFFF   //0xE6B52D16CF375361
         V2 est un entier sur 8 octets sans signe = 0xFFFFFFFFFFFFFFFE // 0xFFFFFFFFFFFFFFFF 
         
         ResOK est Entier256(  "0xcfea0d3dc68974efebb6f377ccd60ac1" )
         //ResOK est Entier256(  "0xfffffffffffffffe0000000000000001" )
         Res  est Entier256 = _multiplication64x64_128( V1, V2 )
         trace(Res.VersChaineHexa())
         trace(ResOK.VersChaineHexa())
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Génration_Table_Point_2_N_mon
    identifier : 0x2b8f620400c6b0a3
    internal_properties : BQAAAAUAAABu5FodbMw+chdOdelLo0nCbjSZ3lKyvs97qHvQzBW8tsH1L1rNLp+5iil5cQjckOq1xd6D4FTH6fJ67EiVCqDy0NrO2Widgc8NrxjUxXhsvQ5rEePgQ686zfx8UeQjhGTg4MJUPa58eQGrmOIPs+M+UIgXbSkBALuralwx8l6QIr/S6heHPqWLSVV4/puLrHe18zd90hbReBhj1ygq5pKwqLPxdRgAzjFe+bBnNhSLIltUHdDJkrXla8DVjjXWi8mJpEIcKXL57qnDK2qDBY2njVz7X226fQ1IR9Kmdxiuq9t3SrCSaOw1MZWZtBLItICYbSHotQ6XRV4HXu6oJdsYfPhK1bVXaPu0jGqMdl7DJw/ST67RAyEHrTwGkTtfljLIzwBDTx+65xlLZDw12GSVg37xthdh6pSUQa2uvBHRPTIeXjxoO1Tr2wn5nq4gFv1rEDKYk4U39dJRGGnl45HBiBs3BWEYC2ACbZlt9eXDkfZeUk873UPpcqeVXfX+lKLgOKrQW2U7ExADPykqYiESVSjWTaouPROwTk19lP+PQtLtMIDMvKB8bwXrIe9Q1am+BgI4OHe9cZOTp9vvvRQ6PndnoeETsO7y3yTnObUPOLx9LXFyGNRgfr4UbrZy2/NR0rQGzupJFASkDhWbjDEng52aRGb9N/rCiJKy50fEXnJIWi+mMnzOYryycpyMvvo3WXHhqoQsPMRFlpt7lqhZbFAMXMCPXULKX/dBckd1TTcatvHjvfg0EQMxMG/Yrccb3w==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         CrytoLib est ECDSA_BTC
         corps est CorpsModulaire dynamique <- CrytoLib.corpsECC
         ecc   est CourbeElliptique_secp256k1 dynamique <- CrytoLib.courbeBtc
         
         //GN est PointFraction256 //= CrytoLib.courbeBtc.pointGen
         //_1 est Entier256
         //_1.affecteAvecEntierPositif(1)
         //mon_résultat   est PointFraction256 // 0
         //mon_résultat.x.dénominateur = corps.X_to_monX( _1 )
         //mon_résultat.y.dénominateur = corps.X_to_monX( _1 )
         POUR i = 0 a 255
         	valeurKPow2I   est PointFraction256  =  ecc.TabPointPow2PreCalculé[i+1]
         	// vers mon 
         	mon_résultatvaleurKPow2I   est PointFraction256 
         	mon_résultatvaleurKPow2I.x   = corps.X_to_monX( valeurKPow2I.x )
         	mon_résultatvaleurKPow2I.y   = corps.X_to_monX( valeurKPow2I.y )
         
         	trace("  " + mon_résultatvaleurKPow2I.x.VersEntier256(corps).VersChaineHexa() + " " +	
         		  	     mon_résultatvaleurKPow2I.y.VersEntier256(corps).VersChaineHexa())		
         	Multitâche(-1)
         FIN
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : ECDSA_SigneNombre
    identifier : 0x2b9198d600a6d698
    internal_properties : BQAAAAUAAABNBOhNcjCBwLZquIQ5QqnYwVfzaOy8iGYz3sI9pf7cR7fQ4QVPaXNwSGiyE6MgBjcNy0XsyRnVOFnFJx4oxoA/10DDLDCZ0ZyZLVFiEdd1nTat8493zkZp9kHC6m4QZIUTjR8U9Y5HSBIOp/cBz+CZJIVJccOavPEGEe8DSomjOMoCasZC2Fz6JroyC+Kgb/Aosrfvhka5RPtc+5ksQS050gqlX4umbKfAebI/f65Jhbu6VNWAkdZPqbf5HawGEjQotIVOIYuMInCgAwNEU6p19+sZ9WU1uru5Nb47z7H7tifVKPqK/FFIwpSaV6gjqFqfeWQwYonZccPlZiy6yx58eYilmA7xpyeoN/7D3Jl69MGeTfH2uXRng1qmVoALUHIoErHuvY5i/d/4gnBrIQMOj7coI5MexLw8BCFcnKgMCl5jq3v8Ppxlv/o/JgR/udLtbWO7hTSvI35GVqW1qDDq8H7CzoPTV3rW4PljGXxM6HxLcQxfKEMbFIq/iQEvL1fO+V8/yWhRl7rO+/PAJU79q0cnAAZz/2uS/zbUpmgWuwbdkHS3MDenHJNKQufbZqLjej4gHduLQXYZ+N+ufZrkJCwWaYdwDUlf0TkDbXo2ffc/Xj5F8LTaMlBhCSlWskiDfGIPvzygG8YjYu+KBlCw4+pxjSNZJRi4KyjO1D/5MYI8ll4RxlKe+FlAdPCdeg1GjObIak0d+ReFJJiA4gW4IqXIWbpLnnMZ667CLsPC7ImkwyW4Jw==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         CrytoLib est ECDSA_BTC
         ClePrivee est Entier256("8727b3b7be9139498f2f48f7b88f92203b1ce5ea527fd7dd754F650e2216b935")
         N est Entier256("12345678")
         
         Trace("Calcul...")
         ChronoDébut()
         signature est SignatureEcdsa
         signature= CrytoLib.SigneNombre( N, ClePrivee)
         Trace( "Temps (ms) : " + ChronoFin())
         trace("Signature : ")
         Trace(signature.R.VersChaineHexa())
         Trace(signature.S.VersChaineHexa())
         retour
         
         CléPublique est Point256 = CrytoLib.DériveCléPubliqueDepuisCléPrivée( ClePrivee )
         sERR est chaine
         bOK est un booléen =  CrytoLib.VerifieSignature( N, CléPublique, signature, sERR )
         trace("Vérif signature :" )
         Trace(bOK)
         Trace(sERR)
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_Mul_65
    identifier : 0x2b9a01bd00828070
    internal_properties : BQAAAAUAAABFMRBYpJHuU/jkwHRmFuQc4Fm6Owg807wJOAQD6DZu1SFBeznherG1r33RCJaK39UtfkME9fOVYlvryTdnlHovQiDJj5iv+1bdz7C20Weu1WOAteSgWFLQUT5qJZhu5tA9/4AP+95ocsMEDnRg+lnDs75GdQvO24ntmFmKM8tYF/rP9488lsXD6OsaY0svY+8yHrz6xwMOzmxdeAIDHPD2dBdOMU/t9FfPD4SdrlE8X6Z7t7L2lTqle1yX1qe50jopD6NbkXn70zgf6vjbsnn/MnZWaXeTSpbCuaHV728hzPziaINN6Ql9FUIAlt0FuDrvcCGeRo7C1UHaFg0Os26b38XDj2mwNWky53sKnkQfS6adbgbZoAiRnycoOwUW59nGlu1OgTsDmX1Npvxv3lBBZRR7vBM1th4moMSf0OFvDQoURAeXFOtnH2u63ekM8TewQ0rKOrTcNPIyhUbaPk6HPsZoupDupOgq5UWdJIcNu1dHSQiBl/spMUXsxECDg7ja6Fu9eS2T5KSxY2U80WCkJKmb5+FqFq2x7//rpDqkfXOEwuDo23hgZvqVaaEvVVQS/8hK3KwYjjzrukYy8lZokhUj0PpUPGHoMN8hh9utYxfGwNCpZa3SkHTceEEiWVEjA2s/80VNGR8FQRjCeirCEX4dUeWD9DXR2Qs+5aFx0WWu3Cxl5pbwltbXR1iEdrpsLYPSdLYVj/KQ7DIwcpy+nCqZdM62R5W5xW1Thgq9FjjM
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         
         //_VerifieAMultB(  0xE6B52D16CF375361,  0xE6B52D16CF375361, "0xcfea0d3dc68974efebb6f377ccd60ac1")	
         //_VerifieAMultB(  0xFFFFFFFFFFFFFFFF,  0xFFFFFFFFFFFFFFFF, "0xfffffffffffffffe0000000000000001")	  
         V1 est Entier256( "0xFFFFFFFFFFFFFFFFFFFFFFFFFF" )
         V2 est  Entier256 ( "0xFAEAAC7C6663B93D3D6A0D489E" )
         
         ResOK est Entier256(  "0xfaeaac7c6663b93d3d6a0d489d05155383999c46c2c295f2b762" )
         //ResOK est Entier256(  "0xfffffffffffffffe0000000000000001" )
         Res  est Entier256 = multiplication128x128_256( V1, V2 )
         trace(Res.VersChaineHexa())
         trace(ResOK.VersChaineHexa())
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEst_Div
    identifier : 0x2b9d499901f6ea31
    internal_properties : BQAAAAUAAADgJ9PuUSybxIgz6YzaT+/psQERkmtRkjP6Fx65iU93TNz4pFES4YdprceIeDx2NgCC5cSFOPGoCcJCqPxs7W07iXTwFGGlm99UjwhpjISA4lWx1R56VNQpqxEJnRLimQKfqVX/iiznr3paIV9Cx+VV1t7u1wh5TnBx93gnwbunqoiOO+mrpcW83A0E4FWI3N5odtPO1QuKgifgwUZZfAIU2XrQFaVTmkAs7s1swMAprIuTT/mDi34kaCtKi7vCp8PE+BNTGF/56LnfrY4VdpIhEVpBU1+bJ2doU90XDsXvSduQK8C9nw2I24BjWqXw8RNKzMsbJPO/Qs4R97frQp6TOEroGq+7edmrl5Ok52o4Mr4KO7W6b92Rkpekw/BxG2YvJ7XSQzGbcuZbtuwMd09BGj75/i+ZFPfBbDrRLb3C47WtYcRs727DBzZXf5P6Fu9+HUnvw6O/dbfLB/B+whgLOQxNRc3fJ2GzYe62eWlmk1e6Jkv3zVFu8cK21hlYrUl66YHojoLMPLEogKjYyoBjuah0qITOs+CsXx2EP4/3/j21oy0VZo22uYYoJJhEvltVKPR+Y4pw9fFw0uiTkzAXCGZ40A6Gx05UCi/UFykj5T6krrD8pJ7klblnA1wWEnrryJPYAJw5KerbZUNnIHI7+kg3Hz9D0QUHLlvoF9GvuNCKezEwIJ8t5e9V1DRi85SX0AzGAILO7zaYpIgWMw1VPhWSvrBH0WA=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         
         	PROCÉDURE INTERNE _VerifieAdivB( AFormaHexA est chaine, BFormaHexa est une chaîne, QuotientFormaHexa est chaine, ResteFormaHexa est chaine)
         	nombreA est Entier256(AFormaHexA)
         	nombreB est Entier256(BFormaHexa)
         	Q_Etalon est Entier256(QuotientFormaHexa)
         	R_Etalon est Entier256(ResteFormaHexa)
         	Q,R sont Entier256
         	(Q,R )  = divisionEuclidienne256( nombreA, nombreB )
         	SI PAS Q.estEgalA(Q_Etalon) ALORS
         		trace(Faux, Q.VersChaineHexa() + RC + Q_Etalon.VersChaineHexa() )
         	FIN
         	SI PAS R.estEgalA(R_Etalon) ALORS
         		Trace(Faux, R.VersChaineHexa() + RC + R_Etalon.VersChaineHexa() )
         	FIN
         	FIN  
         
         
         _VerifieAdivB("0x23456788fffdcba9877", "0xFFFFFFFFFFF", "0x23456789", "0" )  
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : PGFD
    identifier : 0x2b9d55b302462d21
    internal_properties : BQAAAAUAAAB5OVREvDSAlkZeksoiV9ahKFQA/JyAEmhR6ecGXAYaG1y1CwEu4+jmMBYQuXXewRlzZU+mKAdYzI+cSyriAqWLhZieySmvWplcmvkRS75alk7QzNE9DYfLGqk8yOYGkvJMHZba7KFL4R8DMmkUVu5vrWrRMgbgTv+JAJt2ESOTLQlYiE0TkzDWzvFtsGXOyqR6Zedkc/YiKTXTVdLYLmfh3mOJBDtfEi4HnjtfV1zoba9r3bgyVeY+mxqSwlBFOBYRdv9JpiFiIayPceDt9AFFWl2hcaJqWzqw44cGIG6i0fprLk/oYp+RB5MIBR2BnoC5LkhgohM6i4f1l00GImsD4RvqXYVR/6Y7nCxhHBtRZFivPDfRiLqjDr6V0rRHvaOdJARDhCjWJkywAx9Oz2FAKmeGIc7SkXOjKxU+LQtiPBe00oNXvCPRM936lD/cLEjiKIYC5MJ+S4eqTml2ND7OoQ8kPoaGQh0XfunznZ86/iddayboRAhM2duhIwma6wRyEJJny90TsOVJUZ+UjFayvenZU5OvxBImjnpoyFDG3Hzxn2G7OJ11MFgqIg0Nj/9UtVdss+rzI38UrFViCoHUHAf5G6TgDEycUvJQZWzXmnBwmx7+bcdSKOaNq2ehhyars8tEtD7Td4I6DD4qF+/ZVTY0yiyWpX0lu/6BncJKGOC4vreZd88lFY8l0l5ezad0mJzXpKzfvw2XeHzcpCOAXuY=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         nombreA est Entier256("0x23456788fffdcba9877")
         nombreB est Entier256("0xFFFFFFFFFFF")
         
         // Test PGDS
         _pgdg, u, v est Entier256
         (_pgdg,u,v) = PGCD_Etendu(nombreA, nombreB)
         
         trace(_pgdg.VersChaineHexa())
         trace(u.VersChaineHexa())
         trace(v.VersChaineHexa())
        type : 18
      -
        type : 161
        enabled : false
  -
    name : inverseModulo
    identifier : 0x2ba08bf4027a10b8
    internal_properties : BQAAAAUAAAC0xplJ4qnXunLpMCkZwQqL8z0V0bMJ6zTNRRVj33FzsuFWnrB/5eggzDSc+p1Uce+/RCvewu+QHbCBoaHsjRtXyOEcdtWpsRSzw6AuClXbhZmoQZjrW25Lny8zxiC28yl5Cv80v5WGIU/ThiTjybRUSUG2x0yHxWA0joVTmpnqzNOXlT14LmX92bJ/KEsElBt5W5CYEj1MTFEuFNDkfmRNr/MCF1orK/xeYkyy77B+zRw34HF/8eU20NTs63z3A5oxxypAuluy+HWKQGIm3lVxFChYh9aaF/YVZ+LaJr4GnfnLPy/LQDjpOIZRnWOgvazyO3e7auZtbhce1uz2k610h9XtNKJk+8rRRupqoJfCGIhrbB3Rt2LsdFC607C4RaSDQXaIm0UVQ7kCgnVim1EQXA6BBlpwavPUM8DegG3FiTwBvoxmrbziiRDavvRLNwT6CP15lpqVylI7nFlt/fJpDzDQaoJHfonw8hEzwzjxr3wlo7kx8/jWvRI1GFyXRBPl7iwOOKiViBVYrxhlO++tYH0vMsIAZGE8EfjVCCb44M7jNybgYDtbho2+MIt6EQvl1JRzT2eQonj4tSu8PLtKsF7KmSii19fjpEHg5RxnikJhioes+zs653i9UttzHloQvsu2Nrp2IQdqtz2aJbfzePdsg/kBRl0/KnVPU3shuST3o/ip3h3ksOH6zfNSQt6ue2Pk3Btm4NOSaJuxEkOS19pV9gXtYIZRm2Zx
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1-
         gCorps est CorpsModulaire( "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F" )
         
         //P2 est Entier256("1" + Répète("0",28+28)) 
         //P2_Mod est Entier256 = gCorps.multiplicationModulo(P2,P2)
         //trace( P2_Mod.VersChaineHexa())
         
         
         //x est Entier256("2") 
         //x est Entier256("8727b3b7be9139498f2f48f7b88f92203b1ce5ea527fd7dd754F650e2216b915") 
         //x est Entier256("497c0fb9646881ce25a2fc68e89a129135e8715423e73fce0759ecca87d30009") 
         x est Entier256("ea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         
         inverseDex est Entier256
         y_2 est Entier256
         ChronoDébut()
         inverseDex = gCorps.inverseModulo(x)
         Trace( "Temps (ms) : " + ChronoFin())
         //y_2 = gCorps.puissanceModulo( x, gCorps.PMoins2 )
         trace(inverseDex.VersChaineHexa())
         y_2 = gCorps.multiplicationModulo(x, inverseDex)
         dbgAssertion(y_2.estEgalA1(), y_2.VersChaineHexa())
         //trace(y_2.VersChaineHexa())
         
         quotient est Entier256
         reste est Entier256
         ( quotient, reste ) = divisionEuclidienne256( x, gCorps.P )
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_PGCD
    identifier : 0x2badc0020158377f
    internal_properties : BQAAAAUAAADe0a2rIqmwOEh1hzYhmGGz1SthHw8/BDt6EBuHJuWKbewMS6rClQGMxOYRAGGz8EenfhPp/HJuY1R72zde0kT7C19D0UYcSwmAJs11Y8diFg+Qjh0oGUbG4QxoHO/9pbEA5aFZfLDLzJp56Q9F/nDlUFFPm5MROL1E3N0UlRJR+lH/EaZAuQpW4jCrQ3jFJU0N2XTct+HDNtTjgXELryHnmIN5xfCuus/QeG3GPKNWVhcRm+/OBIRR5qdZHmP2qxXW/Hj/ziRS+xrhy5AvXHjwGZUQjdyx+Yj3pG66srsiDO/BspkInhInOip3Dhz9wCmUr4Z0CW+sJemYEHIhY0Cu/ODwkC7wDsUeezi1VYSYCWAoNFQH3+N4i+Xuzov0OnSVpBNlmvmQttt2E5b+jgm0nNEaIFJpsiGuDNz0mbXUfr3l+2Cfdxha4yieZNW224ToPesKjgnT0vQCbwfKr+Ks+Sw8CwrEz+miol7p5LcQ0N/ry0PUJat2TPhOy/ZciVkpfyGWJvtF/p7QIPFRqLL1vsV9qaVIQzCqV7yb5wku7622y2QxbABlz1R4Ba0FxzWR8xdWXTucxdUunAps310lGEv/z/skQHfo0CfqgSBxdtUo/SazAjlkiy//wsWiWOSE0qhH7n/TRjtLtCMYmF9/OqZBHpinsZXIfX249FlOQCDamOlH8c/FnuEW64sedZyosjgemOwPalgo3IumHpSrZRrkXffo+F6m118=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1-
         
         //PGCD_Ex(23,120)
         PGCD_ExR(40,70)
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TET
    identifier : 0x2c228a9a00fa64e4
    internal_properties : BQAAAAUAAAAPd5wKRi9eJM589VTmRqs2MEBJO1bLxGp/+e1CWOgj2UNJuLgilEr/7faSTphfvjeDxO5GaCwfN/TJHEbEmBsSMlEkHQA/VD35nm14nVwJVK8vSzI+N8zKoavZ5Rr8ZGHgtseOrfddSfpa/6syW0uCdSFCb8Ck9J+riqPSVtsLNJWBEKLNOkOy/vBOps8hcPmNjiZxHSAuEa/7oEBvET4zo0dg48E9zyozOgdu0h2N726W6haNAkthke54jCtuWJp1XTquRvW9PH21XdzYWWkwa/H7bF213/9p6N5GmbxpGULHB3ud6L6sacIRWyEtWEti46H6vwbompDIFqZxOsHnk8gUTp6fz6w2hE9HnEF8NcUPliQrl4eYyCDLNQa0pcTCeNhWslMH/14upxhcYokx0y00ulD79GJ9VRPpUZa8KxqAOGhDJxziY9eGsekzcBtpkkBxWDkTeJdmqnyGF/410C0cq9bX3VT7tkeEQ4i0GzRhEcmIB1nJFdtD/tXvUzupJsDwAz4WO+W/B1CUab7TYh+tdLPwD51sms6vDsfqHzPdi7yf6XiEQDBaQ2uC3ah5nGDPoqAImL2Z/wohqAY31/vvwh2CdaviBRoc00zFW3uXJaRzFIzTfSntKK2YTyjOIGctggtBYF52yI9FG7YhQ86h8rVVavRdKdGtV8fYKFLa32r48eyJqJE3aIkcu6qi3UG5lwDw2zNfIOHQfj8AJfgE
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         Signature est SignatureEcdsa
         Signature.R.affecteAvecChaineHexa("13cfb50edf248662ca8d64195cf48b26d90f4ebc1998966d0d9ead4275c20dad")
         Signature.S.affecteAvecChaineHexa("6c2134191f22d1f5fea6848fd23524297fc88c0fb296cd7e955f01370fcda63f")
         
         
         CléPublique est Point256 // = CrytoLib.ECDSA_DériveCléPubliqueDepuisCléPrivée( CléPrivée )
         CléPublique.x.affecteAvecChaineHexa("61b0c48518491955c022d99b0c73b43d947990ae361eced90d5e0d22ce3ab4b7")
         CléPublique.y.affecteAvecChaineHexa("8aa93591f1a2818ffc6e7d575bdc1312055e188616dca470aaefd5bba9b9625e")
         
         N est un entier256
         N.affecteAvecChaineHexa("f49c9d1c8a96157ce04d5651ce201778aba934c3ff245f9c64727ecb2f6fe0ad")
         
         sERR est chaine
         bOK est un booléen =  ECDSA_Bitcoin.VerifieSignature( N, CléPublique, Signature, sERR )
         trace(bOK)
         trace(sERR)
        type : 18
      -
        type : 161
        enabled : false
  -
    name : priv_pub1
    identifier : 0x2dc68581035feaad
    internal_properties : BQAAAAUAAACVe7YuI2advBvAf1qrNeq37+hLKl2Mfx+tUhbgLuu4LBYZvSzrbVJywbf3h1apYK5p9RuiTH6bkI8TYr4wTTnrs+d+o4nwRq3ZUEHVvdUPorfx5F4eQinZPMvDqr089owXEqZy7Y2s2PkK7Cp6GOIgOdhinHcOmlKfK0HzQ/2iPbIszlETAE30gu1M4Dog2QiawF7Y5QCzZiC1m5CZmow/5g0c5RxWzKmImxcPKnvflGy3NCXYm+QA1optfT0exyPOjRGvys1yISkpmVXo7b6SrKOHqiiE+1kUgyPniBoeGSLc7+Sd0n3YxOtlBnfngjyPyawSesGQYNvwPVDok8cH8yrEzlJCRKQu07hE+eqsv0VthLhigg1ZILVO690oaY5hZnlWc0HFgGGAx+GkLNaco5u8b8FmKDZUU3xFrmgIRJrHD2BZl/PBw1B0vZPqoJBKOLn1Ty6nqsc3lvOZ8Kj99/wK5EV6P+dhI2xw808NNqvQNidNUsUNe3qS6K6SCLvYM0C8Q9I5PBKo+2PQyDPP6wHLG8yNGhN7/t2Xe4Mnko+0oQvQhKqs9KPBC5PMirf8Qh8fMG+KEZc754PVogoUYRtNkmPGEb5pdi4wRGPtbH/uiAxIKx6P+1BxddheLvatVUYotUhFPjo5UBaYCpaydzXyBq95eEZwK4eAXItnRKd9FSeEFyk75cCODhyfzhXlWpBn2trvU17S3j78JX95EFP/1VUujWPny3Auer0B7WpE/zZyaxEMtiJFVzltI83veU2B3q7JiJSngS88eb38dj4wAApR
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1-
         gbModeBench = vrai
         CrytoLib est ECDSA_BTC
         ClePrivee est Entier256("0x914f06164094ab80f14de57c15a5dead827a473c005837a5c137167db965a203")
         //CléPrivée est Entier256("2")
         
         Trace("Calcul...")
         ChronoDébut()
         ClePublique est Point256 = CrytoLib.DériveCléPubliqueDepuisCléPrivée(ClePrivee)
         Trace( "Temps (ms) : " + ChronoFin())
         Trace(ClePublique.x.VersChaineHexa())
         Trace(ClePublique.y.VersChaineHexa())
         
         // TEST si OK
         xOK est Entier256("0xc51b1777e1a45b4b3cc29d32cd89153ded2c45d6cadc019207f5aec8b451e9e9")
         yOK est Entier256("0x58f798f6ec04fbcb768aae73f4f58ecd55cbf7326d79adf7cf5bf620ed9acffe")
         dbgAssertion(ClePublique.x.estEgalA( xOK) )
         dbgAssertion(ClePublique.y.estEgalA( yOK) )
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Test_mult_2
    identifier : 0x2dc8390b03833679
    internal_properties : BQAAAAUAAAC25l+k5yvWcrfrvD8AybJJF8fcdgGl+jRgpCqX851Urjxl+4IPbgu7QqvxaURIXx7YHzt556A5F03mXd+Wd0KHDWpj8kThH9FY0EI51r1bgTcNzMd6ONyI/rCuNVwOQVjR78S7AWfPAx2cYMlhglpr+018ltIprDv65VX5FItbONAETKmeThOgzdwEse5ECnFhRoyBfGwC0+FKuiQnJA2EYc1ObySXmPE9MwedePpQouGVYHcqSWHWgnUetyCamWI2cFpEpkFeXlJPkKaqggayJHy0awziDcSMDp6TNjYwfoVD4MnaeQ7kWGVg0WNQ9JgQFtBa81xJjFfFf19fMTtukM0p4Or8FHQzls77USwZ1w33OYg6vFdqHaI2r0s6YKMsDqy6yLNalgexH7fIzuXBbdXNdVK/8Flq2cLTPRdGrRzh+B9ju0hsBVd4XTkgDTWxOaKjeG1TQsixNUIoWRSjvOJtQjja5X26Y/g4dllaEyKxakxAYbOYZnX+ouKW635qnRyLhtUf1mqfOOqrbBpu97tAVoPu+VA2GvzU10GktVlICEMH9IRXqU/C3kVRJwZ+3RpXv1S95KjSHVaVmvTvyFi9S8L1I9C1nsJmij90lElJV96ao9wj3iV+QMiJp9yifIAutm1q3xfZaHXUAIOC7BjQR0UK2yMuMlspvIf8pi8uDUYC3J4Wo32QJMdgWFtM/ME/M7q4bWj0TZedzzPKIKYkCWB/xfFC1c+xJQ==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         gCorps est CorpsMudulaire_sepc256k1 //( "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F" )
         
         
         x est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         //x est Entier256("80000000000000000A00000000000000000000000000B00000000000003") 
         //x est Entier256("483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8") 
         //y est Entier256("0x43cf5d4541155780f44aa34089024a194415bd27e39f7acf86848972528faa001") 
         //y est Entier256("0x43cf5d4541155780f44aa34089024a194415bd27e39f7acf86848972528faaae") 
         y est Entier256("0x43cf5d4541155780f44aa34089024a194415bd27e39f7acf86848972528faaae") 
         //soit y = x
         //y est Entier256("1222") 
         xy est entier256
         xy2 est entier256
         xy_TEST est entier256
         
         // TEST
         //sDLL est chaine = "C:\Users\Paul Albert\Source\myRepo\LibInt256\x64\DebugDLL\LibInt256.dll"
         sDLL est chaine = "C:\Users\Paul Albert\Source\myRepo\LibInt256\x64\ReleaseDLL\LibInt256.dll"
         dbgAssertion(fFichierExiste(sDLL))
         ChargeDLL(sDLL)
         si ErreurDétectée ALORS
         	erreur()
         	retour
         FIN
         hModule est un entier système = API("kernel32","GetModuleHandleA","LibInt256.dll")
         pAddr est un entier système = API("kernel32","GetProcAddress",hModule,"multiplicationMudulo_sepc256k1")
         dbgAssertion(pAddr<>0)
         
         ChronoDébut()
         POUR i = 1 a 10 000
         	//API(sDLL,"multiplicationMudulo_sepc256k1", &x, &y, &xy)
         	API(pAddr, &x, &y, &xy)
         	//Trace(xy.VersChaineHexa())
         	//x = xy
         fin
         soit dureeAlgo3 = ChronoFin()
         Trace(xy.VersChaineHexa()+";"+dureeAlgo3..EnMillisecondes/10+"ms")
         //retour
         
         
         
         // nouvel algo
         ChronoDébut()
         pour i = 1 a 1000
         	 xy2 <- gCorps.multiplicationModulo(x, y)
         fin
         si pas xy2.estEgalA(xy) ALORS
         	trace("*****ERR*****")
         FIN
         soit dureeAlgo1 = ChronoFin()
         
         // ancien
         ChronoDébut()
         POUR i = 1 À 1000
         	xy_TEST <- gCorps.multiplicationModulo_OLD(x, y)
         fin
         soit dureeAlgo2 = ChronoFin()
         
         
         //trace(x.VersChaineHexa())
         //trace(y.VersChaineHexa())
         trace(xy2.VersChaineHexa()+";"+dureeAlgo1..EnMillisecondes+"ms")
         trace(xy_TEST.VersChaineHexa()+";"+dureeAlgo2..EnMillisecondes+"ms")
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Image1
    identifier : 0x2e10ace804c9b359
    internal_properties : BQAAAAUAAACHh+yHqitMRgKyC+o4VZk/aquBSssMrqDLGFuC4vS+N/ZwB0Pyag1JPBeZPZMtNlWcPPx07qSWphV4Z4sDBYrfh7x9ENhNuZALlizvM8bVGghRZAKZovNIfxU1xJSKZGHEAWYVmd/qSddIWLjsstK/c/YMBgW/ovj8/Z4NbVdhELSgnQ+jgvKjhIR39RQNMOkqnh0sp6amNqZlGbUrEXz65yhgyUMNThGbxhkPunJAxw+w38r9go+J/sjMIuZukKi1dFgaYk6zeCAjl7v26QguFtHP6+wBFnwIWxccA7Wc/U/7ABt54FXRpc2CUeHlsATZqHEmySwOIbp2ceVTp3quCB+X7roUEsSsM1NI+9pARPej9rNX5wpaRZy7TvIWNbQ9QOGVDzB4YAF5Ev9OsRxqIkried5z/UivUgoxLxTnY7Nuaew5H0sY0GYjOWXF1KZ3wKYfz7mwV1dgIA3RYTn//xS5VM+IU6M8UtCNCqah0Qdb3kcAi3N/SuZG4hUnhLbnB67Py0+J9WlVfvMZP58rMu49v/ma9PAJ2474lzJHLOKl7JN0V94pJau9pRa+Kovv9ZCZvDZwgoJ6fJH+uqApKki3mvGLdZZw+irXq7dIMeB+dS18zrpwBw9RGOxmNY76XOrxjtzchanpNvPIhgFqWRCocN8JJGIBE70GtbhbHoy1GxvKDoyUhUm4K2epFTIFaEpraRR9EKXK1mHGTz7ZJ1MVT4lRMMI/V+npS5rbbRv/W3I648EBbiidGRBwccY9eSB98IkbysJKJ/zczkmSK81Wc2vbty+nIATZ818nJ68nI4vnpd0HxKF9INPcGDCoe7NMlCZ70IHyrGWRPROZx0SMPzbWGZq0Ihzx2UNbcLL8Peib3Z/Frw==
    type : 8
    code_elements :
     type_code : 8
     p_codes : []
  -
    name : ECDSA_SigneNombre_ECDSA_VérifieSignature
    identifier : 0x2c02cf800181802d
    internal_properties : BQAAAAUAAAC10MuLWt7sCxiacP/eDrizhVE8WxBmFrZUZ1Lcsv6OIW78jZKjGvP/heQSRdmt9eGitKHcaqwloPvDv4LSn9llseFR7iCte7GZqdUKc2Y/avbtaESWnUpqwo6HMFIZhyJeKy/P3DjtX6yudscP4TWpqI2WO6Q2ivOGTL9+AcZaJECe5LWuEcNkaiXaTtsfsp6MVvO+0EC8utdQ55AE5r76arl2crFp/hDzjZjL/9hzTzVSRxLPcdWbjEY1vOoHlG7L9ym6XMeG9wDpoPWYN2DFlmPB7kzuaikxl5nJlTdnb0lziwAOXAEHDyY4qGWiXUKhvnYQ6amX/kkxAcaADc3W3IrgP40LKOU+pxapUV6s7MSjPo/N58GVc/2ibbQ4jrAQ5/If9hYtJUGSbleoVRkYNJ6P+fruJjSWXQrE4xWYbiuh4zHLOKQqTqn7aDPoZu7GS+XEQqyl6nY230sefKI6s1yRHu5eiXA8Hhj5g2k0tJM0mrIiwp19FLGYX7m6jxBgJSMRH4lm+5irLk/chBpOE4A8xW9Tb+0IHTwr2ftP+xAa8MN3hAKOawS3/qXVgW2gWpIHKE201K65tG3VZ7TCdBiqg9dl5yuJQqMMTyJlhJzfLtBCKXxXoND5WALWHjbkqzwtrXtpJhjHFJIWzTv1+o4ZxqPxZBHnce3+fx9pwrykZ3MSxFhWIRovMPjRTITMwwvgPCDn91tG9m1zr5QCWIFd12UKdcqXupzDK+5yS4dZVXNBP1HO+sP8imiPCQ+wCTUYWi+t0LDXCVI=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         CrytoLib est ECDSA_BTC
         ClePrivee est Entier256("8727b3b7be9139498f2f48f7b88f92203b1ce5ea527fd7dd754F650e2216b935")
         N est Entier256("12345678")
         //CléPrivée est Entier256("3")
         
         Trace("Calcul...")
         ChronoDébut()
         signature est SignatureEcdsa
         signature = CrytoLib.SigneNombre( N, ClePrivee)
         Trace( "Temps (ms) : " + ChronoFin())
         trace("Signature : ")
         Trace(signature.R.VersChaineHexa())
         Trace(signature.S.VersChaineHexa())
         
         CléPublique est Point256 = CrytoLib.DériveCléPubliqueDepuisCléPrivée( ClePrivee )
         Trace("Clé publique : ")
         Trace(CléPublique.x.VersChaineHexa())
         Trace(CléPublique.y.VersChaineHexa())
         
         sERR est chaine
         ChronoDébut()
         bOK est un booléen =  CrytoLib.VerifieSignature( N, CléPublique, signature, sERR )
         Trace( "Temps (ms) : " + ChronoFin())
         trace("Vérif signature :" )
         Trace(bOK)
         Trace(sERR)
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_SQR
    identifier : 0x2e11a4eb00e97d0e
    internal_properties : BQAAAAUAAACTlJAChc02WESvKwoPaBG1yRmDH7Dogc5pVy3whReoyVa41wgsv1Heyqpn9mWBvqtpIkd/+kid0YcnLJlaLrsoGXDGm2Lgj3dUMrmbdbD0SC9LWhl0NbLS5aj0WLuZAR00+RVtYGTf4C4PI73VZkxlGyjaRdvsPplsrQJgtJtvlNYHh6vxJtiukZ3RHqKTGoPkNaTeibOv3P7/Aw8TYbcfDm8dS7o47h1y7Aew0BUs/mGRU1H8cgzPaNvXiM8UyUV02LB5uO5GXbS14frLguKkSzWwH8qv2e7F7OjAyonwhAm5PqvqiJa9fP6ZjPz/ooVW7wYWC2GAu/tMTjzl5d4OziBAPqjyCscMUxIXiXrm2d60wAY5sMLjDkizQ7Dd2xsyv8gW0yajwf5BaHvrj05vyQw/6VNOvTBB99HZhqalbf7AOPFAhBvZYtM7wWoHQA9tmECjJ4ZW1WPxsGATRA/Pvo+JpGsJ6ojFgTfSvdx9Q1R+UMxdWrYBa8dv7Nd58qCmhiL7gzyUTTk75dZuseuMZ2j6yo7VtqfVBjx9kFId2f31GzpnbfQ8jFmkS/1eRwGKl4HaQSwdomEnjtwuGfvhfr9Te08YDMP0vMO2RZz90sE8iWq/Lp3I389xcKvC+AS8AsCVYMmpWpbh4L7aNu3P+1vlvPs2MpIl6vj7BzCxVQdHc6CeVCyiu84Bzqb1JE3rXW+rtTNYs4ExJ0LtlV8gKPvXsGJDXcXZmpI=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1-
         CrytoLib est ECDSA_BTC
         corps	est CorpsModulaire dynamique = CrytoLib.corpsOrdre	//( "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141" )
         
         
         //x		est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         // x= n-3
         x		est Entier256("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e") 
         //x		est Entier256(3)
         //x		est Entier256(3)
         
         // y   = 70ad49ae7f8574ecab641a42b3a24f22d6374023944cc665a6bcaeb0f37bbf78
         // y^4 = 1
         
         //x		est Entier256("0x04") 
         //n=				   fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         //nSur2 est Entier256("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0")  // n/2 - 1
         //nPlus1Sur2 est Entier256("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1")  // n/2 - 1
         //nSur3 est Entier256("0x55555555555555555555555555555554e8e4f44ce51835693ff0ca2ef01215c0") 
         //nSur4_Moins1 est Entier256("0x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d9050") // n/4 - 1
         //nPlus1Sur4   est Entier256("0x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d9050") // (n+1)/4 
         //nSur4_Moins1 est Entier256("0x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d904F") 
         //n_8   est Entier256("0x1fffffffffffffffffffffffffffffffd755db9cd5e9140777fa4bd19a06c828") // n/8
         //n_16  est Entier256("0x0fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036414'") // n/16
         
         // calcul racine cubique de X 
         Trace(x.VersChaineHexa())
         racineCaree_x est un Entier256 = _RacineCaree_SHANK(x)
         Trace("y = racine(x) =" )
         trace(racineCaree_x.VersChaineHexa())
         //
         Trace("y^2 =" )
         yy  est un Entier256 =  corps.multiplicationModulo(racineCaree_x,racineCaree_x )
         trace(yy.VersChaineHexa())
         ////Trace("y^3 =" )
         //yyyy est un Entier256 =  corps.multiplicationModulo(yy, racineCubique_x )
         //Trace(yyyy.VersChaineHexa())
         
         //divisionEuclidienne256()
         //inverseModulo
         
         
         
         procédure interne _RacineCaree_SHANK( nombre entier256  ) : entier256
         	
         	// p = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         	trace(corps.P.VersChaineHexa())
         	// p-1 = 2^s * t
         	// p−1 = 2^6 * x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d905
         	// s = 6
         	// t = 0x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d905
         	t			est entier256("0x3fffffffffffffffffffffffffffffffaeabb739abd2280eeff497a3340d905")		// = (p-1) / 64
         	tplus1Sur2	est entier256("0x1fffffffffffffffffffffffffffffffd755db9cd5e9140777fa4bd19a06c83")	// = (t+1)/2
         	
         	// au "hasard". ne dois pas être un résidu quadratique
         	M			est entier256("0x40bf3e95c2d24abb0dc4a579b08c0d3f52ef113a8484f33e83de2d1fef487b48")	
         	
         	
         	B  est entier256 =  corps.puissanceModulo( nombre, t)
         	_X est entier256 =  corps.puissanceModulo( nombre, tplus1Sur2)
         	Y  est entier256 =  corps.puissanceModulo( M, t)
         	R  est entier    =  5 // s-1
         	
         	//@TEst
         	_32 est Entier256(32)
         	_yy est un entier256 = corps.puissanceModulo( Y, _32)
         	trace(_yy.VersChaineHexa())
         	
         	tantque R>=1
         		
         	  // calcul de B^(2^(R-1))
         	   _2PuissanceRMoins1 est entier sans signe sur 8 octets = Puissance(2, R-1)
         	   trace(_2PuissanceRMoins1)
         	   _2PuissanceRMoins1_256 est entier256(_2PuissanceRMoins1)
         	   B2R1 est entier256 =  corps.puissanceModulo( B, _2PuissanceRMoins1_256)	
         	   
         	   //@Test
         		_2PuissanceR	est entier256( _2PuissanceRMoins1*2 )
         //		B2R				est entier256	=  corps.puissanceModulo( B, _2PuissanceR)	
         		B2R				est entier256	=  corps.carremodulo( B2R1 )	
         		trace("R="+R+":"+_2PuissanceR.val0+":"+B2R.VersChaineHexa() )
         		Multitâche(-1)
         		dbgAssertion(B2R.estEgalA1())
         		
         	   
         	   // si c'est 1 
         	   si B2R1.estEgalA1() ALORS
            	
         	   		// Y = Y^2
         	   		Y =  corps.carréModulo(Y)
         	  sinon
         	  	    // B = B*Y^2
         	   		B = corps.multiplicationModulo( B,  corps.carréModulo(Y) )
         	   		// X= XY 
         	   		_X  = corps.multiplicationModulo( _X, Y )
         	   		// Y =Y^2
         	   		Y =  corps.carréModulo(Y)
         	   		
         	   fin
         	   R--
         	FIN
         	
         	renvoyer _X
         FIN
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_MAP
    identifier : 0x2e12d85900ed5c65
    internal_properties : BQAAAAUAAACt0YXaPTvNjITGVPZl3uq7hBtp0uOSkX/Kj4wzbzdya8nB5hyOrQA5mx3R8oJL+kW/3Jox5FnuDWASwjsHpSxZu5/aPV0BgpMuY1+veREtj1t8SISmIRc4a5G2arFZtjJ3nZOoZS8HygIrq1TtkWBev/Cc4OUJH43tRQztSSG7PsccNTgc8ZQggLgxdkWwx3gASYguE9G9cnQh+cvYIiMBekyEN2v9EkShr0fsX0C2u9UaLL/ByTnqJH5ab0JoqEKE7zyxLXPCn6XDgz0G+mlGp6/Ba/FGo8+AnG+leL8F3l7t7w/lqSaF9e2GLbnwhM3xLGbXn2vqa371T9F3VG/Mae9H1B/Cy9LN1KYe79/jKVDGcJVISOS2mi50pgi0K1fcELnL+b1tRipDT6TndvxFhXsO3iUTq0X1zSCQlnc3f0LpuyRUV+fe9M8u2JQq1OdvYed2rxkkZvFJb1kBt3PvFFA8t9HoeG0BU/ofGy/NJ5rbEc/BT2BWHQt23T/U6I6mT7UW1StUaDUh3Bciuhc8aW83B+gwfLbvwgvisO5c9to/SVSooXN485JCw0JM/m4TO3GCJgRHKbG1w8Vo4hn3AsKUmFPtppAoUhg3/xH1/pfRUnXb8X2F0RfSj70NTsKwox8/XZs2QLkieMDhwvoGWi/1Wu58zeKqpSiD0ijaEJ5FMWgzFK1e3u8B1ptRE6owJ5+TpIFLe3Y03WJWDQHowqmjINcnFgxVlG9o
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib est ECDSA_BTC
         corps	est CorpsModulaire dynamique = CrytoLib.corpsOrdre	
         
         
         
         // nombre d'odre 3.
         // ie tel que  beta^3 = 1 mod 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         //beta  	est Entier256("0xac9c52b33fa3cf1f5ad9e3fd77ed9ba4a880b9fc8ec739c2e0cfc810b51283ce")
         // ie tel que  beta^3 = 1 mod 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
         beta  	est Entier256("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
         
         // Racine carrée de 3:
         //racineDe3      est Entier256("0x3538be51af024152640d9ba6e4fa9c5ce6ed7102d28e789bcc8921c18a34cf78")
         //// Racine carrée de -3:
         racineDeMoins3 est Entier256("a6c75a9980b861c14a4c38051024c8b4245c45d44102ccf1be052cf836477ae5")
         //// racine de X^2 + X + 1 = 0 :
         //// (1 - racineDeMoins3) / 2:
         //// 0xac9c52b33fa3cf1f5ad9e3fd77ed9ba4a880b9fc8ec739c2e0cfc810b51283cf
         _moins1 est Entier256("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
         _1 est Entier256(1)
         _2 est Entier256(2)
         //_1_MoinsRacineCaréeDe3 est Entier256 = corps.soustractionModulo(_moins1, racineDeMoins3)
         _moins1_PlusRacineCaréeDe3 est Entier256 = corps.additionModulo(_moins1, racineDeMoins3 )
         //_moins1_PlusRacineCaréeDe3 est Entier256 = corps.soustractionModulo(_moins1, racineDeMoins3 )
         //trace( "-1-sqrt(-3)   = " + _1_MoinsRacineCaréeDe3.VersChaineHexa())
         _L est Entier256 = corps.divisionModulo( _moins1_PlusRacineCaréeDe3 ,  _2 )
         trace( "-1-sqrt(-3)/2 = " + _L.VersChaineHexa())
         //Trace( corps.multiplicationModulo( _L, _2).VersChaineHexa() )
         
         // racine de X^2 + X + 1 = 0 ( modulo xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 )
         //_Racine est Entier256("ac9c52b33fa3cf1f5ad9e3fd77ed9ba4a880b9fc8ec739c2e0cfc810b51283ce")
         _Racine est Entier256("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72")
         //_Racine est Entier256= _L //("0xac9c52b33fa3cf1f5ad9e3fd77ed9ba4a880b9fc8ec739c2e0cfc810b51283cf")
         x est Entier256 = corps.additionModulo( corps.carréModulo(_Racine), _Racine )
         x =  corps.additionModulo(x, _1)
         dbgAssertion(x.estEgalAZero())
         //trace("X^2 + X + 1     = " + x.VersChaineHexa())
         
         
         P est Point256 = CrytoLib.courbeBtc.pointGen
         P =  CrytoLib.courbeBtc.pointDouble(P)
         
         // _Racine^2 marche ausi ?
         // _Racine = CrytoLib.corpsECC.multiplicationModulo(_Racine,_Racine)
         
         // on doit avoir _map(P) = _Racine * P
         mapP  est Point256 = _map(P)
         trace("Map(P) : " )
         trace(mapP.x.VersChaineHexa())
         trace(mapP.y.VersChaineHexa())
         //moinsX est Entier256 = CrytoLib.corpsECC.négationModulo( mapP.x )
         //Trace(moinsX.VersChaineHexa())
         KP  est Point256 =  CrytoLib.courbeBtc.MultiplicationScalairePoint( P, _Racine )
         Trace(" K*P : k = "+ _Racine.VersChaineHexa()  )
         Trace(KP.x.VersChaineHexa())
         Trace(KP.y.VersChaineHexa())
         
         
         // (x, y) => (βx, y) 
         procédure interne _map( _p est Point256 ) : Point256
         	pointRésultat est Point256 
         	pointRésultat.x =  CrytoLib.corpsECC.multiplicationModulo( beta, _p.x )
         	pointRésultat.y = _p.y
         	renvoyer pointRésultat
         FIN
         
         PROCÉDURE INTERNE _map2( _p est Point256 ) : Point256
         	RENVOYER _map(_map( _p))
         fin
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_SQR_3
    identifier : 0x2e142a0400e15cc3
    internal_properties : BQAAAAUAAABN8WV6/SUjLhZU3j/aA1iZ5sZ8NhPzH3w1TYeuFInXlpGWQmjeOCLH80Pfo/QdTI5akLovfIGGvao3GsAbOzL6HpEZotHWgkFOdyBF2l/tQ2uh9tXDf+woLPPXbvA4my2n+DqcQ3FaXs6U1lJC3YQHXLldMcWDvzMfad/ypY06GmumL7pmO9K6SoYTQD/aAtLurzomOUeNauIbQUGgavHXcFK+x+1vDpxfcd8Oz6hcmTdkikP/F5EmhnxKXa5cshQ+eW5J892eQ5N179v6zgdUoelTi/t4p7u+lkufbANTdCAvobfLH0ahx2NivyF4Ksv/KhCHTQUut7RfFx+H3HGum3nRvIksB8pP2iKQR+fZl+qoguWObg9zQVUX/aGL1P6VTfwKtjiUb4ESmhMIpcmQ/uhJLepO2nIkvB+Tk2o0ckfSqs+1NrozA+7ZD8VpecpgRtY58CAvU+Q0DrxO6kjC6Y1DUkJ/kwYUNtGiwArqCk8kzJbOQm9nlJK1qOyHSbX/EFSJZloXrchUl04TKaBTnhju0iH/zwu24TqNfRJE3jKbjZSUvfOISzLuUYrBAfPBov55d9Ve4m8IH/h41KKsnnoeH08tmX/xi7+rLWEbVPYS+PO23r/LZ9ZpzLKWyrgmAo5Acp52RvLY6MmT3GzetXAzlspwmT7Ut1a6+lTK4M1YvO+Ew+0SksPg49Xo0KAghXXWyq3mYFU8/gslvoNRapWXMBMjFiy1NI8I
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib est ECDSA_BTC
         corps	est CorpsModulaire dynamique = CrytoLib.corpsECC	//( "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F" )
         
         
         //x		est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         // x= n-3
         x		est Entier256("2") 
         //x		est Entier256(3)
         //x		est Entier256(3)
         
         // y   = 70ad49ae7f8574ecab641a42b3a24f22d6374023944cc665a6bcaeb0f37bbf78
         // y^4 = 1
         
         //x		est Entier256("0x04") 
         //n=				   fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         //nSur2 est Entier256("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0")  // n/2 - 1
         //nPlus1Sur2 est Entier256("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1")  // n/2 - 1
         nSur3 est Entier256("0x55555555555555555555555555555555555555555555555555555554fffffeba") 
         
         // calcul racine cubique de X 
         Trace(x.VersChaineHexa())
         racineCubique_x est un Entier256 = corps.puissanceModulo(x, nSur3)
         Trace("y = racine3(x) =" )
         trace(racineCubique_x.VersChaineHexa())
         //
         Trace("y^3 =" )
         yy  est un Entier256 =  corps.multiplicationModulo(racineCubique_x,racineCubique_x )
         yyy  est un Entier256 =  corps.multiplicationModulo(racineCubique_x,yy )
         trace(yyy.VersChaineHexa())
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : TEST_MAP2
    identifier : 0x2e155cf800e36084
    internal_properties : BQAAAAUAAACszoTZPAfDlugyvt3+52IzTOSe0rAUrMWUHJerEI1ROGuQdPSgrmZr2eU7tZgxkrTQXrAnZo+yUdhhpi4Ds7yE1JdHCq+BTI2my0HlFtZcztb8XJZqmV02A2mY7i/vPnr3DYfaESN7FP4PbbhfO0TCz9gkwqUK++2F9Tw1+Tknyq80KVgoKTAA8Cgxho0IUfhAidgek7GtsiSBOWtoEkORivwk1/sNcnShvxf8X4Bm+9XanI8hiQnK9L6az5KYiHI0f/zxXSOC70UTEw2Guhmm568xGxHGs68QXA/lKA9Frm5dD691+cZ1Vb12XVlQNI3RDDbHvys6iy41z7FnJI98mT/H9O/S64LtRLYuj39TyTAmAOWIaMyuApbcDpAso49EqGGTwTX1PlLrN+wvjvS9bXNWJo3rc52ddUg4Pi/vd4rhoyyczy+WPLc2gBwC7L8X2e8eF/FsPhkxt2HJ70uH/OjE35lggGWJ22InA6dF3+JzORepp+juZZP+pSfMgCaOZ70eHaNcYD3p5P/qcs80sYdfD/DopG7XyhPqmMh+VFgRGwYm4w2yoSiEVRj2SPzxPROcBGb4uILO7JY7vzycKdHF8ao8FRmnufsigOCaKdD+hXjYxFgugA41uKaE4Rdn4kQEoCgLLeO5DaJyfcP3fPvABwVFchn9oIObmYUpSSTfHVQ7zFKZ44QtjJyhj+FjvDybK9Rj39L5e9QsBz5OqZSQNdokEwtUk25p
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib est ECDSA_BTC
         corps	est CorpsModulaire dynamique = CrytoLib.corpsOrdre	
         
         
         _P est Entier256("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")
         
         
         
         P est Point256 = CrytoLib.courbeBtc.pointGen
         //P =  CrytoLib.courbeBtc.pointDouble(P)
         
         // Test que 2 P = map(P) - map(map(P)) ?
         
         // on doit avoir _map(P) = _Racine * P
         mapP    est Point256 = _mapFrobenius(P)
         dbgAssertion(  CrytoLib.courbeBtc.pointEstSurLaCourbe(mapP))
         mapP_2  est Point256 = _mapFrobeniusCarré(P)
         moinsMapP_2  est Point256 =   CrytoLib.courbeBtc.pointNégation(mapP_2)
         moinsMapP    est Point256 =   CrytoLib.courbeBtc.pointNégation(mapP)
         
         _2_MoinsP est entier256("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413f")
         _T_fois_mapP  est Point256 =  CrytoLib.courbeBtc.MultiplicationScalairePoint( mapP_2 , _2_MoinsP )
         
         _P_  est Point256 =  CrytoLib.courbeBtc.pointMoinsPoint( mapP_2, _T_fois_mapP )
         
         // ---1
         trace("  Map(P) - Map(Map(P))   : " )
         trace(_P_.x.VersChaineHexa())
         trace(_P_.y.VersChaineHexa())
         ///---2
         //_2 est Entier256(2)
         _1 est Entier256(1)
         
         
         
         _1P  est Point256 =  CrytoLib.courbeBtc.MultiplicationScalairePointGenérateur( _1 )
         Trace(" P :"  )
         Trace(_1P.x.VersChaineHexa())
         Trace(_1P.y.VersChaineHexa())
         
         
         // (x, y) => (x^2, y^2) 
         procédure interne _mapFrobenius( _Pt est Point256 ) : Point256
         	pointRésultat est Point256 
         	pointRésultat.x = CrytoLib.corpsECC.puissanceModulo(  _Pt.x, _P )
         	pointRésultat.y = CrytoLib.corpsECC.puissanceModulo(  _Pt.y, _P )
         	renvoyer pointRésultat
         FIN
         
         // (x, y) => (x^4, y^4) 
         PROCÉDURE INTERNE _mapFrobeniusCarré( _Pt est Point256 ) : Point256
         	RENVOYER _mapFrobenius(_mapFrobenius(_Pt))
         fin
        type : 18
      -
        type : 161
        enabled : false
  -
    name : K1_K2
    identifier : 0x2e1826970129ec26
    internal_properties : BQAAAAUAAACanWlWfnh/kWGyNt8KC4SOLv6E/s0sTsV8OmjVM4e8v15uBezDFnvmxqg70ot1MikB3NXX3nSz0XOZ2CHcbsvifSbEl6cEs1GTuSf/1LWcr52TOPXQzh7cS6vq2hJWSHJSDrxMSsf6w0EccGjsKaSx/gaZxA1418wPTLE5F2Mab8cQS4kQ9PsxzI4CK2/+9ICRoJH+FgxJyN61h9PF3IxkVxN71L9DaZk0N2Ya7SQHO1PmoqYzps+DVxd/QgVzbzn/jfHTtnsaga3kyie6qS9K7zTFZBZa4uLCZV5VkYoK/lrEzQ29dNm46TX43aMf01z/EqU91rz30MBtZd1CnGEF7wfnudMNsbyBQME8WtGac/GtR+BTiXkWTTO6JlMG6FY7OLUlwgOmytfWAe4WaG8OYj3s6JI7oJXiJLIcw05ZBQoC4DkmafbZ9AvdJJj1CnXitXHZnfohILBy7mWe7f60WzLEJID4QieUFB6M/Gt5qrpl+7bnSclCZmrnjhEBLMPBSaLe7F3rahNSSrFxjEOtf8c0E5ol3FCMHaMcfIKhqy99jULvuHfqzyxVxFQujUmwyVXcvZmjdP8gQ4SliOJaJQjgdjDppinq6IoBZNcK0iZZv0XbfvQuep+caQfoslISXyAXFu+iWy+274GVceDcwkDkS2Kdm3cmQ3NCzn/Y/qYIst/dkm/piikqW7/uLeRU3uDSlBMY7RdfIyyX7U+gALUX8iSrtZrik5s=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib	est ECDSA_BTC
         corps		est CorpsModulaire dynamique	= CrytoLib.corpsOrdre
         N est Entier256 = corps.P	
         // 					0x100000000000000000000000000000000 00000000000000000000000000000000
         _Lambda est Entier256("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72")
         
         nMax128Bit  est Entier256("0x100000000000000000000000000000000")
         
         // trouve x,t,r tels que
         // s*N - t*_Racine = r et r < nMax128Bit
         soit (s,t,r,i) = PGCD_Etendu_StopMax(N, _Lambda, nMax128Bit)
         
         // vérifie que  S*A + T*B = R 
         _SA		est Entier512	= multiplication256x256_512(s,N)
         _TB		est Entier512	= multiplication256x256_512(t,_Lambda)
         _Tmp	est Entier256 
         // r = SA + TB  : 
         bSPositif est un booléen = estpair(i)
         SI bSPositif ALORS
         	//  avec T négatif  =>
         	//  R = SA - TB 
         	_Tmp = soustraction( _SA.valPoidsFaible, _TB.valPoidsFaible  ) 
         SINON
         	//  avec S négatif  =>
         	//  R = - SA + TB 		
         	_Tmp = soustraction( _TB.valPoidsFaible , _SA.valPoidsFaible ) 
         FIN
         trace(_Tmp.VersChaineHexa())
         
         
         Trace("************Trouve :")
         trace("s:"+s.VersChaineHexa())
         trace(t.VersChaineHexa())
         trace(r.VersChaineHexa())
         
         // R-1:
         _0_256 est Entier256
         soit (s0,t0,r0,i0) = PGCD_Etendu_StopMax(N, _Lambda, _0_256,i-1)
         dbgAssertion((i0=i-1))
         // R+2
         soit (s2,t2,r2,i2) = PGCD_Etendu_StopMax(N, _Lambda, _0_256,i+1)
         dbgAssertion((i2=i+1))
         
         Trace("************ -1  :")
         Trace("s0:"+s0.VersChaineHexa())
         Trace("t0:"+t0.VersChaineHexa())
         Trace("r0:"+r0.VersChaineHexa())
         
         Trace("************ +1  :")
         Trace(s2.VersChaineHexa())
         Trace(t2.VersChaineHexa())
         Trace(r2.VersChaineHexa())
         
         procédure interne _F( x Entier256, y Entier256 ) : Entier256
         	res est Entier256 = corps.additionModulo( x, corps.multiplicationModulo( y, _Lambda ) )
         	renvoyer res
         fin
         
         // vecteurs tels que  X + Y*_Lamda = 0 modulo N
         V1_X est Entier256  = r2
         V1_Y est Entier256  = t2
         V2_X est Entier256	= r
         V2_Y est Entier256	= t//corps.négationModulo(t)
         //_Tmp est entier256
         _Tmp = _F(V1_X, V1_Y )
         Trace(_Tmp.VersChaineHexa())
         _Tmp = _F(V2_X, V2_Y )
         Trace(_Tmp.VersChaineHexa())
         Trace("****** ")
         Trace("X1 (v1.x) = " +V1_X.VersChaineHexa())
         Trace("X2 (v2.x) = " +V2_X.VersChaineHexa())
         Trace("Y1 (v1.x) = " +V1_Y.VersChaineHexa())
         Trace("Y2 (v2.x) = " +V2_Y.VersChaineHexa())
         
         X1Y2 est un entier512 = multiplication256x256_512(V1_X,V2_Y)
         X2Y1 est un entier512 = multiplication256x256_512(V2_X,V1_Y)
         _Delta est Entier256 = soustraction( X2Y1.valPoidsFaible, X1Y2.valPoidsFaible )  
         Trace("_Delta = " + _Delta.VersChaineHexa())
         //trace(X1Y2.valPoidsFaible.VersChaineHexa())
         //trace(X1Y2.valPoidsFaible.VersChaineHexa())
         
         // Test de multiplication par K (nombre "au hasard")
         K est Entier256("0x071e443c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef878")
         
         //  = K * Y1 / Delta
         //   =K * Y2 / Delta
         _B1 est Entier256("0x085428ac856e542bb711d2bb9e408611")
         
         K_Y2 est Entier512 = multiplication256x256_512(K,V2_Y)
         
         
         
         _DeltaLow est entier256 = _Delta
         K_Y2.multitpliePar2puissance128()
         _DeltaLow.diviseParUnePuissanceDe2(128)
         reste est Entier256
         trace(K_Y2.valPoidsFort.VersChaineHexa())
         trace(_DeltaLow.VersChaineHexa())
         
         (_B1,reste) = divisionEuclidienne256(K_Y2.valPoidsFort, _DeltaLow  )
         trace("_B1:" + _B1.VersChaineHexa())
          
         
         _B2 est Entier256("0x2b6a121d1ef84b440996421265b4e26d")
         K_Y1 est Entier512 = multiplication256x256_512(K,V1_Y)
         K_Y1.multitpliePar2puissance128()
         (_B2,reste) = divisionEuclidienne256(K_Y1.valPoidsFort, _DeltaLow  )
         Trace("_B2:" + _B2.VersChaineHexa())
         
         
         
         // v = b1*V1 + b*V2
         VX1 est Entier512 = multiplication256x256_512( _B1, V1_X )
         VX2 est Entier512 = multiplication256x256_512( _B2, V2_X )
         
         YY1	est Entier512	= multiplication256x256_512( _B1, V1_Y )
         VY2	est Entier512	= multiplication256x256_512( _B2, V2_Y )
         
         VX est Entier256 = soustraction( VX2.valPoidsFaible, VX1.valPoidsFaible )
         trace(VX.VersChaineHexa())
         K_VX est Entier256 = soustraction( K, VX)
         
         Trace("K-VX=" + K_VX.VersChaineHexa())
         
         VY est Entier256 = soustraction( VY2.valPoidsFaible, YY1.valPoidsFaible )
         Trace("VY=  " +VY.VersChaineHexa())
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : K1_K3
    identifier : 0x2e19a33400edabb1
    internal_properties : BQAAAAUAAABkW1kLJdOKRX5S1z0jnpQuXqbOz6GbXHd+c7flX5iiF696rcub7A8XEeMkDRGIpwtfh5eAFRFdRo0TDv6GzMwZAjmhrZ0Awdxz4u3r7HKNX9qjaEMKxDrBumfEPKIdUhwWKJJ6OhLyHbNoG9EO4n6ES0WmSXHBaThPpiQJFdN6C1FUPyWH/K1iXHbGqQJ719ea4QM6Zjgv+kE7EB0K2ydaBULnJywxjtR9MpZ5IWu724tGrvtCKpEKPLw7jZlMSiy2UjKJAquvtZ9uVwW5OtCzk4nknwAOllgbr7F7AMZWyx9509HLZHM2yuNTRcxh8Ie+/oCEh+Jm3LsdzdlkXwft++0UfpRIzksFbGfgoLEXJ2ryU6HQOScVUWmIG7kXSw1JGDZhPRoQL4AlgZNTvOLXTiJDJPtz6SO4Z1UGpW74uZPjGf2vNBBQcC9U2pTWKuBqlgCLUEjy4mcjP3lfQIsSJMcnBLu5OF7s2kKWHXDXoOLl9VxsLA7DJjg+rFcWBAGiKR0tNiLsb1qyDKScmlAWvEyuA0/JWOKqQ6dzs7/HvRgtAlAmBTChL9LRvbiCgBRha1DixctrdBAor0os3G/CYjSetbjIesUArjmtzIa6FR5C6NZh//CrtAgZA8ZKhBfu1Nlw/IDVYzCB9asfdKjvJHLFkc87xQcHLl+sMxVDzGAZjChkHJg0nPbsdaWFVB0cZRfb/V2vyjkLAyHvN4ks17475Z7DVeQ=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib	est ECDSA_BTC
         corps		est CorpsModulaire dynamique	= CrytoLib.corpsOrdre
         N est Entier256 = corps.P	
         // 					0x100000000000000000000000000000000 00000000000000000000000000000000
         _Lambda est Entier256("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72")
         //_0_256 est Entier256
         //nMax128Bit  est Entier256("0x100000000000000000000000000000000")
         
         CalculeCoefConstantEuclide( _Lambda )
         retour
         
         // renvoie x + L*y mod N
         procédure interne _F( x Entier256, y Entier256 ) : Entier256
         	res est Entier256 = corps.additionModulo( x, corps.multiplicationModulo( y, _Lambda ) )
         	renvoyer res
         fin
         
         
         
         // Test de multiplication par K (nombre "au hasard")
         K est Entier256("0x071e443c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef878")
         // cas a pb
         //K.val0	=0x8C9709EE2C00DB85
         //K.val1	=0xED340B2E31901BFD 
         //K.val2	=0x5DCE66E6049C6A08
         //K.val3	=0x7B5AAE134D8FDABF
         // cas a pb 2
         K.val0	=0xCD20AFA495B7BF2B	
         K.val1	=0xC1605B209D915713	 
         K.val2	=0x732947073A8716AF	
         K.val3	=0xF5CDDA00DF9C6B90	
         
         
         // renvoie V1,V2,signeV1,signeV2 tels que
         // V1 + V2*R = K ( modulo N)
         // avec V1 et V2 "petits" = sur ~128 bits 
         // signeV1 et signeV2 valent +1 ou -1
         procédure interne _calcVecteurOpimise( _k est Entier256 )  : (Entier256,Entier256, entier,entier)  
         
         	// constantes calculée par utilPourOptim.CalculeCoefConstantEuclide() :
         	_moinsDelta est Entier256("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141") // X2*Y1 -X1*Y2
         	V1_X        est Entier256("0x03086d221a7d46bcde86c90e49284eb15")
         	moinsV1_Y   est Entier256("0x0e4437ed6010e88286f547fa90abfe4c3")
         	V2_X        est Entier256("0x00e5e9bd2461792dd1aca54cdd1d8b2a6")
         	moinsV2_Y   est Entier256("0x58a1bcb25ae2b9cc084678edad30447a7")
         	
         	// B2,B2 : coefficients tels que "(K,0) - (B1*V1 + B2*V2)" soit sur ~128 bits
          	_B1      est Entier256 // ex : "0x276e6bcbe7ba30a0b216a78e91107e13"
         	_moinsB2 est Entier256 // ex : "0x0658d53831aae2574117afb315cc83da"
         	
         	moinsK_Y2 est Entier512 = multiplication256x256_512( _k, moinsV2_Y)	
         	moinsK_Y1 est Entier512 = multiplication256x256_512( _k, moinsV1_Y)
         		
         	trace("K1*Y2="+moinsK_Y2.VersChaineHexa())		
         	trace(moinsK_Y2.valPoidsFort.VersChaineHexa())		
         	trace("delta="+_moinsDelta.VersChaineHexa())		
         	// calcul de B1 =  K*Y1 / _Delta
         	//	         B2 = -K*Y2 / _DeltaZ
         	/// comme delta = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 ~= 2^256, 
         	//  on approxime la division par un décalage de 256 bits vers la droite.
         	_B1 	 = moinsK_Y2.valPoidsFort
         	_moinsB2 = moinsK_Y1.valPoidsFort
         	
         	//moinsK_Y2_haut est un entier512 = moinsK_Y2
         //	_DeltaLow.multiplieParUnePuissanceDe2(128)
              //moinsK_Y2_haut.multitpliePar2puissance128()
         //     Trace("moinsK_Y2_haut=" + moinsK_Y2_haut.VersChaineHexa())	
         	//moinsK_Y1.multitpliePar2puissance128()
         	// calcul de la division entière : donne un nombre de 128 bits si K est sur 256 bits
         //	reste est Entier256
         	//soit (     b1,reste) = divisionEuclidienne256(   moinsK_Y2_haut.valPoidsFort, _moinsDelta  )
         	//_B1.multiplieParUnePuissanceDe2(128)
         	//'0x1a08ee06c6ba89c9f5498001ad0306fdd4382c84d8d3008c7fd6305c0da8a294'
         	// idem B2
         	//(     _B2,reste) = divisionEuclidienne256(moinsK_Y1.valPoidsFort, _DeltaLow  )
         	//_B2.multiplieParUnePuissanceDe2(128)
         //	trace("b1: "+ b1.VersChaineHexa())
         	trace("_B1: "+ _B1.VersChaineHexa())
         	trace("_B2:-"+ _moinsB2.VersChaineHexa())
         	
         	// v = B1*V1 + B2*V2
         	// B1*V1
         	B1V1X  	    est Entier512	= multiplication256x256_512( _B1,      V1_X      )
         	moinsB1VY1	est Entier512	= multiplication256x256_512( _B1,      moinsV1_Y )
         	// B2*V2
         	moinsB2V2X	est Entier512	= multiplication256x256_512( _moinsB2, V2_X      )
         	B2V2Y	    est Entier512	= multiplication256x256_512( _moinsB2, moinsV2_Y )
         //	dbgAssertion(B1V1X.valPoidsFort.estEgalAZero())
         //	dbgAssertion(moinsB1VY1.valPoidsFort.estEgalAZero())
         //	dbgAssertion(moinsB2V2X.valPoidsFort.estEgalAZero())
         //	dbgAssertion(B2V2Y.valPoidsFort.estEgalAZero())
         	
         	// vx     = b1*v1.x + b2*v2.x
         	VX512	est Entier512	 = soustraction512(  B1V1X,   moinsB2V2X )
         	dbgAssertion(VX512.valPoidsFort.estEgalAZero())
         //	VX	est Entier256		  = corps.soustractionModulo(  B1V1X.valPoidsFaible,   moinsB2V2X.valPoidsFaible )
         	VX	est Entier256		  = VX512.valPoidsFaible
         	Trace(" B1V1X= "  +  B1V1X   .VersChaineHexa())
         	
         	Trace(" B2V2X=-"  +  moinsB2V2X   .VersChaineHexa())
         	Trace(" VX ="  + VX	.VersChaineHexa())
         	
         	// vy     = b1*v1.y + b2*v2.y
         	//B1VY1_256 est Entier256 = corps.négationModulo(moinsB1VY1.valPoidsFaible)
         	VY est Entier256         = corps.soustractionModulo(  B2V2Y.valPoidsFaible,  moinsB1VY1.valPoidsFaible   )
         	//moinsVY est Entier256    = addition(  moinsB1VY1.valPoidsFaible,  moinsB2V2X.valPoidsFaible ) 
         	Trace(" VY ="  +VY.VersChaineHexa())
         	//moinsVX est Entier256    = corps.négationModulo(VX)
         	moinsVY est Entier256    = corps.négationModulo(VY)
         		
         	// k - vx = K - (b2*v2.x - b1*v1.x)
         	KmoinsVX est Entier256 = corps.soustractionModulo( _k, VX)
         	//Trace("K-VX ="  + KmoinsVX.VersChaineHexa())
         	//Trace(" -VY ="  + moinsVY.VersChaineHexa())
         	
         	//_0_256_ est entier256
         	signeX est entier = 1
         	signeY est entier = 1
         	VX_Resultat	est Entier256 = KmoinsVX; // corps.additionModulo(     B1V1X.valPoidsFaible , B2V2X.valPoidsFaible ) 
         	VY_Resultat	est Entier256 = moinsVY; //corps.soustractionModulo( B1V1Y.valPoidsFaible , B2V2Y.valPoidsFaible ) 
         	// si VX_Test<0
         	si VX_Resultat.bit(255)=1 ALORS
         		// x' = -x
         		VX_Resultat = corps.négationModulo( VX_Resultat ) 
         		signeX  = -1
         	FIN
         		// si VX_Test<0
         	SI VY_Resultat.bit(255)=1 ALORS
         		// y' = -y
         		VY_Resultat	= corps.négationModulo( VY_Resultat ) 
         		signeY	= -1
         	FIN	
         	
         	// renvoie le vecteur (Lamda-(b1*v1+b2*v2))
         	renvoyer ( VX_Resultat, VY_Resultat, signeX, signeY )
         fin
         
         soit (k1,k2,signek1,signek2) = _calcVecteurOpimise(K)
         
         // on vérifie que le résultat a bien les propriétés attendues
         k1AvecSigne est entier256 = (signek1 = -1) ?  corps.négationModulo(k1) sinon k1
         k2AvecSigne est entier256 = (signek2 = -1) ?  corps.négationModulo(k2) sinon k2
         _Tmp est Entier256
         _Tmp = _F(k1AvecSigne, k2AvecSigne )
         dbgAssertion( _Tmp.estEgalA(K) ,"nombre pas OK")
         // k1 et k2 doivent êtres "petits"
         dbgAssertion( k1AvecSigne.val3 = 0)
         dbgAssertion( k1AvecSigne.val2 < 0x1000)
         dbgAssertion( k2AvecSigne.val3 = 0)
         dbgAssertion( k2AvecSigne.val2 < 0x1000)
         //sinonK
         //	_Tmp =  corps.négationModulo( _FMoins(k1, k2 ) )
         //fin
         Trace("-------------------------------------------------------------")
         Trace("k1:    =" + k1.VersChaineHexa()) 
         Trace("k2:    =" + k2.VersChaineHexa()) 
         Trace("k1+k2*L=" +_Tmp.VersChaineHexa())
         Trace("K=      " + K.VersChaineHexa())
         
         
         // N = générateur du groupe des points  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
         // P = ordre de la courbe               = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
         
         // un nombre d'odre 3.
         // ie tel que :  beta^3 = 1 modulo N
         // NB : tout nombre d'ordre 3 est OK.
         
         beta  	est Entier256("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
         // R tel que map(P) = R*P
         // racine du polynome : X^2 + X + 1 = 0 ( modulo P )
         _Racine est Entier256("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72")
         dbgAssertion(_Lambda.estEgalA(_Racine))
         
         	// (x, y) => (βx, y) 
         	PROCÉDURE INTERNE _map( _p est Point256 ) : Point256
         		pointRésultat est Point256 
         		pointRésultat.x	=  CrytoLib.corpsECC.multiplicationModulo( beta, _p.x )
         		pointRésultat.y	= _p.y
         		RENVOYER pointRésultat
         	FIN
         
         
         P est Point256 = CrytoLib.courbeBtc.pointGen
         P =  CrytoLib.courbeBtc.pointDouble(P)
         // on doit avoir _map(P) = _Racine * P
         mapP  est Point256 = _map(P)
         // gestion du cas ou les coefficients sont négatifs
         si signek1 = -1 ALORS
         	// P = -P
         	P = CrytoLib.courbeBtc.pointNégation(P)
         FIN
         SI signek2 = -1 ALORS
         	// P = -P
         	mapP = CrytoLib.courbeBtc.pointNégation(mapP)
         FIN
         bSigneOpose est un booléen = signek1<>signek2
         //ChronoDébut()
         // calcul optimisé
         //P1_optim		est Point256	=  CrytoLib.courbeBtc.multiplicationScalairePointJacobi( P,       k1   )
         //P2_optim		est Point256	=  CrytoLib.courbeBtc.multiplicationScalairePointJacobi( mapP,    k2  )
         
         //KfoisP_optim	est Point256	= CrytoLib.courbeBtc.pointPlusPoint(P1_optim, P2_optim )  
         //KfoisP_optim	est Point256	= CrytoLib.courbeBtc._multiplicationScalaire2PointJacobi(P, k1, k2, bSigneOpose )  
         //
         //trace(chronofin())
         //Trace("KfoisP_optim=")
         //Trace(KfoisP_optim.x.VersChaineHexa())
         //Trace(KfoisP_optim.y.VersChaineHexa())
         //
         //// calcul standard de "KP"
         //ChronoDébut()
         //KfoisP_defaut  est Point256 =  CrytoLib.courbeBtc.multiplicationScalairePointJacobi( P, K )
         //Trace(ChronoFin())
         //Trace("KfoisP_defaut=")
         //Trace(KfoisP_defaut.x.VersChaineHexa())
         //Trace(KfoisP_defaut.y.VersChaineHexa())
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : K1_K4
    identifier : 0x2e1ad517009b85a6
    internal_properties : BQAAAAUAAADNwtmwX5njbkYCeZ5NjLkf8UM1y1KamZCXiwnoMyeuC0oioeKQa2k7NzFcpCkAhjVvaTvBtjl7PWuLW/IjpG0/9/wEKdG2L4glMXdG7XioLWyWT6fIjnsVEPgi/q6QAichKmARRSW17oHE/xQ+hZwTHZeL26DX8tMLgURxLRLsGgGE0geygNrxg6srhIDcKtXC0T2bNBBb0+YQ7sStZAeYoP/e4XkLzQavN3iWMl3QTgJg1qz4wOwUGdxe2kEQbvg0R13HcW2gbMudDmVTDavijvCXaagG0n7jjh9rFPGB3Lf6OL6kCc0E9QZQLWZjkIeQNlVQczzjffIJlaO+npCgtpCMo3uc186fX3nUZw+OUwD0jwUJuLrRNyMemqfl8Wt0VFPnR3QqTfYZ8DnRzw4vD8xlq8X+zV7/DGpmirYpV+iiOAA9OyTn1rsi2HEF351mP4iluGulMDHGhatWJQ672ppYN3KDzwJzt6Hicur7Yb1FZQPrzKZjrqegs/ZQXQLsgsVGg8CgHv1B8WAgamDosAstgutfUb8UkVGowFnGkKwwDeZNYVLJ9m9szXjJEqvDLsGmK94+b5PClB9KJXK4UfjUlZzjZPV63xd7jrEqt6uPWFfMkRMox+9/LM8uIzM9NPam2U70LYVEbe052XhEZtR4J44rPRlU8aG4RPN0OlY2YL+dSzWpWmHS85EAU06CCqLaRB49EEI2HhU4SKo1hVG9Ws1OSpKTxEw=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         CrytoLib	est ECDSA_BTC
         
         // Test de multiplication par K (nombre "au hasard")
         //K est Entier256("0x071e443c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef878")
         K est Entier256
         // cas a pb
         K.val0=0xCD20AFA495B7BF2B	
         K.val1=0xC1605B209D915713	 
         K.val2=0x732947073A8716AF	
         K.val3=0xF5CDDA00DF9C6B90	
         
         //Point = 2*G , pour test
         P est Point256 = CrytoLib.courbeBtc.pointGen
         P =  CrytoLib.courbeBtc.pointDouble(P)
         
         ChronoDébut()
         
         KfoisP_optimJ	est Point256_3D	= CrytoLib.courbeBtc.multiplicationScalairePoint_OptimiseJacobi(P,  K )  
         KfoisP_optim	est Point256	= CrytoLib.courbeBtc._JacobiVersPoint( KfoisP_optimJ )
         
         trace(chronofin())
         Trace("KfoisP_optim=")
         Trace(KfoisP_optim.x.VersChaineHexa())
         Trace(KfoisP_optim.y.VersChaineHexa())
         
         // calcul standard de "KP"
         ChronoDébut()
         PJ est Point256_3D
         PJ.VersJacobi(P)
         KfoisP_defaut  est Point256_3D =  CrytoLib.courbeBtc.multiplicationScalairePointJacobi( PJ, K )
         Trace(ChronoFin())
         Trace("KfoisP_defaut=")
         Trace(KfoisP_defaut.x.VersChaineHexa())
         Trace(KfoisP_defaut.y.VersChaineHexa())
         Trace(KfoisP_defaut.z.VersChaineHexa())
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : ECDSA_VérifieSignature
    identifier : 0x2e1b496d009cf43f
    internal_properties : BQAAAAUAAAB5Jc6ml/0WGh4zSli2EaETIT6OXIRp9JlPJaw1nxxRxkTN0+Og0TEQQaD8qeoML3PECNuIhrU1xBX10roNOr4FWTmyhVDgBAYE5IihorMw5uoz2vy4pew9euewUosW1x+K+5ZzAL0GeBCf1qEJ18kUSQu72dAscMOBCImC9nOuTVs2qmUG5s0lGUFaJ1wuVTAZtsOt0s1GvkY3STsD5jmwJU94VKqdYw1ZypNaDbiGvUQ96yjo5nQuXN3RO8PDohOljoX9Y2W04A2C8f5jo/YZAz14yRVeM7MdEZyR5iBYxVXXSXVb/wiZSH7+tXm52rZe1zTG56rohYIDxVuDb9wM34cpM/O7Fl4Gn33SL9/nuToj0HzYRkBqLGeMBpVqE7/kBBMDcX1dpsrbL6qDSqLvD7U4OLmHB9HBcXgcGHU3PzJho87quUeuBiHgApKsSmFZpx1c1Xv0liHpvz3rzXWtkiIOedfi9DnFp0o5H6u7EXQxx4fdK3QKwVcySaPAhnAo6b92cRfGOs05tAv+zn+kQRtpc3pmskxJvK1iOQr4oRFEFd6SrqvbADcsszRL4tYCi91kBH+boSD70OoV1YKUA4HrNfRUs68DVVMuULC6yaDqYQZubupQ5AJ/HoJWhFZ81++QQiYtPpV81dNWjbvRxOOfqNIxxqyOYDc6LDzy7427oWAcbIZYUMmpwpCIOokfuvpi2QYouka5qAloWjJcYvvBCmsptlu5ZWSJ/MElwMfBKaWrbUEJLI6dNg==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         
         
         
         // signature
         signature est SignatureEcdsa
         signature.R.affecteAvecChaineHexa("381d97bbc2cfbe448bf256bdb5ff9cd6fdbe27726ee4d603a4f92fa541fa7518")
         signature.S.affecteAvecChaineHexa("040e51ef10775569752ce8258dd5c382e1a39ae6530ba1044a58bed5f8ca9d55")
         // clé pub
         CléPublique est Point256 //= CrytoLib.DériveCléPubliqueDepuisCléPrivée( ClePrivee )
         CléPublique.x.affecteAvecChaineHexa("5b0ec43c0ea2bb19964c367e44bfba69b3ec528a3c15a4122bb90ff42bcef87b")
         CléPublique.y.affecteAvecChaineHexa("b809f2a2d4c6423c2f946ff6499dffec78385fd75f97245910c358a4a55cfdb6")
         
         // valeur signée
         N est Entier256("12345678")
         
         sERR est chaine
         Trace("Calcul...")
         ChronoDébut()
         bOK est un booléen =  VerifieSignature( N, CléPublique, signature, sERR )
         Trace( "Temps (ms) : " + ChronoFin())
         trace("Vérif signature :" )
         Trace(bOK)
         Trace(sERR)
         
         
         
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Test_mult_3
    identifier : 0x2e1d51a8009da1c7
    internal_properties : BQAAAAUAAABQr+J59lu94zhlHpAiaiYTVxMC90LK4pMRZIo3ZO/DQZT+ZkGUnUb1+J8XbLW0H+EaYVNIr5bWipefHBD9QxmCyVfBupx76j/TvVa5gw4Rxt800pBb5bb/aBFo5a90GbOEEM3d9djhaJDa51E/liM02pGF4nBZKn6nng33oJTAOV9AucuNadh8KCwzlYWqwr0V8wH7xI2vKQZj3dk3gshZri8yxkc3+pN04yZvhf/+SEnfWAngCLDsgv40hrXsL/c3F7pHmyC9TK8dBrx1NUCvsp9X38h8rddnt0n3iYlfnWk+bWyIZ2mFqei25xCXqQH6AlmnXANazI86emf7enbA2CaUXYN6LFwGOdnp/Bz38z8u61tjjYk5Ils+K6wewEjbrfQnuMzy6oBuYfEINYG4susgB9ZqAS/vGU3WhQwy6qlLVfamPUIgxvzLjNIjXvr9BiVfkR1zdRM/UrEj5aGkGR2RETvD70HVcPZsV2QgsFKKJB144KKqHmzv+d3Wtp01UwyMnPrmoUESyPgr8jv5x4T4ikiDrTIApDiKiRCOQgqNFGhedd4umKxvV6FfLfyybd5sAiBwnDbL+ADGXmq0shUfxBq0XJX8JOMt8SFZb1dAjpLnL6PY6hx0IJnMscmriGCwkCBza9URH8yDspxM+yZw7qgRde4a/P/HVfmcrvoysFl2YlwOuEykeBoOKqaz9/FxKsykWKjNFqUnGra7iFIQyFt2lrVfomAQxxKo2qp1OY4wIOWRIspI2cCXZs5loQ==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         //gCorps est CorpsMudulaire_sepc256k1 //( "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F" )
         
         
         x est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         y est Entier256("0x43cf5d4541155780f44aa34089024a194415bd27e39f7acf86848972528faaae") 
         
         // TEST
         //sDLL est chaine = "C:\Users\Paul Albert\Source\myRepo\LibInt256\x64\DebugDLL\LibInt256.dll"
         sDLL est chaine = "C:\Users\Paul Albert\Source\myRepo\LibInt256\x64\ReleaseDLL\LibInt256.dll"
         dbgAssertion(fFichierExiste(sDLL))
         ChargeDLL(sDLL)
         si ErreurDétectée ALORS
         	erreur()
         	retour
         FIN
         
         //extern "C" void multiplication256x256_256(byte * pNombreA, byte * pNombreB, OUT byte * pResultat, OUT byte * pResultatH);
         hModule est un entier système = API("kernel32","GetModuleHandleA","LibInt256.dll")
         dbgAssertion(hModule<>0)
         pAddr est un entier système = API("kernel32","GetProcAddress",hModule,"multiplication256x256_256")
         dbgAssertion(pAddr<>0,"multiplication256x256_256 non trouvée")
         
         xy_L est entier256
         xy_H est entier256
         
         API(pAddr, &x, &y, &xy_L, &xy_H)
         
         //ChronoDébut()
         //POUR i = 1 a 10 000
         //	//API(sDLL,"multiplicationMudulo_sepc256k1", &x, &y, &xy)
         //	API(pAddr, &x, &y, &xy)
         //	//Trace(xy.VersChaineHexa())
         //	//x = xy
         //fin
         //soit dureeAlgo3 = ChronoFin()
         Trace( xy_H.VersChaineHexa() + xy_L.VersChaineHexa())
         //retour
         
         xy512 est Entier512 = multiplication256x256_512(x,y)
         trace( xy512.VersChaineHexa())
         
         //
         //// nouvel algo
         ChronoDébut()
         pour i = 1 a 1 000 000
         	x.affecteAvecBuffer(HasardCryptoBuffer(32)  ) 
         	y.affecteAvecBuffer(HasardCryptoBuffer(32)  ) 
         	// code c++ / asm
         	API(pAddr, &x, &y, &xy_L, &xy_H)
         	// de de test
         	xy512 = multiplication256x256_512(x,y)
         	dbgAssertion( xy512.valPoidsFort.estEgalA(xy_H )  )
         	dbgAssertion( xy512.valPoidsFaible.estEgalA(xy_L) )
         
         //	 xy2 <- gCorps.multiplicationModulo(x, y)
         
         
         fin
         Trace("OK")
         //si pas xy2.estEgalA(xy) ALORS
         //	trace("*****ERR*****")
         //FIN
         //soit dureeAlgo1 = ChronoFin()
         //
         //// ancien
         //ChronoDébut()
         //POUR i = 1 À 1000
         //	xy_TEST <- gCorps.multiplicationModulo_OLD(x, y)
         //fin
         //soit dureeAlgo2 = ChronoFin()
         //
         //
         ////trace(x.VersChaineHexa())
         ////trace(y.VersChaineHexa())
         //trace(xy2.VersChaineHexa()+";"+dureeAlgo1..EnMillisecondes+"ms")
         //trace(xy_TEST.VersChaineHexa()+";"+dureeAlgo2..EnMillisecondes+"ms")
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Test_mult_4
    identifier : 0x2e1d5d3700dbc959
    internal_properties : BQAAAAUAAAB4vKHeA3iMziWy7HfvthjHHD3v9TZZvBzarX7x5A2nFUFqJ1B8XtQVrKUZOVQiWSG4AU0/PqSyP1xDAlvaioS/Jj68Vbp1uhy24eDVSbTGl4D8W54SpeljVvjbvOhulSww9ZkV5MLkGwrB8sdcpw89dujwD5WKmd4dtCnhQtYOkPYXer/lP6VWofUAdasYq55fKVlYHFCDYvnMJ3NrfeJu08A38w2Ev5ezi4fhiFT/UDol4g0W4xpEhB5a8FVnZC9pX9EPTUawxAiKFu5aN5nTunIfrcf49bLX0WU1UWyCfIe4wm6R0egDZ9vyMoudGxY5eseeAOce29+4e/j1ZlsYetodqkcgHTM+/78i+IsDRrJbe5N+84r+ERj8k7iw97m39wsWjtVNvwnnEequrwA4B+Te/HI/UERGalVZIXDJ4liauw8IchnNPyFF5/QRsTiM8atWLZoayo7SEgLBV/LsnqzRXm0qxEy4u2RlYcp1whHzcOIWmwtl46932G+Ez40SaGYThHPB1uxtANl9kJwnpsvkLSqCGrEhexpDuYBrHFlQ5Ckc0AfZ/yVDLkUrzjKhWAYR6FfjA8ua5rWOxoGcowqV715RmxZNEZmM4TFsI7INCHV3fpAjkVNkUTsrOx4x3HuYp2hHSh6elRIM5v0cz+/fTqFjZYJD+2cE0PK9xQI54n0lRGld/uHZB5SkTdp5c8qVAELwQIzYSN0cVjUYXZ/FgSy6NpSJHYcwhajn7olWoKigaf6fR7FwPqc01R77u67duJpWOtA=
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         gCorps est CorpsMudulaire_sepc256k1 //( "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F" )
         
         
         x est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         y est Entier256("0x43cf5d4541155780f44aa34089024a194415bd27e39f7acf86848972528faaae") 
         
         
         
         // TEST
         //sDLL est chaine = "C:\Users\Paul Albert\Source\myRepo\LibInt256\x64\DebugDLL\LibInt256.dll"
         sDLL est chaine = "C:\Users\Paul Albert\Source\myRepo\LibInt256\x64\ReleaseDLL\LibInt256.dll"
         dbgAssertion(fFichierExiste(sDLL))
         ChargeDLL(sDLL)
         si ErreurDétectée ALORS
         	erreur()
         	retour
         FIN
         
         //extern "C" void multiplicationModulo_sepc256k(byte * pNombreA, byte * pNombreB, OUT byte * pResultat);
         hModule est un entier système = API("kernel32","GetModuleHandleA","LibInt256.dll")
         dbgAssertion(hModule<>0)
         pAddr est un entier système = API("kernel32","GetProcAddress",hModule,"multiplicationModulo_sepc256k")
         dbgAssertion(pAddr<>0,"multiplicationModulo_sepc256k non trouvée")
         
         xy est entier256
         API(pAddr, &x, &y, &xy )
         
         //ChronoDébut()
         //POUR i = 1 a 10 000
         //	//API(sDLL,"multiplicationMudulo_sepc256k1", &x, &y, &xy)
         //	API(pAddr, &x, &y, &xy)
         //	//Trace(xy.VersChaineHexa())
         //	//x = xy
         //fin
         //soit dureeAlgo3 = ChronoFin()
         Trace( xy.VersChaineHexa() )
         //retour
         
         xy_DBG est Entier256 = gCorps.multiplicationModulo(x,y)
         trace( xy_DBG.VersChaineHexa())
         //retour
         //
         //// nouvel algo
         ChronoDébut()
         pour i = 1 a 1 000 000
         	x.affecteAvecBuffer(HasardCryptoBuffer(32)  ) 
         	y.affecteAvecBuffer(HasardCryptoBuffer(32)  ) 
         	// code c++ / asm
         	API(pAddr, &x, &y, &xy )
         	// de de test
         	xy_DBG  = gCorps.multiplicationModulo(x,y)
         	dbgAssertion( xy_DBG.estEgalA(xy )  )
         
         
         fin
         Trace("PASSED OK")
         //si pas xy2.estEgalA(xy) ALORS
         //	trace("*****ERR*****")
         //FIN
         //soit dureeAlgo1 = ChronoFin()
         //
         //// ancien
         //ChronoDébut()
         //POUR i = 1 À 1000
         //	xy_TEST <- gCorps.multiplicationModulo_OLD(x, y)
         //fin
         //soit dureeAlgo2 = ChronoFin()
         //
         //
         ////trace(x.VersChaineHexa())
         ////trace(y.VersChaineHexa())
         //trace(xy2.VersChaineHexa()+";"+dureeAlgo1..EnMillisecondes+"ms")
         //trace(xy_TEST.VersChaineHexa()+";"+dureeAlgo2..EnMillisecondes+"ms")
        type : 18
      -
        type : 161
        enabled : false
  -
    name : Test_mult_5
    identifier : 0x2e233a3f009df4e7
    internal_properties : BQAAAAUAAADhYjXfCTOBfQOJzKjgVIjirpmFtuKgM2GAci/SwpZ4s0aPTvoJgLgBu0u4n3ZZWqdTnOgXP5YGlfGzvcMGzzHhSZdlo3Fh5OiJYGsBFQVHCjZ8nwcQMvCYrj3bsZ9awRk+0+duIhMMbUKOfaz3WZfD6MQcoEqhbxh31n1cjCwdTyFWAHmN+JkK95wh5JOOjvr7BX0+/fEven12WaVJCRJJVxRYHJ0HSZSsMnnE2/79M7HZQK2oaqiu1dVtJob17ip6P5XQ3mlFyX7emnODG5FKb3jLNcp84D+FRaI79awKIj4l6pvgnnmGFAWOayRPG9MbAjpGHnaGka6b6v/bjHYOiei73RtCpEl4Rrw0rG/Ni5kU5eyBMVin/YuLwAscU+y0cLNcD69Sjkov1DZ0VjRROubM3bgnW8/taOgrQaFXge3mQ6KgSOzMGDNsW6LWW3lfv3WhrbSZhQGceZrTpnz164xdX0uuS1fHFdvvKVWDyXrL3FcIp9L0cJNQ+NGPFdollAZIBg1S8yeBr0ETifjw8TvYEGAapXiqaQW9vX0ZbQwc/PaW5khm3sly1KWIiuP6jBb2tn8AaM72R2Hwh3GZtrQLrmKTJmnm39yMH7CaQlPXbiQLtF24lv+bCc04G3uAZJ9HgapZqmodb+yUF89dwpz9fT1iZ1J0s5xAuGrmWYRwiVXoje/lh1MFlGOdMqH12uUvL0ZjNwVszXnuEy2WBWRV2SvkRS4VZNEz9kKyp6ZL6b19ukKZgOTIk0OEDtacpZ3vDUBBKXX8w3lyVQ==
    type : 4
    code_elements :
     type_code : 4
     p_codes :
      -
        code : |1+
         gCorps est CorpsMudulaire_sepc256k1 //( "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F" )
         
         
         x est Entier256("0xea92bdc008249e599c2570ab25deff4b35b971c0a059add76a64ce20724128d0") 
         y est Entier256("0x43cf5d4541155780f44aa34089024a194415bd27e39f7acf86848972528faaae") 
         
         
         
         // TEST
         sCodeAssembleur est chaine
         sCodeAssembleur = fChargeRessourceTexte("multiplicationModulo_sepc256k.asm")
         // compiler le coder assembleur vers une procédure WL
         procMult256x256Modulo est  entier système = compileAsmX86_API(sCodeAssembleur) 
         SI ErreurDétectée ALORS
         	Erreur()
         	RETOUR
         FIN
         sAddr est chaine = "0x" + EntierVersHexa(procMult256x256Modulo,16)
         Trace( sAddr)
         VersPressePapier(sAddr)
         
         
         xy est entier256
         API(procMult256x256Modulo, &x, &y, &xy )
         //xy_DBG  = gCorps.multiplicationModulo(x,y)
         //dbgAssertion( xy_DBG.estEgalA(xy )  )
         
         
         //ChronoDébut()
         //POUR i = 1 a 10 000
         //	//API(sDLL,"multiplicationMudulo_sepc256k1", &x, &y, &xy)
         //	API(pAddr, &x, &y, &xy)
         //	//Trace(xy.VersChaineHexa())
         //	//x = xy
         //fin
         //soit dureeAlgo3 = ChronoFin()
         Trace( xy.VersChaineHexa() )
         
         
         xy_DBG est Entier256 = gCorps.multiplicationModulo(x,y)
         trace( xy_DBG.VersChaineHexa())
         //retour
         //
         //// nouvel algo
         ChronoDébut()
         pour i = 1 a 1 000 000
         	x.affecteAvecBuffer(HasardCryptoBuffer(32)  ) 
         	y.affecteAvecBuffer(HasardCryptoBuffer(32)  ) 
         	// code c++ / asm
         	API(procMult256x256Modulo, &x, &y, &xy )
         	// de de test
         	xy_DBG  = gCorps.multiplicationModulo(x,y)
         	dbgAssertion( xy_DBG.estEgalA(xy )  )
         
         
         fin
         Trace("PASSED OK")
         //si pas xy2.estEgalA(xy) ALORS
         //	trace("*****ERR*****")
         //FIN
         //soit dureeAlgo1 = ChronoFin()
         //
         //// ancien
         //ChronoDébut()
         //POUR i = 1 À 1000
         //	xy_TEST <- gCorps.multiplicationModulo_OLD(x, y)
         //fin
         //soit dureeAlgo2 = ChronoFin()
         //
         //
         ////trace(x.VersChaineHexa())
         ////trace(y.VersChaineHexa())
         //trace(xy2.VersChaineHexa()+";"+dureeAlgo1..EnMillisecondes+"ms")
         //trace(xy_TEST.VersChaineHexa()+";"+dureeAlgo2..EnMillisecondes+"ms")
        type : 18
      -
        type : 161
        enabled : false
 menu :
  name : _Menu
  identifier : 0x292573e513b5f221
  internal_properties : BQAAAAUAAABd4biPtdLQOwfUFiqrit8H4xfGqKyz9t6VLxCUnNZRQiLPVs82PZNE+UVdKRzjizyeuKyRur85gNMUfqplpmtNDnQWQla9zo+GH9+1EfUJ6w17Dn/egD/gv+Hhywk8c9unIdzEp7EHgaAqD28w7Agveg4u19PBcKGZtQ==
  options : []
 languages :
  - fr-FR
 popup_menus : []
 message_bar :
  internal_properties : BQAAAAUAAABqPQh6HC8RxAVkp2SqPYLuZrfVhd+1KX4lx22hIT8uqEpE6yP7Sbc2rmVqdmL816EWzXOkEe9ijOtYwchZKAfpy3B1cNqhpJgsnbUs
 code_elements :
  internal_properties : BQAAAAUAAABWIHrh1Yb2YcVvIfiiRDSu3aXMOSCmrRDPwCP2jtbUBEGFOv+qg2ayVXoCZujUnWzZv/mop+WO+JtZ1Q==
  type_code : 1
  p_codes :
   -
     code : |1+
      PROCEDURE MaFenêtre()
   -
     code : |1+
      
      
     type : 34
   -
     code : |1+
      
      
     type : 2
   -
     code : |1+
      
      
     type : 40
   -
     code : |1+
      
      
     type : 234
   -
     code : |1+
      
      
     type : 165
   -
     code : |1+
      
      
     type : 177
   -
     code : |1+
      
      
     type : 180
   -
     type : 230
     enabled : false
  procedures :
   -
     name : PGCD_Ex
     procedure_id : 1994461367820771349
     type_code : 14
     code : |1+
      
      PROCEDURE PGCD_Ex( nA entier, nB entier)
      
      dbgAssertion(nB > nA )
      
      r, u, v   sont des entiers
      r_,u_,v_ sont des entiers
      //reste est un entier
      quotient est entier 
      
      // init
      r  = nA 
      r_ = nB
      u  = 1
      v  = 0
      u_ = 0
      v_ = 1
      
      tantque r_ <> 0
          quotient =  r / r_
          
          // sauver les valeur précédentes
          rTemp,uTemp,vTemp sont des entiers
          rTemp = r;
          uTemp = u;
          vTemp = v;
          
          r =r_
          u =u_
          v =v_ 
          
          // calcul du reste
      	r_ 	 =  rTemp- r_*quotient
      	dbgAssertion(r_>=0)
       	u_Avant est entier = u_
       	v_Avant est entier = v_
      	u_ = uTemp - quotient * u_
      	v_ = vTemp - quotient * v_
      	//trace( complete(u_+"",4," ") + " = " + Complète(uTemp+"",4," ") + "- " + quotient + " * " + u_Avant )
      	trace( complete(r_+"",4," ") + " = " + Complète(uTemp+"",4," ") + " + " + quotient + " * " + u_Avant )
      fin
      
     type : 458752
   -
     name : PGCD_ExR
     procedure_id : 1994470541871085041
     type_code : 14
     code : |1+
      // version résursive
      PROCEDURE PGCD_ExR( nA entier, nB entier, u=1, u_ =0 )
      
      //dbgAssertion(nB > nA )
      
      r   sont des entiers
      r_  sont des entiers
      //reste est un entier
      quotient est entier 
      
      // init
      r  = nA 
      r_ = nB
      
      
      si  r_ = 0 ALORS
      	renvoyer ( r, r_ ,  u, u_) 
      
      FIN
      
          quotient =  r / r_
          
          // sauver les valeur précédentes
          rTemp,uTemp sont des entiers
          rTemp = r;
          uTemp = u;
          r	  = r_
          u     = u_
          
          // calcul du reste
      	r_ 	 =  rTemp- r_*quotient
      	dbgAssertion(r_>=0)
       	uPourTrace est entier = u_
      	u_ = uTemp - quotient * u_
      	trace( complete(u_+"",4," ") + " = " + Complète(uTemp+"",4," ") + "- " + quotient + " * " +uPourTrace )
      	// récursion
      	( r, r_ ,  u, u_) = PGCD_ExR( r, r_,u,u_)
      	
      renvoyer  ( r, r_ ,  u, u_)
      
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BQAAAAUAAAAwjDLmDSZ0H1P68nJIeNfqR9EvRjU/K+sVcM1T6rhVNr+VTV1mZ/rmoweYbFDZUhBGcv8UsxlDxVCOnb2U/SQOvlGWzNby3/w/V+ppSymxv+Vh
  original_name : Modele1
resources :
 string_res :
  identifier : 0x1b7cfed701529005
  internal_properties : BQAAAAUAAAAa2Zm8J9E/zh+/WIrVvz1fER/So3PB0gjQuxc1xKQVWY4ZDm5lfg==
custom_note :
 internal_properties : BQAAAAUAAAC68/W0/adbG0nFCRhrE42B5HRnbDzVHaz86sSQyxlBk7I=
rad :
 internal_properties : BQAAAAUAAABoAN7PLpwJW3EiA7WVZdCA5EwrCA1rvutcDHooMWKe
